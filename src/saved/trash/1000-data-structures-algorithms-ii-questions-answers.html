<html>
<head>
<style>
.hk1_style{
  background-color: rgb(199, 193, 193);
}
</style>
</head>
                <body>
				<h2 style="text-align:center">1000-data-structures-algorithms-ii-questions-answers</h2><p><b>1. Where is linear searching used?<br>
a) When the list has only a few elements<br>
b) When performing a single search in an unordered list<br>
c) Used all the time<br>
d) When the list has only a few elements and When performing a single search in an unordered list<br>
</b></p><i>Answer: d<br>
Explanation: It is practical to implement linear search in the situations mentioned in When the list has only a few elements and When performing a single search in an unordered list, but for larger elements the complexity becomes larger and it makes sense to sort the list and employ binary search or hashing.</i><p><b>2. Select the code snippet which performs unordered linear search iteratively?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw4">int</span> unorderedLinearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> size, <span class="kw4">int</span> data<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> index<span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> data<span class="br0">)</span>
        <span class="br0">{</span>
            index <span class="sy0">=</span> i<span class="sy0">;</span>
            <span class="kw1">break</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw4">int</span> unorderedLinearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> size, <span class="kw4">int</span> data<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> index<span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> data<span class="br0">)</span>
        <span class="br0">{</span>
            <span class="kw1">break</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw4">int</span> unorderedLinearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> size, <span class="kw4">int</span> data<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> index<span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> size<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> data<span class="br0">)</span>
        <span class="br0">{</span>
            index <span class="sy0">=</span> i<span class="sy0">;</span>
            <span class="kw1">break</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw4">int</span> unorderedLinearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> size, <span class="kw4">int</span> data<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> index<span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> data<span class="br0">)</span>
        <span class="br0">{</span>
            index <span class="sy0">=</span> i<span class="sy0">;</span>
            <span class="kw1">break</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Unordered term refers to the given array, that is, the elements need not be ordered. To search for an element in such an array, we need to loop through the elements until the desired element is found.</i><p><b>3. What is the best case for linear search?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(1)<br>
</b></p><i>Answer: d<br>
Explanation: The element is at the head of the array, hence O(1).</i><p><b>4. What is the worst case for linear search?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(1)<br>
</b></p><i>Answer: c<br>
Explanation: Worst case is when the desired element is at the tail of the array or not present at all, in this case you have to traverse till the end of the array, hence the complexity is O(n).</i><p><b>5. Select the code snippet which performs ordered linear search iteratively?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> linearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>,<span class="kw4">int</span> key,<span class="kw4">int</span> size<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> index <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	   <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span><span class="br0">(</span>size <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
       <span class="br0">{</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
             <span class="br0">{</span>
		  index <span class="sy0">=</span> i<span class="sy0">;</span>
             <span class="br0">}</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span><span class="br0">)</span> 
             <span class="br0">{</span>
		 index <span class="sy0">=</span> i<span class="sy0">;</span>
                 <span class="kw1">break</span><span class="sy0">;</span>
             <span class="br0">}</span>
             i<span class="sy0">++;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> linearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>,<span class="kw4">int</span> key,<span class="kw4">int</span> size<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> index <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	   <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span><span class="br0">(</span>size <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
       <span class="br0">{</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
             <span class="br0">{</span>
		  index <span class="sy0">=</span> i<span class="sy0">;</span>
             <span class="br0">}</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span><span class="br0">)</span> 
             <span class="br0">{</span>
                  <span class="kw1">break</span><span class="sy0">;</span>
             <span class="br0">}</span>
             i<span class="sy0">++;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> linearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>,<span class="kw4">int</span> key,<span class="kw4">int</span> size<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> index <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	   <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span><span class="br0">(</span>size <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
       <span class="br0">{</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
             <span class="br0">{</span>
		<span class="kw1">break</span><span class="sy0">;</span>
             <span class="br0">}</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span><span class="br0">)</span> 
             <span class="br0">{</span>
                 index <span class="sy0">=</span> i<span class="sy0">;</span>
             <span class="br0">}</span>
             i<span class="sy0">++;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> linearSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>,<span class="kw4">int</span> key,<span class="kw4">int</span> size<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> index <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	   <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span><span class="br0">(</span>size <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
       <span class="br0">{</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
             <span class="br0">{</span>
		<span class="kw1">break</span><span class="sy0">;</span>
             <span class="br0">}</span>
             <span class="kw1">if</span><span class="br0">(</span>data<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span><span class="br0">)</span> 
             <span class="br0">{</span>
                 <span class="kw1">break</span><span class="sy0">;</span>
                 index<span class="sy0">=</span>i<span class="sy0">;</span> 
             <span class="br0">}</span>
             i<span class="sy0">++;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> index<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The term ordered refers to the items in the array being sorted(here we assume ascending order). So traverse through the array until the element, if at any time the value at i exceeds key value, it means the element is not present in the array. This provides a slightly better efficiency than unordered linear search.</i><p><b>6. What is the best case and worst case complexity of ordered linear search?<br>
a) O(nlogn), O(logn)<br>
b) O(logn), O(nlogn)<br>
c) O(n), O(1)<br>
d) O(1), O(n)<br>
</b></p><i>Answer: d<br>
Explanation: Although ordered linear search is better than unordered when the element is not present in the array, the best and worst cases still remain the same, with the key element being found at first position or at last position.</i><p><b>7. Choose the code snippet which uses recursion for linear search.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">void</span> linSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> first, <span class="kw4">int</span> last, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>first <span class="sy0">==</span> last<span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"-1"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
        <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>first<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
                <span class="br0">{</span>
			<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>first<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
                <span class="br0">{</span>
			linSearch<span class="br0">(</span>arr, first<span class="sy0">+</span><span class="nu0">1</span>, last, key<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">      <span class="kw1">public</span> <span class="kw4">void</span> linSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> first, <span class="kw4">int</span> last, <span class="kw4">int</span> key<span class="br0">)</span>
      <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>first <span class="sy0">==</span> last<span class="br0">)</span>
                <span class="br0">{</span>
			<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"-1"</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
                <span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>first<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
                        <span class="br0">{</span>
				<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>first<span class="br0">)</span><span class="sy0">;</span>
			<span class="br0">}</span>
			<span class="kw1">else</span>
                        <span class="br0">{</span>
				linSearch<span class="br0">(</span>arr, first<span class="sy0">+</span><span class="nu0">1</span>, last<span class="sy0">-</span><span class="nu0">1</span>, key<span class="br0">)</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
      <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">void</span> linSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> first, <span class="kw4">int</span> last, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>first <span class="sy0">==</span> last<span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"-1"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
        <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>first<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
                <span class="br0">{</span>
			<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>last<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
                <span class="br0">{</span>
			linSearch<span class="br0">(</span>arr, first<span class="sy0">+</span><span class="nu0">1</span>, last, key<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">void</span> linSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> first, <span class="kw4">int</span> last, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>first <span class="sy0">==</span> last<span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"-1"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
        <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>first<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
                <span class="br0">{</span>
			<span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>first<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
                <span class="br0">{</span>
			linSearch<span class="br0">(</span>arr, first<span class="sy0">+</span><span class="nu0">1</span>, last<span class="sy0">+</span><span class="nu0">1</span>, key<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Every time check the key with the array value at first index, if it is not equal then call the function again with an incremented first index.</i><p><b>8. What does the following piece of code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j <span class="sy0">=</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> arr.<span class="me1">length</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">equals</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>i <span class="sy0">!=</span> j<span class="br0">)</span> <span class="br0">)</span>
        <span class="br0">{</span>
            <span class="kw3">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Print the duplicate elements in the array<br>
b) Print the element with maximum frequency<br>
c) Print the unique elements in the array<br>
d) Prints the element with minimum frequnecy<br>
</b></p><i>Answer: a<br>
Explanation: The print statement is executed only when the items are equal and their indices are not.</i><p><b>9. Select the code snippet which prints the element with maximum frequency.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> findPopular<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>a <span class="sy0">==</span> <span class="kw2">null</span> <span class="sy0">||</span> a.<span class="me1">length</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw3">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> previous <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> popular <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw4">int</span> maxCount <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a.<span class="me1">length</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> previous<span class="br0">)</span>
		count<span class="sy0">++;</span>
		<span class="kw1">else</span> 
                <span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>count <span class="sy0">&gt;</span> maxCount<span class="br0">)</span> 
                        <span class="br0">{</span>
				popular <span class="sy0">=</span> a<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				maxCount <span class="sy0">=</span> count<span class="sy0">;</span>
			<span class="br0">}</span>
		previous <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
		count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> count <span class="sy0">&gt;</span> maxCount <span class="sy0">?</span> a<span class="br0">[</span>a.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">:</span> popular<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> findPopular<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>a <span class="sy0">==</span> <span class="kw2">null</span> <span class="sy0">||</span> a.<span class="me1">length</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw3">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> previous <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> popular <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw4">int</span> maxCount <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a.<span class="me1">length</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> previous<span class="br0">)</span>
			count<span class="sy0">++;</span>
		<span class="kw1">else</span> 
                <span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>count <span class="sy0">&gt;</span> maxCount<span class="br0">)</span> 
                        <span class="br0">{</span>
				popular <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
				maxCount <span class="sy0">=</span> count<span class="sy0">;</span>
			<span class="br0">}</span>
			previous <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
			count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> count <span class="sy0">&gt;</span> maxCount <span class="sy0">?</span> a<span class="br0">[</span>a.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">:</span> popular<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> findPopular<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>a <span class="sy0">==</span> <span class="kw2">null</span> <span class="sy0">||</span> a.<span class="me1">length</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw3">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> previous <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> popular <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw4">int</span> maxCount <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a.<span class="me1">length</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> previous<span class="br0">)</span>
			count<span class="sy0">++;</span>
		<span class="kw1">else</span> 
                <span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>count <span class="sy0">&gt;</span> maxCount<span class="br0">)</span> 
                        <span class="br0">{</span>
				popular <span class="sy0">=</span> a<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				maxCount <span class="sy0">=</span> count<span class="sy0">;</span>
			<span class="br0">}</span>
			previous <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
			count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> count <span class="sy0">&gt;</span> maxCount <span class="sy0">?</span> a<span class="br0">[</span>a.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">:</span> popular<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Traverse through the array and see if it is equal to the previous element, since the array is sorted this method works with a time complexity of O(nlogn), without sorting a Brute force technique must be applied for which the time complexity will be O(n<sup>2</sup>).</i><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> findPopular<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>a <span class="sy0">==</span> <span class="kw2">null</span> <span class="sy0">||</span> a.<span class="me1">length</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw3">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> previous <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> popular <span class="sy0">=</span> a<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
	<span class="kw4">int</span> count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw4">int</span> maxCount <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a.<span class="me1">length</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">==</span> previous<span class="br0">)</span>
			count<span class="sy0">++;</span>
		<span class="kw1">else</span> 
                <span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>count <span class="sy0">&gt;</span> maxCount<span class="br0">)</span> 
                        <span class="br0">{</span>
				popular <span class="sy0">=</span> a<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				maxCount <span class="sy0">=</span> count<span class="sy0">;</span>
			<span class="br0">}</span>
			previous <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
			count <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> count <span class="sy0">&gt;</span> maxCount <span class="sy0">?</span> a<span class="br0">[</span>a.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">:</span> popular<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>10. Which of the following is a disadvantage of linear search?<br>
a) Requires more space<br>
b) Greater time complexities compared to other searching algorithms<br>
c) Not easy to understand<br>
d) Not easy to implement<br>
</b></p><i>Answer: b<br>
Explanation: The complexity of linear search as the name suggests is O(n) which is much greater than other searching techniques like binary search(O(logn)). Linear search is easy to implement and understand than other searching techniques.</i><p><b>1. Is there any difference in the speed of execution between linear serach(recursive) vs linear search(lterative)?<br>
a) Both execute at same speed<br>
b) Linear search(recursive) is faster<br>
c) Linear search(Iterative) is faster<br>
d) Cant be said<br>
</b></p><i>Answer: c<br>
Explanation: The Iterative algorithm is faster than the latter as recursive algorithm has overheads like calling function and registering stacks repeatedly.</i><p><b>2. Is the space consumed by the linear search(recursive) and linear search(iterative) same?<br>
a) No, recursive algorithm consumes more space<br>
b) No, recursive algorithm consumes less space<br>
c) Yes<br>
d) Nothing can be said<br>
</b></p><i>Answer: a<br>
Explanation: The recursive algorithm consumes more space as it involves the usage the stack space(calls the function numerous times).</i><p><b>3. What is the worst case runtime of linear search(recursive) algorithm?<br>
a) O(n)<br>
b) O(logn)<br>
c) O(n<sup>2</sup>)<br>
d) O(nx)<br>
</b></p><i>Answer: a<br>
Explanation: In the worst case scenario, there might be a need of calling the stack n times. Therfore O(n).</i><p><b>4. Linear search(recursive) algorithm used in _____________<br>
a) When the size of the dataset is low<br>
b) When the size of the dataset is large<br>
c) When the dataset is unordered<br>
d) Never used<br>
</b></p><i>Answer: a<br>
Explanation: It is used when the size of the dataset is low as its runtime is O(n) which is more when compared to the binary search O(logn).</i><p><b>5. The array is as follows: 1,2,3,6,8,10. At what time the element 6 is found? (By using linear search(recursive) algorithm)<br>
a) 4th call<br>
b) 3rd call<br>
c) 6th call<br>
d) 5th call<br>
</b></p><i>Answer: a<br>
Explanation: Provided that the search starts from the first element, the function calls itself till the element is found. In this case, the element is found in 4th call.</i><p><b>6. The array is as follows: 1,2,3,6,8,10. Given that the number 17 is to be searched. At which call it tells that there’s no such element? (By using linear search(recursive) algorithm)<br>
a) 7th call<br>
b) 9th call<br>
c) 17th call<br>
d) The function calls itself infinite number of times<br>
</b></p><i>Answer: a<br>
Explanation: The function calls itself till the element is found. But at the 7th call it terminates as goes outside the array.</i><p><b>7. What is the best case runtime of linear search(recursive) algorithm on an ordered set of elements?<br>
a) O(1)<br>
b) O(n)<br>
c) O(logn)<br>
d) O(nx)<br>
</b></p><i>Answer: a<br>
Explanation: The best case occurs when the given element to be found is at the first position. Therefore O(1) is the correct answer. </i><p><b>8. Which of the following code snippet performs linear search recursively?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">        <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">==</span>key<span class="br0">)</span>
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"element found"</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">        LinearSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="sy0">,</span> n<span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">&lt;</span><span class="nu0">1</span><span class="br0">)</span>
		<span class="kw1">return</span> False
		<span class="kw1">if</span><span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">==</span>key<span class="br0">)</span>
		<span class="kw1">return</span> True
		<span class="kw1">else</span>
		LinearSearch<span class="br0">(</span>a<span class="sy0">,</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">        LinearSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="sy0">,</span> n<span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">&lt;</span><span class="nu0">1</span><span class="br0">)</span>
		<span class="kw1">return</span> True
		<span class="kw1">if</span><span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">==</span>key<span class="br0">)</span>
		<span class="kw1">return</span> False
		<span class="kw1">else</span>
		LinearSearch<span class="br0">(</span>a<span class="sy0">,</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">        LinearSearch<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="sy0">,</span> n<span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">&lt;</span><span class="nu0">1</span><span class="br0">)</span>
		<span class="kw1">return</span> False
		<span class="kw1">if</span><span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">==</span>key<span class="br0">)</span>
		<span class="kw1">return</span> True
		<span class="kw1">else</span>
		LinearSearch<span class="br0">(</span>a<span class="sy0">,</span>n<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span>key<span class="br0">)</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Compare n with first element in arr[]. If element is found at first position, return it. Else recur for remaining array and n.<br>
</i><p><b>9. Can linear search recursive algorithm and binary search recursive algorithm be performed on an unordered list?<br>
a) Binary search can’t be used<br>
b) Linear search can’t be used<br>
c) Both cannot be used<br>
d) Both can be used<br>
</b></p><i>Answer: a<br>
Explanation: As binary search requires comparison, it is required that the list be ordered. Whereas this doesn’t matter for linear search.</i><p><b>10. What is the recurrence relation for the linear search recursive algorithm?<br>
a) T(n-2)+c<br>
b) 2T(n-1)+c<br>
c) T(n-1)+c<br>
d) T(n+1)+c<br>
</b></p><i>Answer: c<br>
Explanation: After each call in the recursive algorithm, the size of n is reduced by 1. Therefore the optimal solution is T(n-1)+c.  </i><p><b>1. What is the advantage of recursive approach than an iterative approach?<br>
a) Consumes less memory<br>
b) Less code and easy to implement<br>
c) Consumes more memory<br>
d) More code has to be written<br>
</b></p><i>Answer: b<br>
Explanation: A recursive approach is easier to understand and contains fewer lines of code.</i><p><b>2. Choose the appropriate code that does binary search using recursion.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> recursive<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> low, <span class="kw4">int</span> high, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> mid<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,mid<span class="sy0">+</span><span class="nu0">1</span>,high,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,low,mid<span class="sy0">-</span><span class="nu0">1</span>,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> recursive<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> low, <span class="kw4">int</span> high, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">+</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> mid<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,mid<span class="sy0">-</span><span class="nu0">1</span>,high,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,low,mid<span class="sy0">+</span><span class="nu0">1</span>,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> recursive<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> low, <span class="kw4">int</span> high, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> mid<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,mid,high,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,low,mid<span class="sy0">-</span><span class="nu0">1</span>,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> recursive<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> low, <span class="kw4">int</span> high, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span><span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> mid<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,mid,high,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw1">return</span> recursive<span class="br0">(</span>arr,low,mid<span class="sy0">-</span><span class="nu0">1</span>,key<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Calculate the ‘mid’ value, and check if that is the key, if not, call the function again with 2 sub arrays, one with till mid-1 and the other starting from mid+1. </i><p><b>3. Given an input arr = {2,5,7,99,899}; key = 899; What is the level of recursion?<br>
a) 5<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: level 1: mid = 7<br>
level 2: mid = 99<br>
level 3: mid = 899(this is the key).</i><p><b>4. Given an array arr = {45,77,89,90,94,99,100} and key = 99; what are the mid values(corresponding array elements) in the first and second levels of recursion?<br>
a) 90 and 99<br>
b) 90 and 94<br>
c) 89 and 99<br>
d) 89 and 94<br>
</b></p><i>Answer: a<br>
Explanation: At first level key = 90<br>
At second level key= 99<br>
Here 90 and 99 are mid values. </i><p><b>5. What is the worst case complexity of binary search using recursion?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Using the divide and conquer master theorem.</i><p><b>6. What is the average case time complexity of binary search using recursion?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: T(n) = T(n/2) + 1, Using the divide and conquer master theorem.</i><p><b>7. Which of the following is not an application of binary search?<br>
a) To find the lower/upper bound in an ordered sequence<br>
b) Union of intervals<br>
c) Debugging<br>
d) To search in unordered list<br>
</b></p><i>Answer: d<br>
Explanation: In Binary search, the elements in the list should be sorted. It is applicable only for ordered list. Hence Binary search in unordered list is not an application. </i><p><b>8. Choose among the following code for an iterative binary search.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> iterative<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> high <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span>
	<span class="br0">{</span>
		mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">+</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">return</span> mid<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			low <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
		<span class="br0">{</span>
			high <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> iterative<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> high <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span>
	<span class="br0">{</span>
		mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">return</span> mid<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
		<span class="br0">{</span>
			high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> iterative<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> high <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span>
	<span class="br0">{</span>
		mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">+</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">return</span> mid<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
		<span class="br0">{</span>
			high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> iterative<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> mid <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw4">int</span> high <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span>
	<span class="br0">{</span>
		mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">return</span> mid<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span>
		<span class="br0">{</span>
			low <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw1">else</span>
		<span class="br0">{</span>
			high <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Find the ‘mid’, check if it equals the key, if not, continue the iterations until low &lt;= high.</i><p><b>9. Binary Search can be categorized into which of the following?<br>
a) Brute Force technique<br>
b) Divide and conquer<br>
c) Greedy algorithm<br>
d) Dynamic programming<br>
</b></p><i>Answer: b<br>
Explanation: Since ‘mid’ is calculated for every iteration or recursion, we are diving the array into half and then try to solve the problem.</i><p><b>10. Given an array arr = {5,6,77,88,99} and key = 88; How many iterations are done until the element is found?<br>
a) 1<br>
b) 3<br>
c) 4<br>
d) 2<br>
</b></p><i>Answer: d<br>
Explanation: Iteration1 : mid = 77; Iteration2 : mid = 88;</i><p><b>11. Given an array arr = {45,77,89,90,94,99,100} and key = 100; What are the mid values(corresponding array elements) generated in the first and second iterations?<br>
a) 90 and 99<br>
b) 90 and 100<br>
c) 89 and 94<br>
d) 94 and 99<br>
</b></p><i>Answer: a<br>
Explanation: Trace the input with the binary search iterative code.</i><p><b>12. What is the time complexity of binary search with iteration?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: T(n) = T(n/2) + theta(1)<br>
Using the divide and conquer master theorem, we get the time complexity as O(logn).</i><p><b>1. In which of the cases uniform binary search fails compared to binary search?<br>
a) A table lookup is generally faster than an addition and a shift<br>
b) Many searches will be performed on the same array<br>
c) Many searches will be performed on several arrays of the same length<br>
d) Complexity of code<br>
</b></p><i>Answer: d<br>
Explanation: Uniform binary search code is more complex to implement than binary search as it involves mid points to be computed in hand before search.</i><p><b>2. Which of the following is a suitable lookup table that can be used in the uniform binary search?(N is the number of elements in the array and the delta array is global)<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> make_delta<span class="br0">(</span><span class="kw4">int</span> N<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> power <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">do</span> 
       <span class="br0">{</span>
            <span class="kw4">int</span> half <span class="sy0">=</span> power<span class="sy0">;</span>
            power <span class="sy0">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy0">;</span>
            delta<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="br0">(</span>N <span class="sy0">+</span> half<span class="br0">)</span> <span class="sy0">/</span> power<span class="sy0">;</span>
       <span class="br0">}</span> 
       <span class="kw1">while</span> <span class="br0">(</span>delta<span class="br0">[</span>i<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> make_delta<span class="br0">(</span><span class="kw4">int</span> N<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> power <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">do</span> 
       <span class="br0">{</span>
            <span class="kw4">int</span> half <span class="sy0">=</span> power<span class="sy0">;</span>
            power <span class="sy0">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy0">;</span>
            delta<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="br0">(</span>N <span class="sy0">+</span> half<span class="br0">)</span> <span class="sy0">/</span> power<span class="sy0">;</span>
       <span class="br0">}</span> 
       <span class="kw1">while</span> <span class="br0">(</span>delta<span class="br0">[</span>i<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> make_delta<span class="br0">(</span><span class="kw4">int</span> N<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> power <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">do</span> 
       <span class="br0">{</span>
            <span class="kw4">int</span> half <span class="sy0">=</span> power<span class="sy0">;</span>
            power <span class="sy0">&gt;&gt;=</span> <span class="nu0">1</span><span class="sy0">;</span>
            delta<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="br0">(</span>N <span class="sy0">+</span> half<span class="br0">)</span> <span class="sy0">/</span> power<span class="sy0">;</span>
       <span class="br0">}</span>
       <span class="kw1">while</span> <span class="br0">(</span>delta<span class="br0">[</span>i<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> make_delta<span class="br0">(</span><span class="kw4">int</span> N<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> power <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">do</span> 
       <span class="br0">{</span>
            <span class="kw4">int</span> half <span class="sy0">=</span> power<span class="sy0">;</span>
            power <span class="sy0">&lt;&lt;=</span> <span class="nu0">1</span><span class="sy0">;</span>
            delta<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="br0">(</span>N <span class="sy0">-</span> half<span class="br0">)</span> <span class="sy0">/</span> power<span class="sy0">;</span>
       <span class="br0">}</span> 
       <span class="kw1">while</span> <span class="br0">(</span>delta<span class="br0">[</span>i<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: This provides a single lookup index and the values are dependent on the the number of elements(N) in the array.</i><p><b>3. Given delta[4] is a global array and number of elements in the sorted array is 10, what are the values in the delta array?<br>
a) 4, 3, 1, 0<br>
b) 5, 3, 1, 0<br>
c) 4, 2, 1, 1<br>
d) 5, 2, 1, 1<br>
</b></p><i>Answer: b<br>
Explanation: Trace with respect to the make_delta function, always note that the last element is always 0.</i><p><b>4. Choose the appropriate code snippet that performs uniform binary search.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> unisearch<span class="br0">(</span><span class="kw4">int</span> key<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> delta<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
       <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
       <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">==</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                <span class="kw1">return</span> i<span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>delta<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> 
            <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                    i <span class="sy0">+=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    i <span class="sy0">-=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
            <span class="br0">}</span>
       <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> unisearch<span class="br0">(</span><span class="kw4">int</span> key<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> delta<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
       <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
       <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">==</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                <span class="kw1">return</span> i<span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>delta<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> 
            <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                    i <span class="sy0">-=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    i <span class="sy0">+=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
            <span class="br0">}</span>
       <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> unisearch<span class="br0">(</span><span class="kw4">int</span> key<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> delta<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
       <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
       <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">==</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                <span class="kw1">return</span> i<span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>delta<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> 
            <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                    i <span class="sy0">-=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    i <span class="sy0">+=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
            <span class="br0">}</span>
       <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> unisearch<span class="br0">(</span><span class="kw4">int</span> key<span class="br0">)</span> 
<span class="br0">{</span>
       <span class="kw4">int</span> i <span class="sy0">=</span> delta<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
       <span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
       <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">==</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                <span class="kw1">return</span> i<span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>delta<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
                <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> 
            <span class="br0">{</span>
                <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
                    i <span class="sy0">+=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    i <span class="sy0">+=</span> delta<span class="br0">[</span><span class="sy0">++</span>j<span class="br0">]</span><span class="sy0">;</span>
            <span class="br0">}</span>
       <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: Unlike the usual binary search which a low, high and a mid variable and every time comparing the key with the mid value, the comparing index is obtained from the lookup delta table, choosing the left or right side of the array is same as with the normal binary search.</i><p><b>5. What is the time complexity of uniform binary search?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: With every iteration we are dividing the array into two parts(though not equal halves), the complexity remains same as the normal binary search.</i><p><b>7. How can Jump Search be improved?<br>
a) Start searching from the end<br>
b) Begin from the kth item, where k is the step size<br>
c) Cannot be improved<br>
d) Step size should be other than sqrt(n)<br>
</b></p><i>Answer: b<br>
Explanation: Tracing with the above code, comparison #1: i=4, comparison #2: i=7, comparison #3: i=8</i><p><b>8. Which of the following false about Jump Search?<br>
a) Jump Search is better than Linear Search<br>
b) Useful when jumping back is more costly than jumping forward<br>
c) Jump Search is worse than Binary Search<br>
d) Jump search starts from the index 0 even though specified index is k<br>
</b></p><i>Answer: b<br>
Explanation: This gives a very slight improvement as you are skipping the first k elements.</i><p><b>1. Jump search algorithm requires which of the following condition to be true?<br>
a) array should be sorted<br>
b) array should have not be sorted<br>
c) array should have a less than 64 elements<br>
d) array should be partially sorted<br>
</b></p><i>Answer: a<br>
Explanation: Jump sort requires the input array to be sorted. The algorithm would fail to give the correct result if array is not sorted. </i><p><b>2. Jumps are made in the jump search algorithm until ___________<br>
a) element having value less than that of the required element is found<br>
b) element having value equal to the median of values of the array is found<br>
c) element having value greater than that of the required element is found<br>
d) middle element is found equal to the element being searched<br>
</b></p><i>Answer: c<br>
Explanation: In jump search algorithm jumps are made until element having value greater than the value of element being searched is found. After this linear search is performed in backwards direction.</i><p><b>3. Which of the following step is taken after finding an element having value greater than the element being searched?<br>
a) linear search takes place in the forward direction<br>
b) linear search takes place in the backward direction<br>
c) binary search takes place in the forward direction<br>
d) binary search takes place in a backward direction<br>
</b></p><i>Answer: b<br>
Explanation: First an element having value greater than the element being searched is found. After this linear search is performed in a backward direction.</i><p><b>4. How many jumps will be made in the worst case of jump search(let block jumped =k)?<br>
a) n*k<br>
b) n/k<br>
c) k/n<br>
d) n+k<br>
</b></p><i>Answer: b<br>
Explanation: Worst case occurs when the value to be searched is in the last section of the array. So, in this case the number of jumps will be n/k.</i><p><b>5. What will be the maximum number of comparisons that can be made in jump search algorithm (assuming k to be blocks jumped)?<br>
a) k<br>
b) n/k<br>
c) k-1<br>
d) k-1<br>
</b></p><i>Answer: c<br>
Explanation: Worst case occurs when the element being searched is present just after the element that has been compared while making the last jump. So, in this case k-1 comparisons will have to be made.</i><p><b>6. What is the value of jump taken for maximum efficiency while implementing jump search?<br>
a) n/2<br>
b) n<sup>2</sup><br>
c) n<sup>1/2</sup><br>
d) log n<br>
</b></p><i>Answer: c<br>
Explanation: Total number of comparisons required will be n/k + k-1 in worst case. This function will be minimum for k=n<sup>1/2</sup>. So this value of jump will be the best for implementing jump search.</i><p><b>7. What is the auxiliary space requirement of the jump search?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(n<sup>1/2</sup>)<br>
d) O(1)<br>
</b></p><i>Answer: d<br>
Explanation: Jump search does not require any additional space for searching the required element. Thus its auxiliary space requirement will be O(1).</i><p><b>8. Which of the following searching algorithm is fastest?<br>
a) jump search<br>
b) binary search<br>
c) linear search<br>
d) all are equally fast<br>
</b></p><i>Answer: b<br>
Explanation: Binary search has the least time complexity (equal to log n) out of the given searching algorithms. This makes binary search preferable in most cases.</i><p><b>9. In which of the following case jump search will be preferred over binary search?<br>
a) jumping backwards takes significantly more time than jumping forward<br>
b) jumping forward takes significantly more time than jumping backwards<br>
c) when the given array is very large in size<br>
d) when the given array is very small in size<br>
</b></p><i>Answer: a<br>
Explanation: Jump search only needs to jump backwards once, while a binary can jump backwards up to log n times. Thus jump search will be preferred over binary search if jumping backwards is expensive.</i><p><b>10. Best case of jump search will have time complexity of _________<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Best case of jump search will be when the first element of the array is the element that is being searched. In this case only one comparison will be required. Thus it will have a time complexity of O(1).</i><p><b>11. Which of the following code correctly represent jump search?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw4">int</span> step <span class="sy0">=</span> n<span class="sy0">*</span>n<span class="sy0">;</span> 
    <span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev <span class="sy0">=</span> step<span class="sy0">;</span> 
        step <span class="sy0">+=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev<span class="sy0">++;</span> 
&nbsp;
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
        <span class="kw1">return</span> prev<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw4">int</span> step <span class="sy0">=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev <span class="sy0">=</span> step<span class="sy0">;</span> 
        step <span class="sy0">+=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev<span class="sy0">++;</span> 
&nbsp;
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
        <span class="kw1">return</span> prev<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw4">int</span> step <span class="sy0">=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev <span class="sy0">=</span> step<span class="sy0">;</span> 
        step <span class="sy0">+=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> n<span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev<span class="sy0">++;</span> 
&nbsp;
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
        <span class="kw1">return</span> prev<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw4">int</span> step <span class="sy0">=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev <span class="sy0">=</span> step<span class="sy0">;</span> 
        step <span class="sy0">+=</span> <span class="kw3">sqrt</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&gt;</span> x<span class="br0">)</span> 
    <span class="br0">{</span> 
        prev<span class="sy0">++;</span> 
&nbsp;
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> min<span class="br0">(</span>step<span class="sy0">,</span> n<span class="br0">)</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
&nbsp;
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
        <span class="kw1">return</span> prev<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The correct code first makes jumps until an element greater than the required element is found. Then linear search is performed in a backwards direction. If the element is not found then we return -1.</i><p><b>1. Which algorithmic technique does Fibonacci search use?<br>
a) Brute force<br>
b) Divide and Conquer<br>
c) Greedy Technique<br>
d) Backtracking<br>
</b></p><i>Answer: b<br>
Explanation: With every iteration, we divide the given array into two sub arrays(not necessarily equal).</i><p><b>2. Choose the recursive formula for the Fibonacci series.(n&gt;=1)<br>
a) F(n) = F(n+1) + F(n+2)<br>
b) F(n) = F(n) + F(n+1)<br>
c) F(n) = F(n-1) + F(n-2)<br>
d) F(n) = F(n-1) – F(n-2)<br>
</b></p><i>Answer: c<br>
Explanation: None.</i><p><b>3. Write a function for the Fibonacci search method.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> fibSearch<span class="br0">(</span><span class="kw1">final</span> <span class="kw4">int</span> key, <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
        <span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> high <span class="sy0">=</span> a.<span class="me1">length</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibCurrent <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibPrev <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> N <span class="sy0">=</span> a.<span class="me1">length</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span> 
        <span class="br0">{</span>
            <span class="kw1">while</span><span class="br0">(</span>fibCurrent <span class="sy0">&lt;</span> N<span class="br0">)</span>
            <span class="br0">{</span>
                <span class="kw4">int</span> tmp <span class="sy0">=</span> fibCurrent <span class="sy0">+</span> fibPrev<span class="sy0">;</span>
                fibPrev <span class="sy0">=</span> fibCurrent<span class="sy0">;</span>
                fibCurrent <span class="sy0">=</span> tmp<span class="sy0">;</span>
                N <span class="sy0">=</span> N <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">-</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
            <span class="kw1">final</span> <span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span> <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">+</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span>      <span class="br0">(</span>key <span class="sy0">&lt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&gt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">return</span> mid<span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> fibSearch<span class="br0">(</span><span class="kw1">final</span> <span class="kw4">int</span> key, <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
        <span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> high <span class="sy0">=</span> a.<span class="me1">length</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibCurrent <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibPrev <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> N <span class="sy0">=</span> a.<span class="me1">length</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span> 
        <span class="br0">{</span>
            <span class="kw4">int</span> tmp <span class="sy0">=</span> fibCurrent <span class="sy0">+</span> fibPrev<span class="sy0">;</span>
            fibPrev <span class="sy0">=</span> fibCurrent<span class="sy0">;</span>
            fibCurrent <span class="sy0">=</span> tmp<span class="sy0">;</span>
            N <span class="sy0">=</span> N <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">-</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">final</span> <span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span> <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">+</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span>      <span class="br0">(</span>key <span class="sy0">&lt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&gt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">return</span> mid<span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> fibSearch<span class="br0">(</span><span class="kw1">final</span> <span class="kw4">int</span> key, <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
        <span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> high <span class="sy0">=</span> a.<span class="me1">length</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibCurrent <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibPrev <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> N <span class="sy0">=</span> a.<span class="me1">length</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span> 
        <span class="br0">{</span>
            <span class="kw1">while</span><span class="br0">(</span>fibCurrent <span class="sy0">&lt;</span> N<span class="br0">)</span>
            <span class="br0">{</span>
                <span class="kw4">int</span> tmp <span class="sy0">=</span> fibCurrent <span class="sy0">+</span> fibPrev<span class="sy0">;</span>
                fibPrev <span class="sy0">=</span> fibCurrent<span class="sy0">;</span>
                fibCurrent <span class="sy0">=</span> tmp<span class="sy0">;</span>
                N <span class="sy0">=</span> N <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">-</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
            <span class="kw1">final</span> <span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span> <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">+</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span>      <span class="br0">(</span>key <span class="sy0">&lt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> low <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&gt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">return</span> mid<span class="sy0">;</span>
        <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> fibSearch<span class="br0">(</span><span class="kw1">final</span> <span class="kw4">int</span> key, <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="br0">)</span> 
<span class="br0">{</span>
        <span class="kw4">int</span> low <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        <span class="kw4">int</span> high <span class="sy0">=</span> a.<span class="me1">length</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibCurrent <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> fibPrev <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw4">int</span> N <span class="sy0">=</span> a.<span class="me1">length</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span>low <span class="sy0">&lt;=</span> high<span class="br0">)</span> 
        <span class="br0">{</span>
            <span class="kw1">while</span><span class="br0">(</span>fibCurrent <span class="sy0">&lt;</span> N<span class="br0">)</span>
            <span class="br0">{</span>
                <span class="kw4">int</span> tmp <span class="sy0">=</span> fibCurrent <span class="sy0">+</span> fibPrev<span class="sy0">;</span>
                fibPrev <span class="sy0">=</span> fibCurrent<span class="sy0">;</span>
                fibCurrent <span class="sy0">=</span> tmp<span class="sy0">;</span>
                N <span class="sy0">=</span> N <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">-</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
            <span class="kw1">final</span> <span class="kw4">int</span> mid <span class="sy0">=</span> low <span class="sy0">+</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span> <span class="sy0">-</span> <span class="br0">(</span>fibCurrent <span class="sy0">+</span> fibPrev<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span>      <span class="br0">(</span>key <span class="sy0">&lt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> low <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>key <span class="sy0">&gt;</span> a<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span> high <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="kw1">else</span> <span class="kw1">return</span> mid<span class="sy0">;</span>
        <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Here instead of choosing middle of the array as a point of array division, we use Fibonacci numbers, the division index are strictly between two Fibonacci numbers.</i><p><b>4. What is the time complexity of Fibonacci Search?<br>
a) O(logn)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(nlogn)<br>
</b></p><i>Answer: a<br>
Explanation: Since it divides the array into two parts, although not equal, its time complexity is O(logn), it is better than binary search in case of large arrays.</i><p><b>5. Which of the following is not an advantage of Fibonacci Search?<br>
a) When the element being searched for has a non uniform access storage<br>
b) Can be used in magnetic tapes<br>
c) Can be used for large arrays which do not fit in the CPU cache or in the RAM<br>
d) It can be applied efficiently on unsorted arrays<br>
</b></p><i>Answer: d<br>
Explanation: When the speed of access depends on the location previously accessed, Fibonacci search is better compared to binary search as it performs well on those locations which have lower dispersion. Fibonacci search won’t work on unsorted arrays. The input should be a sorted array or array should be sorted before Fibonacci search. </i><p><b>6. What is the length of the step in jump search?<br>
a) n<br>
b) n/2<br>
c) sqrt(n)<br>
d) 1<br>
</b></p><i>Answer: c<br>
Explanation: If the step size is 1, it becomes a linear search, if it is n, we reach the end of the list in just on step, if it is n/2, it becomes similar to binary search, therefore the most efficient step size is found to be sqrt(n).</i><p><b>7. Select the code snippet for Jump Search.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> size <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">;</span>
	<span class="kw4">int</span> step <span class="sy0">=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="br0">(</span>step <span class="sy0">&gt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev <span class="sy0">=</span> step<span class="sy0">;</span>
		step <span class="sy0">+=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>step <span class="sy0">&gt;=</span> size<span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev<span class="sy0">++;</span>
		<span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> <span class="br0">(</span>step <span class="sy0">&lt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">return</span> prev<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> size <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">;</span>
	<span class="kw4">int</span> step <span class="sy0">=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="br0">(</span>step <span class="sy0">&lt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev <span class="sy0">=</span> step<span class="sy0">;</span>
		step <span class="sy0">+=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>step <span class="sy0">&gt;=</span> size<span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev<span class="sy0">++;</span>
		<span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> <span class="br0">(</span>step <span class="sy0">&lt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">return</span> prev<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> size <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">;</span>
	<span class="kw4">int</span> step <span class="sy0">=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="br0">(</span>step <span class="sy0">&gt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev <span class="sy0">=</span> step<span class="sy0">;</span>
		step <span class="sy0">+=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>step <span class="sy0">&gt;=</span> size<span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev<span class="sy0">++;</span>
		<span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> <span class="br0">(</span>step <span class="sy0">&lt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">return</span> prev<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw4">int</span> jumpSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> key<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> size <span class="sy0">=</span> arr.<span class="me1">length</span><span class="sy0">;</span>
	<span class="kw4">int</span> step <span class="sy0">=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw4">int</span> prev <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="br0">(</span>step <span class="sy0">&gt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">]</span> <span class="sy0">&lt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev <span class="sy0">=</span> step<span class="sy0">;</span>
		step <span class="sy0">+=</span> floor<span class="br0">(</span>sqrt<span class="br0">(</span>size<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="kw1">if</span> <span class="br0">(</span>step <span class="sy0">&lt;=</span> size<span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		prev<span class="sy0">++;</span>
		<span class="kw1">if</span> <span class="br0">(</span>prev <span class="sy0">==</span> <span class="br0">(</span>step <span class="sy0">&lt;</span> size <span class="sy0">?</span> step <span class="sy0">:</span> size<span class="br0">)</span><span class="br0">)</span> 
                <span class="br0">{</span>
			<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>prev<span class="br0">]</span> <span class="sy0">==</span> key<span class="br0">)</span> 
        <span class="br0">{</span>
		<span class="kw1">return</span> prev<span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: After finding the correct block of k elements, a sequential search is performed in this block.</i><p><b>8. What is the time complexity of Jump Search?<br>
a) O(logn)<br>
b) O(n)<br>
c) O(sqrt(n))<br>
d) O(nlogn)<br>
</b></p><i>Answer: c<br>
Explanation: Since the size of the step is sqrt(n), the complexity is also obviously O(sqrt(n)).</i><p><b>1. Exponential search algorithm requires which of the following condition to be true?<br>
a) array should be sorted<br>
b) array should have not be sorted<br>
c) array should have a less than 128 elements<br>
d) array should be partially sorted<br>
</b></p><i>Answer: a<br>
Explanation: Exponential sort requires the input array to be sorted. The algorithm would fail to give the correct result if array is not sorted. </i><p><b>2. Which of the following searching algorithm is used with exponential sort after finding the appropriate range?<br>
a) Linear search<br>
b) Binary search<br>
c) Jump search<br>
d) Fibonacci Search<br>
</b></p><i>Answer: b<br>
Explanation: In exponential search, we first find a range where the required elements should be present in the array. Then we apply binary search in this range.</i><p><b>3. Exponential search has ____________<br>
a) neither an exponential space complexity nor exponential time complexity<br>
b) exponential time complexity but a linear space complexity<br>
c) exponential space complexity but a linear time complexity<br>
d) both exponential time and space complexity<br>
</b></p><i>Answer: a<br>
Explanation: Exponential search has neither an exponential space complexity nor exponential time complexity. It is named exponential search because it searches for an element in an exponential manner.</i><p><b>5. What is the time complexity of exponential sort?<br>
a) O(n)<br>
b) O(2n)<br>
c) O(n log n)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In exponential search we first find the range where the element being searched can be present before applying binary search. We do this by comparing the value of element under search with the array elements present at the positions 1,2,4,8….n. </i><p><b>6. What is the auxiliary space requirement of an exponential sort when used with iterative binary search?<br>
a) O(n)<br>
b) O(2<sup>n</sup>)<br>
c) O(1)<br>
d) O(log n)<br>
</b></p><i>Answer: d<br>
Explanation: In exponential search, we first find a range where the required elements should be present in the array. Then we apply binary search in this range. This takes O(log n) time in the worst case.</i><p><b>7. What is the auxiliary space requirement of the exponential sort when used with recursive binary search?<br>
a) O(n)<br>
b) O(2<sup>n</sup>)<br>
c) O(1)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: Exponential search does not require any auxiliary space for finding the element being searched. So it has a constant auxiliary space O(1).</i><p><b>8. Which of the following searching algorithm is fastest?<br>
a) jump search<br>
b) exponential search<br>
c) linear search<br>
d) all are equally fast<br>
</b></p><i>Answer: d<br>
Explanation: Exponential search requires an auxiliary space of log n when used with recursive binary search. This space is required for the recursion call stack space.</i><p><b>9. In which of the following case jump search will be preferred over exponential search?<br>
a) jumping backwards takes significantly more time than jumping forward<br>
b) jumping forward takes significantly more time than jumping backwards<br>
c) when the given array is very large in size<br>
d) when the given array is very small in size<br>
</b></p><i>Answer: b<br>
Explanation: Exponential search has the least time complexity (equal to log n) out of the given searching algorithms. This makes exponential search preferable in most cases.</i><p><b>10. Best case of the exponential search will have time complexity of?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Jump search only needs to jump backwards once, while an exponential search can jump backwards up to log n times. Thus jump search will be preferred if jumping backwards is expensive.</i><p><b>11. Which of the following code correctly represent exponential search?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> expSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> x<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">while</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> x<span class="br0">)</span> 
		i <span class="sy0">=</span> i<span class="sy0">*</span><span class="nu0">2</span><span class="sy0">;</span> 
&nbsp;
<span class="kw1">return</span> binarySearch<span class="br0">(</span>arr<span class="sy0">,</span> i<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">,</span> min<span class="br0">(</span>i<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span> x<span class="br0">)</span><span class="sy0">;</span>
<span class="co1">//applies binary search in the calculated range</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> expSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> x<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">while</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> x<span class="br0">)</span> 
		i <span class="sy0">=</span> i<span class="sy0">*</span><span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw1">return</span> binarySearch<span class="br0">(</span>arr<span class="sy0">,</span> i<span class="sy0">,</span> min<span class="br0">(</span>i<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span> x<span class="br0">)</span><span class="sy0">;</span>
<span class="co1">//applies binary search in the calculated range</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> expSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> x<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
	<span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">while</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> x<span class="br0">)</span> 
		i <span class="sy0">=</span> i<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> 
&nbsp;
<span class="kw1">return</span> binarySearch<span class="br0">(</span>arr<span class="sy0">,</span> i<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">,</span> min<span class="br0">(</span>i<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span> x<span class="br0">)</span><span class="sy0">;</span>
<span class="co1">//applies binary search in the calculated range</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> expSearch<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> x<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">==</span> x<span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">while</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> x<span class="br0">)</span> 
		i <span class="sy0">=</span> i<span class="sy0">*</span><span class="nu0">2</span><span class="sy0">;</span> 
&nbsp;
<span class="kw1">return</span> binarySearch<span class="br0">(</span>arr<span class="sy0">,</span> i<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">,</span> max<span class="br0">(</span>i<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span> x<span class="br0">)</span><span class="sy0">;</span> 
<span class="co1">//applies binary search in the calculated range</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Best case of the exponential search will be when the first element of the array is the element that is being searched. In this case, only one comparison will be required. Thus it will have a time complexity of O(1).</i><p><b>14. Choose the incorrect statement about exponential search from the following.<br>
a) Exponential search is an in place algorithm<br>
b) Exponential search has a greater time complexity than binary search<br>
c) Exponential search performs better than binary search when the element being searched is present near the starting point of the array<br>
d) Jump search has a greater time complexity than an exponential search<br>
</b></p><i>Answer: a<br>
Explanation: In exponential search we first find a range where the required element should be present in the array. Then we apply binary search in this range.</i><p><b>15. Which of the following is not an alternate name of exponential search?<br>
a) Logarithmic search<br>
b) Doubling search<br>
c) Galloping search<br>
d) Struzik search<br>
</b></p><i>Answer: b<br>
Explanation: The worst case time complexity of jump search and exponential searches are O(n1/2) and O(log n) respectively. So exponential search is better in terms of time complexity.</i><p><b>1. Which of the following is the most desirable condition for interpolation search?<br>
a) array should be sorted<br>
b) array should not be sorted but the values should be uniformly distributed<br>
c) array should have a less than 64 elements<br>
d) array should be sorted and the values should be uniformly distributed<br>
</b></p><i>Answer: d<br>
Explanation: Desirable condition for interpolation search is that the array should be sorted and the values should be uniformly distributed. The algorithm would fail to give the correct result if array is not sorted. </i><p><b>2. Interpolation search is a variation of?<br>
a) Linear search<br>
b) Binary search<br>
c) Jump search<br>
d) Exponential search<br>
</b></p><i>Answer: b<br>
Explanation: Interpolation search is a variation of binary search which gives the best result when the array has uniformly distributed values. Interpolation search goes to different positions depending on the value being searched whereas binary search always goes to the middle element.</i><p><b>3. Interpolation search performs better than binary search when?<br>
a) array has uniformly distributed values but is not sorted<br>
b) array is sorted and has uniform distribution of values<br>
c) array is sorted but the values are not uniformly distributed<br>
d) array is not sorted<br>
</b></p><i>Answer: b<br>
Explanation: Interpolation search is an improvement over a binary search for the case when array is sorted and has uniformly distributed values. Binary search performs better when the values are not distributed uniformly.</i><p><b>4. In which of the following case jump search performs better than interpolation search?<br>
a) When array has uniformly distributed values but is not sorted<br>
b) when array is sorted and has uniform distribution of values<br>
c) when array is sorted but the values increases exponentially<br>
d) when array is not sorted<br>
</b></p><i>Answer: c<br>
Explanation: In case of non uniform distribution of values the time complexity of interpolation search is O(n) whereas the average time complexity of jump search is O(n<sup>1/2</sup>). So in such a case jump search has a better performance.</i><p><b>5. What is the time complexity of interpolation search when the input array has uniformly distributed values and is sorted?<br>
a) O(n)<br>
b) O(log log n)<br>
c) O(n log n)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Interpolation search goes to different positions in the array depending on the value being searched. It is an improvement over binary search and has a time complexity of O(log log n).</i><p><b>6. What is the auxiliary space requirement of interpolation search?<br>
a) O(n)<br>
b) O(2<sup>n</sup>)<br>
c) O(1)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: Interpolation search does not require any auxiliary space for finding the element being searched. So it has a constant auxiliary space O(1).</i><p><b>7. What is the time complexity of exponential search when the input array is sorted but the values are not uniformly distributed?<br>
a) O(n<sup>1/2</sup>)<br>
b) O(log log n)<br>
c) O(n)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: When an array has non uniformly distributed values then in that case the algorithm of interpolation search fails to work efficiently. As a result, it has a time complexity of O(n) in such a case.</i><p><b>8. Which of the following searching algorithm is fastest when the input array is sorted and has uniformly distributed values?<br>
a) jump search<br>
b) exponential search<br>
c) binary search<br>
d) interpolation search<br>
</b></p><i>Answer: d<br>
Explanation: Interpolation search has a time complexity of O( log log n) when the array is sorted and has uniformly distributed values. It has the least time complexity out of the given options for such a case.</i><p><b>9. Which of the following searching algorithm is fastest when the input array is sorted but has non uniformly distributed values?<br>
a) jump search<br>
b) linear search<br>
c) binary search<br>
d) interpolation search<br>
</b></p><i>Answer: c<br>
Explanation: Interpolation search has a time complexity of O(n) when the array does not have uniformly distributed values. So in such a case binary search has the least time complexity out of the given options.</i><p><b>10. Which of the following searching algorithm is fastest when the input array is not sorted but has uniformly distributed values?<br>
a) jump search<br>
b) linear search<br>
c) binary search<br>
d) interpolation search<br>
</b></p><i>Answer: b<br>
Explanation: Out of the given options linear search is the only searching algorithm which can be applied to arrays which are not sorted. It has a time complexity of O(n) in the worst case.</i><p><b>14. What are the updated values of high and low in the array if the element being searched is greater than the value at calculated index in interpolation search? (pos = current position)<br>
a) low = pos + 1, high remains unchanged<br>
b) high = pos – 1, low remains unchanged<br>
c) low = low +1, high = high – 1<br>
d) low = pos +1, high = pos – 1<br>
</b></p><i>Answer: a<br>
Explanation: Interpolation search has an auxiliary space complexity of O(1). So it qualifies as an in place algorithm.</i><p><b>15. What are the updated values of high and low in the array if the element being searched is lower than the value at calculated index in interpolation search? (pos = current position)<br>
a) low = pos + 1, high remains unchanged<br>
b) high = pos – 1, low remains unchanged<br>
c) low = low +1, high = high – 1<br>
d) low = pos +1, high = pos – 1<br>
</b></p><i>Answer: b<br>
Explanation: The worst case time complexity of interpolation search and exponential search are O(n) and O(log n) respectively. So exponential search is better when the worst case scenario is considered. </i><p><b>1. Which of the following is a sub string of “SANFOUNDRY”?<br>
a) SANO<br>
b) FOUND<br>
c) SAND<br>
d) FOND<br>
</b></p><i>Answer: b<br>
Explanation: A sub string is a subset of another string. So “FOUND” is the only possible sub string out of the given options.  </i><p><b>2. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> str2<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> str1<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> m <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n <span class="sy0">-</span> m<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> j<span class="sy0">;</span> 
&nbsp;
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> m<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw1">if</span> <span class="br0">(</span>str1<span class="br0">[</span>i <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">!=</span> str2<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span> 
				<span class="kw2">break</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">if</span> <span class="br0">(</span>j <span class="sy0">==</span> m<span class="br0">)</span> 
			cout <span class="sy0">&lt;&lt;</span> i <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"1253234"</span><span class="sy0">;</span> 
	<span class="kw4">char</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"323"</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The given code describes the naive method of finding a pattern in a string. So the output will be 3 as the given sub string begins at that index in the pattern. </i><p><b>3. What will be the worst case time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> str2<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> str1<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> m <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n <span class="sy0">-</span> m<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> j<span class="sy0">;</span> 
&nbsp;
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> m<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw1">if</span> <span class="br0">(</span>str1<span class="br0">[</span>i <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">!=</span> str2<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span> 
				<span class="kw2">break</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">if</span> <span class="br0">(</span>j <span class="sy0">==</span> m<span class="br0">)</span> 
			cout <span class="sy0">&lt;&lt;</span> i <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"1253234"</span><span class="sy0">;</span> 
	<span class="kw4">char</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"323"</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(m)<br>
c) O(m * n)<br>
d) O(m + n)<br>
</b></p><i>Answer: c<br>
Explanation: The given code describes the naive method of pattern searching. By observing the nested loop in the code we can say that the time complexity of the loop is O(m*n).</i><p><b>4. What will be the auxiliary space complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> str2<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> str1<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> m <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n <span class="sy0">-</span> m<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> j<span class="sy0">;</span> 
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> m<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw1">if</span> <span class="br0">(</span>str1<span class="br0">[</span>i <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">!=</span> str2<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span> 
				<span class="kw2">break</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">if</span> <span class="br0">(</span>j <span class="sy0">==</span> m<span class="br0">)</span> 
			cout <span class="sy0">&lt;&lt;</span> i <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"1253234"</span><span class="sy0">;</span> 
	<span class="kw4">char</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"323"</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(m)<br>
</b></p><i>Answer: b<br>
Explanation: The given code describes the naive method of pattern searching. Its auxiliary space requirement is O(1).</i><p><b>5. What is the worst case time complexity of KMP algorithm for pattern searching (m = length of text, n = length of pattern)?<br>
a) O(n)<br>
b) O(n*m)<br>
c) O(m)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: KMP algorithm is an efficient pattern searching algorithm. It has a time complexity of O(m) where m is the length of text.</i><p><b>6. What will be the best case time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span><span class="sy0">*</span> str2<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> str1<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> m <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n <span class="sy0">-</span> m<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> j<span class="sy0">;</span> 
&nbsp;
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> m<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw1">if</span> <span class="br0">(</span>str1<span class="br0">[</span>i <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">!=</span> str2<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span> 
				<span class="kw2">break</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">if</span> <span class="br0">(</span>j <span class="sy0">==</span> m<span class="br0">)</span> 
			cout <span class="sy0">&lt;&lt;</span> i <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"1253234"</span><span class="sy0">;</span> 
	<span class="kw4">char</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"323"</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The given code describes the naive method of pattern searching. The best case of the code occurs when the first character of the pattern does not appear in the text at all. So in such a case, only one iteration is required thus time complexity will be O(m).</i><p><b>a) O(n)<br>
b) O(m)<br>
c) O(m * n)<br>
d) O(m + n)<br>
</b></p><i>Answer: a<br>
Explanation: Z algorithm is an efficient pattern searching algorithm as it searches the pattern in linear time. It has a time complexity of O(m + n) where m is the length of text and n is the length of the pattern. </i><p><b>7. What is the time complexity of Z algorithm for pattern searching (m = length of text, n = length of pattern)?<br>
a) O(n + m)<br>
b) O(m)<br>
c) O(n)<br>
d) O(m * n)<br>
</b></p><i>Answer: b<br>
Explanation: Z algorithm is an efficient pattern searching algorithm as it searches the pattern in linear time. It an auxiliary space of O(m) for maintaining Z array. </i><p><b>8. What is the auxiliary space complexity of Z algorithm for pattern searching (m = length of text, n = length of pattern)?<br>
a) O(n + m)<br>
b) O(m)<br>
c) O(n)<br>
d) O(m * n)<br>
</b></p><i>Answer: a<br>
Explanation: The auxiliary space complexity required by naive pattern searching algorithm is O(1). So it qualifies as an in place algorithm.</i><p><b>1. How many passes does an insertion sort algorithm consist of?<br>
a) N<br>
b) N-1<br>
c) N+1<br>
d) N<sup>2</sup><br>
</b></p><i>Answer: b<br>
Explanation: An insertion algorithm consists of N-1 passes when an array of N elements is given.</i><p><b>2. Which of the following algorithm implementations is similar to that of an insertion sort?<br>
a) Binary heap<br>
b) Quick sort<br>
c) Merge sort<br>
d) Radix sort<br>
</b></p><i>Answer: a<br>
Explanation: Insertion sort is similar to that of a binary heap algorithm because of the use of temporary variable to swap.</i><p><b>3. What is the average case running time of an insertion sort algorithm?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The average case analysis of a tight bound algorithm is mathematically achieved to be O(N<sup>2</sup>).</i><p><b>5. What is the average number of inversions in an array of N distinct numbers?<br>
a) N(N-1)/4<br>
b) N(N+1)/2<br>
c) N(N-1)/2<br>
d) N(N-1)/3<br>
</b></p><i>Answer: a<br>
Explanation: Each swap removes only one inversion, so O(N<sup>2</sup>) swaps are required.</i><p><b>6. What is the running time of an insertion sort algorithm if the input is pre-sorted?<br>
a) O(N<sup>2</sup>)<br>
b) O(N log N)<br>
c) O(N)<br>
d) O(M log N)<br>
</b></p><i>Answer: a<br>
Explanation: The total number of pairs in a list L is N(N-1)/2. Thus, an average list has half this amount, or N(N-1)/4 inversions.</i><p><b>9. Which of the following real time examples is based on insertion sort?<br>
a) arranging a pack of playing cards<br>
b) database scenarios and distributes scenarios<br>
c) arranging books on a library shelf<br>
d) real-time systems<br>
</b></p><i>Answer: c<br>
Explanation: If the input is pre-sorted, the running time is O(N), because the test in the inner for loop always fails immediately and the algorithm will run quickly.</i><p><b>10. In C, what are the basic loops required to perform an insertion sort?<br>
a) do- while<br>
b) if else<br>
c) for and while<br>
d) for and if<br>
</b></p><i>Answer: b<br>
Explanation: The number of passes is given by N-1. Here, N=6. Therefore,<br>
6-1=5 passes.</i><p><b>12. Which of the following options contain the correct feature of an insertion sort algorithm?<br>
a) anti-adaptive<br>
b) dependable<br>
c) stable, not in-place<br>
d) stable, adaptive<br>
</b></p><i>Answer: d<br>
Explanation: After swapping elements in the second pass, the array will look like, 8, 34, 64, 51, 32, 21.</i><p><b>13. Which of the following sorting algorithms is the fastest for sorting small arrays?<br>
a) Quick sort<br>
b) Insertion sort<br>
c) Shell sort<br>
d) Heap sort<br>
</b></p><i>Answer: a<br>
Explanation: Arranging a pack of cards mimics an insertion sort. Database scenario is an example for merge sort, arranging books is a stack and real-time systems uses quick sort.</i><p><b>14. For the best case input, the running time of an insertion sort algorithm is?<br>
a) Linear<br>
b) Binary<br>
c) Quadratic<br>
d) Depends on the input<br>
</b></p><i>Answer: c<br>
Explanation: To perform an insertion sort, we use two basic loops- an outer for loop and an inner while loop.</i><p><b>15. Which of the following examples represent the worst case input for an insertion sort?<br>
a) array in sorted order<br>
b) array sorted in reverse order<br>
c) normal unsorted array<br>
d) large array<br>
</b></p><i>Answer: a<br>
Explanation: Binary search can be used in an insertion sort algorithm to reduce the number of comparisons. This is called a Binary insertion sort.</i><p><b>1. Which of the following is correct with regard to insertion sort?<br>
a) insertion sort is stable and it sorts In-place<br>
b) insertion sort is unstable and it sorts In-place<br>
c) insertion sort is stable and it does not sort In-place<br>
d) insertion sort is unstable and it does not sort In-place<br>
</b></p><i>Answer: a<br>
Explanation: During insertion sort, the relative order of elements is not changed. Therefore, it is a stable sorting algorithm. And insertion sort requires only O(1) of additional memory space. Therefore, it sorts In-place. </i><p><b>2. Which of the following sorting algorithm is best suited if the elements are already sorted?<br>
a) Heap Sort<br>
b) Quick Sort<br>
c) Insertion Sort<br>
d) Merge Sort<br>
</b></p><i>Answer: c<br>
Explanation: The best case running time of the insertion sort is O(n). The best case occurs when the input array is already sorted. As the elements are already sorted, only one comparison is made on each pass, so that the time required is O(n). </i><p><b>3. The worst case time complexity of insertion sort is O(n<sup>2</sup>). What will be the worst case time complexity of insertion sort if the correct position for inserting element is calculated using binary search?<br>
a) O(nlogn)<br>
b) O(n<sup>2</sup>)<br>
c) O(n)<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: The use of binary search reduces the time of finding the correct position from O(n) to O(logn). But the worst case of insertion sort remains O(n<sup>2</sup>) because of the series of swapping operations required for each insertion.  </i><p><b>5. Consider the code given below, which runs insertion sort:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> insertionSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> array_size<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> value<span class="sy0">;</span>
  <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> array_size<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
  <span class="br0">{</span>
          value <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          j <span class="sy0">=</span> i<span class="sy0">;</span>
          <span class="kw1">while</span> <span class="br0">(</span>________ <span class="br0">)</span>
          <span class="br0">{</span>
                   arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j − <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                   j <span class="sy0">=</span> j − <span class="nu0">1</span><span class="sy0">;</span>
          <span class="br0">}</span>
          arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> value<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which condition will correctly implement the while loop?<br>
a) (j &gt; 0) || (arr[j − 1] &gt; value)<br>
b) (j &gt; 0) &amp;&amp; (arr[j − 1] &gt; value)<br>
c) (j &gt; 0) &amp;&amp; (arr[j + 1] &gt; value)<br>
d) (j &gt; 0) &amp;&amp; (arr[j + 1] &lt; value)<br>
</b></p><i>Answer: a<br>
Explanation: In the incremental algorithms, the complicated structure on n items is built by first building it on n − 1 items. And then we make the necessary changes to fix things in adding the last item. Insertion sort builds the sorted sequence one element at a time. Therefore, it is an example of an incremental algorithm. </i><p><b>6. Which of the following is good for sorting arrays having less than 100 elements?<br>
a) Quick Sort<br>
b) Selection Sort<br>
c) Merge Sort<br>
d) Insertion Sort<br>
</b></p><i>Answer: b<br>
Explanation: In insertion sort, the element is A[j] is inserted into the correct position in the sorted sequence A[1… j – 1]. So, condition given in (j &gt; 0) &amp;&amp; (arr[j − 1] &gt; value) will implement while loop correctly. </i><p><b>7. Consider an array of length 5, arr[5] = {9,7,4,2,1}. What are the steps of insertions done while running insertion sort on the array?<br>
a) 7 9 4 2 1&nbsp;&nbsp;&nbsp;	4 7 9 2 1&nbsp;&nbsp;&nbsp;	2 4 7 9 1&nbsp;&nbsp;&nbsp;	1 2 4 7 9<br>
b) 9 7 4 1 2&nbsp;&nbsp;&nbsp;	9 7 1 2 4&nbsp;&nbsp;&nbsp;	9 1 2 4 7&nbsp;&nbsp;&nbsp;	1 2 4 7 9<br>
c) 7 4 2 1 9&nbsp;&nbsp;&nbsp;	4 2 1 9 7&nbsp;&nbsp;&nbsp; 	2 1 9 7 4&nbsp;&nbsp;&nbsp;	1 9 7 4 2<br>
d) 7 9 4 2 1&nbsp;&nbsp;&nbsp; 	2 4 7 9 1&nbsp;&nbsp;&nbsp;	4 7 9 2 1&nbsp;&nbsp;&nbsp; 	1 2 4 7 9<br>
</b></p><i>Answer: d<br>
Explanation: The insertion sort is good for sorting small arrays. It sorts smaller arrays faster than any other sorting algorithm. </i><p><b>9. In insertion sort, the average number of comparisons required to place the 7<sup>th</sup> element into its correct position is ____<br>
a) 9<br>
b) 4<br>
c) 7<br>
d) 14<br>
</b></p><i>Answer: a<br>
Explanation: The steps performed while running insertion sort on given array are:<br>
Initial : 9 7 4 2 1 key = 7<br>
	   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7 9 4 2 1 key = 4<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 7 9 2 1 key = 2<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 4 7 9 1 key = 1<br>
	    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 2 4 7 9<p></p>


	<p>In each step, the key is the element that is compared with the elements present at the left side to it. </p></i><p><b>10. Which of the following is not an exchange sort?<br>
a) Bubble Sort<br>
b) Quick Sort<br>
c) Partition-exchange Sort<br>
d) Insertion Sort<br>
</b></p><i>Answer: b<br>
Explanation: In insertion sort, after m passes through the array, the first m elements are in sorted order but they are whatever the first m elements were in the unsorted array. </i><p><b>1. What is an in-place sorting algorithm?<br>
a) It needs O(1) or O(logn) memory to create auxiliary locations<br>
b) The input is already sorted and in-place<br>
c) It requires additional storage<br>
d) It requires additional space<br>
</b></p><i>Answer: a<br>
Explanation: Auxiliary memory is required  for storing the data temporarily.</i><p><b>2. In the following scenarios, when will you use selection sort?<br>
a) The input is already sorted<br>
b) A large file has to be sorted<br>
c) Large values need to be sorted with small keys<br>
d) Small values need to be sorted with large keys<br>
</b></p><i>Answer: c<br>
Explanation: Selection is based on keys, hence a file with large values and small keys can be efficiently sorted with selection sort.</i><p><b>3. What is the worst case complexity of selection sort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: Selection sort creates a sub-list, LHS of the ‘min’ element is already sorted and RHS is yet to be sorted. Starting with the first element the ‘min’ element moves towards the final element.</i><p><b>4. Select the appropriate code that performs selection sort.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">int</span> min<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		min <span class="sy0">=</span> j<span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">&lt;=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="br0">)</span>
				min <span class="sy0">=</span> k<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>min<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
       <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">int</span> min<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		min <span class="sy0">=</span> j<span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">&lt;=</span>arr.<span class="me1">length</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="br0">)</span>
				min <span class="sy0">=</span> k<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>min<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">int</span> min<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		min <span class="sy0">=</span> j<span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">&lt;=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="br0">)</span>
				min <span class="sy0">=</span> k<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>min<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">int</span> min<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		min <span class="sy0">=</span> j<span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">&lt;=</span>arr.<span class="me1">length</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="br0">)</span>
				min <span class="sy0">=</span> k<span class="sy0">;</span>
		<span class="br0">}</span>
		<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>min<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>min<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
		arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Starting with the first element as ‘min’ element, selection sort loops through the list to select the least element which is then swapped with the ‘min’ element.</i><p><b>5. What is the advantage of selection sort over other sorting techniques?<br>
a) It requires no additional storage space<br>
b) It is scalable<br>
c) It works best for inputs which are already sorted<br>
d) It is faster than any other sorting technique<br>
</b></p><i>Answer: a<br>
Explanation: Since selection sort is an in-place sorting algorithm, it does not require additional storage.</i><p><b>6. What is the average case complexity of selection sort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: In the average case, even if the input is partially sorted, selection sort behaves as if the entire array is not sorted. Selection sort is insensitive to input.</i><p><b>7. What is the disadvantage of selection sort?<br>
a) It requires auxiliary memory<br>
b) It is not scalable<br>
c) It can be used for small keys<br>
d) It takes linear time to sort the elements<br>
</b></p><i>Answer: b<br>
Explanation: As the input size increases, the performance of selection sort decreases.</i><p><b>8. The given array is arr = {3,4,5,2,1}. The number of iterations in bubble sort and selection sort respectively are __________<br>
a) 5 and 4<br>
b) 4 and 5<br>
c) 2 and 4<br>
d) 2 and 5<br>
</b></p><i>Answer: a<br>
Explanation: Since the input array is not sorted, bubble sort takes 5 iterations and selection sort takes 4(n-1) iterations.</i><p><b>9. The given array is arr = {1,2,3,4,5}. (bubble sort is implemented with a flag variable)The number of iterations in selection sort and bubble sort respectively are __________<br>
a) 5 and 4<br>
b) 1 and 4<br>
c) 0 and 4<br>
d) 4 and 1<br>
</b></p><i>Answer: d<br>
Explanation: Selection sort is insensitive to input, hence 4(n-1) iterations. Whereas bubble sort iterates only once to set the flag to 0 as the input is already sorted.</i><p><b>10. What is the best case complexity of selection sort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The best, average and worst case complexities of selection sort is O(n<sup>2</sup>).<br>
(n-1) + (n-2) + (n-3) + …. + 1 = (n(n-1))/2 ~ (n<sup>2</sup>)/2.</i><p><b>1. What is an external sorting algorithm?<br>
a) Algorithm that uses tape or disk during the sort<br>
b) Algorithm that uses main memory during the sort<br>
c) Algorithm that involves swapping<br>
d) Algorithm that are considered ‘in place’<br>
</b></p><i>Answer: a<br>
Explanation: As the name suggests, external sorting algorithm uses external memory like tape or disk.</i><p><b>2. What is an internal sorting algorithm?<br>
a) Algorithm that uses tape or disk during the sort<br>
b) Algorithm that uses main memory during the sort<br>
c) Algorithm that involves swapping<br>
d) Algorithm that are considered ‘in place’<br>
</b></p><i>Answer: b<br>
Explanation: As the name suggests, internal sorting algorithm uses internal main memory.</i><p><b>3. What is the worst case complexity of bubble sort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: Bubble sort works by starting from the first element and swapping the elements if required in each iteration.</i><p><b>4. Select the appropriate code that performs bubble sort.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
			arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The outer loop keeps count of number of iterations, and the inner loop checks to see if swapping is necessary.</i><p><b>5. What is the average case complexity of bubble sort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: Bubble sort works by starting from the first element and swapping the elements if required in each iteration even in the average case.</i><p><b>6. Which of the following is not an advantage of optimised bubble sort over other sorting techniques in case of sorted elements?<br>
a) It is faster<br>
b) Consumes less memory<br>
c) Detects whether the input is already sorted<br>
d) Consumes less time<br>
</b></p><i>Answer: c<br>
Explanation: Optimised Bubble sort is one of the simplest sorting techniques and perhaps the only advantage it has over other techniques is that it can detect whether the input is already sorted. It is faster than other in case of sorted array and consumes less time to describe whether the input array is sorted or not. It consumes same memory than other sorting techniques. Hence it is not an advantage. </i><p><b>7. The given array is arr = {1, 2, 4, 3}. Bubble sort is used to sort the array elements. How many iterations will be done to sort the array?<br>
a) 4<br>
b) 2<br>
c) 1<br>
d) 0<br>
</b></p><i>Answer: a<br>
Explanation: Even though the first two elements are already sorted, bubble sort needs 4 iterations to sort the given array.</i><p><b>8. How can you improve the best case efficiency in bubble sort? (The input is already sorted)<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">boolean</span> swapped <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> swapped<span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
	<span class="br0">{</span>
		swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
				swapped <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">boolean</span> swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> swapped<span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
	<span class="br0">{</span>
		swapped <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">boolean</span> swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> swapped<span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
	<span class="br0">{</span>
		swapped <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
				swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">        <span class="kw4">boolean</span> swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span>arr.<span class="me1">length</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> j<span class="sy0">&gt;=</span><span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> swapped<span class="sy0">;</span> j<span class="sy0">--</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> k<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> k<span class="sy0">&lt;</span>j<span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				<span class="kw4">int</span> temp <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
				arr<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> temp<span class="sy0">;</span>
				swapped <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: A boolean variable ‘swapped’ determines whether any swapping has happened in a particular iteration, if no swapping has occurred, then the given array is sorted and no more iterations are required.</i><p><b>9. What is the best case efficiency of bubble sort in the improvised version?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: Some iterations can be skipped if the list is sorted, hence efficiency improves to O(n).</i><p><b>10. The given array is arr = {1,2,4,3}. Bubble sort is used to sort the array elements. How many iterations will be done to sort the array with improvised version?<br>
a) 4<br>
b) 2<br>
c) 1<br>
d) 0<br>
</b></p><i>Answer: b<br>
Explanation: Only 2 elements in the given array are not sorted, hence only 2 iterations are required to sort them.</i><p><b>1. Merge sort uses which of the following technique to implement sorting?<br>
a) backtracking<br>
b) greedy algorithm<br>
c) divide and conquer<br>
d) dynamic programming<br>
</b></p><i>Answer: c<br>
Explanation: Merge sort uses divide and conquer in order to sort a given array. This is because it divides the array into two halves and applies merge sort algorithm to each half individually after which the two sorted halves are merged together.</i><p><b>2. What is the average case time complexity of merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The recurrence relation for merge sort is given by T(n) = 2T(n/2) + n. It is found to be equal to O(n log n) using the master theorem.</i><p><b>3. What is the auxiliary space complexity of merge sort?<br>
a) O(1)<br>
b) O(log n)<br>
c) O(n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: An additional space of O(n) is required in order to merge two sorted arrays. Thus merge sort is not an in place sorting algorithm.</i><p><b>5. What is the worst case time complexity of merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Standard merge sort requires O(n) space to merge two sorted arrays. We can optimize this merging process so that it takes only constant space. This version is known as in place merge sort.</i><p><b>6. Which of the following method is used for sorting in merge sort?<br>
a) merging<br>
b) partitioning<br>
c) selection<br>
d) exchanging<br>
</b></p><i>Answer: a<br>
Explanation: The time complexity of merge sort is not affected by worst case as its algorithm has to implement the same number of steps in any case. So its time complexity remains to be O(n log n).</i><p><b>7. What will be the best case time complexity of merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Merge sort algorithm divides the array into two halves and applies merge sort algorithm to each half individually after which the two sorted halves are merged together. Thus its method of sorting is called merging.</i><p><b>8. Which of the following is not a variant of merge sort?<br>
a) in-place merge sort<br>
b) bottom up merge sort<br>
c) top down merge sort<br>
d) linear merge sort<br>
</b></p><i>Answer: a<br>
Explanation: The time complexity of merge sort is not affected in any case as its algorithm has to implement the same number of steps. So its time complexity remains to be O(n log n) even in the best case.</i><p><b>9. Choose the incorrect statement about merge sort from the following?<br>
a) it is a comparison based sort<br>
b) it is an adaptive algorithm<br>
c) it is not an in place algorithm<br>
d) it is stable algorithm<br>
</b></p><i>Answer: d<br>
Explanation: In-place, top down and bottom up merge sort are different variants of merge sort. Whereas linear merge sort is not a possible variant as it is a comparison based sort and the minimum time complexity of any comparison based sort is O(n log n).</i><p><b>10. Which of the following is not in place sorting algorithm by default?<br>
a) merge sort<br>
b) quick sort<br>
c) heap sort<br>
d) insertion sort<br>
</b></p><i>Answer: b<br>
Explanation: Merge sort is not an adaptive sorting algorithm. This is because it takes O(n log n) time complexity irrespective of any case.</i><p><b>11. Which of the following is not a stable sorting algorithm?<br>
a) Quick sort<br>
b) Cocktail sort<br>
c) Bubble sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Quick sort, heap sort, and insertion sort are in-place sorting algorithms, whereas an additional space of O(n) is required in order to merge two sorted arrays. Even though we have a variation of merge sort (to do in-place sorting), it is not the default option. So, among the given choices, merge sort is the most appropriate answer.</i><p><b>12. Which of the following stable sorting algorithm takes the least time when applied to an almost sorted array?<br>
a) Quick sort<br>
b) Insertion sort<br>
c) Selection sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options quick sort is the only algorithm which is not stable. Merge sort is a stable sorting algorithm.</i><p><b>14. Which of the following sorting algorithm makes use of merge sort?<br>
a) tim sort<br>
b) intro sort<br>
c) bogo sort<br>
d) quick sort<br>
</b></p><i>Answer: d<br>
Explanation: Insertion sort takes linear time to sort a partially sorted array. Though merge and  quick sort takes O(n*logn) complexity to sort, merge sort is stable. Hence, Merge sort takes less time to sort partially sorted array.</i><p><b>15. Choose the correct code for merge sort.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> merge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>left <span class="sy0">&gt;</span> right<span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>right<span class="sy0">-</span>left<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
        merge<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//function to merge sorted arrays</span>
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> merge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw4">int</span> mid <span class="sy0">=</span> left<span class="sy0">+</span><span class="br0">(</span>right<span class="sy0">-</span>left<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
        merge<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//function to merge sorted arrays</span>
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> merge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw4">int</span> mid <span class="sy0">=</span> left<span class="sy0">+</span><span class="br0">(</span>right<span class="sy0">-</span>left<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> 
merge<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//function to merge sorted arrays</span>
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> merge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>right<span class="sy0">-</span>left<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> 
merge<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//function to merge sorted arrays</span>
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span> 
        merge_sort<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Merge sort is preferred for linked list over arrays. It is because in a linked list the insert operation takes only O(1) time and space which implies that we can implement merge operation in constant time.</i><p><b>16. Which of the following sorting algorithm does not use recursion?<br>
a) quick sort<br>
b) merge sort<br>
c) heap sort<br>
d) bottom up merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Tim sort is a hybrid sorting algorithm as it uses more than one sorting algorithm internally. It makes use of merge sort and insertion sort.</i><p><b>1. Merge sort uses which of the following algorithm to implement sorting?<br>
a) backtracking<br>
b) greedy algorithm<br>
c) divide and conquer<br>
d) dynamic programming<br>
</b></p><i>Answer: c<br>
Explanation: Merge sort uses the technique of divide and conquer in order to sort a given array. It divides the array into two halves and apply merge sort algorithm to each half individually after which the sorted versions of these halves are merged together.</i><p><b>2. What is the average case time complexity of standard merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The recurrence relation for merge sort is given by T(n) = 2T(n/2) + n. This can be solved using master’s theorem and is found equal to O(n log n).</i><p><b>3. What is the auxiliary space complexity of standard merge sort?<br>
a) O(1)<br>
b) O(log n)<br>
c) O(n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: The merging of two sorted arrays requires an additional space of n due to which the auxiliary space requirement of merge sort is O(n). Thus merge sort is not an in place sorting algorithm.</i><p><b>4. What is the space complexity of in place merge sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: Space complexity of in place version of merge sort is O(log n) which is used for storing call stack formed due to recursion. Note that the algorithms with space complexity as O(log n) also qualifies as in place algorithms as the value of log n is close to 1.</i><p><b>5. What is the average time complexity of in place merge sort when we use the following function for merging?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> in_place_merge<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> middle<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> start2 <span class="sy0">=</span> middle <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>middle<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">while</span> <span class="br0">(</span>l <span class="sy0">&lt;=</span> middle <span class="sy0">&amp;&amp;</span> start2 <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
                <span class="br0">{</span> 
			l<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> 
                <span class="br0">{</span> 
			<span class="kw4">int</span> val <span class="sy0">=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="sy0">;</span> 
			<span class="kw4">int</span> index <span class="sy0">=</span> start2<span class="sy0">;</span> 
			<span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">!=</span> l<span class="br0">)</span> 
                        <span class="br0">{</span> 
				arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
				index<span class="sy0">--;</span> 
			<span class="br0">}</span> 
			arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">=</span> val<span class="sy0">;</span> 
		        l<span class="sy0">++;</span> 
			middle<span class="sy0">++;</span> 
			start2<span class="sy0">++;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The merge function in the in place merge sort takes O(n<sup>2</sup>) time so the recurrence relation becomes T(n)=2T(n/2)+n<sup>2</sup>. This can be solved using master’s theorem and is found equal to O(n<sup>2</sup>).</i><p><b>6. Merge sort uses which of the following method to implement sorting?<br>
a) merging<br>
b) partitioning<br>
c) selection<br>
d) exchanging<br>
</b></p><i>Answer: a<br>
Explanation: Merge sort implements sorting by merging the sorted versions of smaller parts of the array. Thus its method of sorting is called merging.</i><p><b>9. Choose the incorrect statement about merge sort from the following?<br>
a) both standard merge sort and in-place merge sort are stable<br>
b) standard merge sort has greater time complexity than in-place merge sort<br>
c) standard merge sort has greater space complexity than in-place merge sort<br>
d) in place merge sort has O(log n) space complexity<br>
</b></p><i>Answer: b<br>
Explanation: In place version of merge sort has a greater time complexity as compared to its standard version. It is because the merging in in-place merge sort takes place in O(n<sup>2</sup>) time whereas in standard version it takes O(n) time.</i><p><b>10. Choose the correct function from the following that implements merging in in-place merge sort.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> in_place_merge<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> middle<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> start2 <span class="sy0">=</span> middle <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>middle<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">while</span> <span class="br0">(</span>l <span class="sy0">&lt;=</span> middle<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&amp;&amp;</span> start2 <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
        <span class="br0">{</span>  
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
                <span class="br0">{</span> 
			l<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> 
                <span class="br0">{</span> 
			<span class="kw4">int</span> val <span class="sy0">=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="sy0">;</span> 
			<span class="kw4">int</span> index <span class="sy0">=</span> start2<span class="sy0">;</span> 
			<span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">!=</span> l<span class="br0">)</span> 
                        <span class="br0">{</span> 
				arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
				index<span class="sy0">--;</span> 
			<span class="br0">}</span> 
			arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">=</span> val<span class="sy0">;</span> 
		        l<span class="sy0">++;</span> 
			middle<span class="sy0">++;</span> 
			start2<span class="sy0">++;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> in_place_merge<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> middle<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> start2 <span class="sy0">=</span> middle <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>middle<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">while</span> <span class="br0">(</span>l <span class="sy0">&lt;=</span> middle <span class="sy0">&amp;&amp;</span> start2 <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
        <span class="br0">{</span>  
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
                <span class="br0">{</span> 
			l<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> 
                <span class="br0">{</span> 
			<span class="kw4">int</span> val <span class="sy0">=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="sy0">;</span> 
			<span class="kw4">int</span> index <span class="sy0">=</span> start2<span class="sy0">;</span> 
			<span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">!=</span> l<span class="br0">)</span> 
                        <span class="br0">{</span> 
				arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
				index<span class="sy0">--;</span> 
			<span class="br0">}</span> 
			arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">=</span> val<span class="sy0">;</span> 
		        l<span class="sy0">++;</span> 
			middle<span class="sy0">++;</span> 
			start2<span class="sy0">++;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> in_place_merge<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> middle<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> start2 <span class="sy0">=</span> middle <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>middle<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">while</span> <span class="br0">(</span>l <span class="sy0">&lt;=</span> middle<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&amp;&amp;</span> start2 <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
        <span class="br0">{</span>  
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&gt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
                <span class="br0">{</span> 
			l<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> 
                <span class="br0">{</span> 
			<span class="kw4">int</span> val <span class="sy0">=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="sy0">;</span> 
			<span class="kw4">int</span> index <span class="sy0">=</span> start2<span class="sy0">;</span> 
			<span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">!=</span> l<span class="br0">)</span> 
                        <span class="br0">{</span> 
				arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
				index<span class="sy0">--;</span> 
			<span class="br0">}</span> 
			arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">=</span> val<span class="sy0">;</span> 
                        l<span class="sy0">++;</span> 
			middle<span class="sy0">++;</span> 
			start2<span class="sy0">++;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: In-place merge sort like standard merge sort is a stable sort. This implies that the relative position of equal valued elements in the input and sorted array remain same.</i><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> in_place_merge<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> middle<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> start2 <span class="sy0">=</span> middle <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>middle<span class="br0">]</span> <span class="sy0">&gt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">while</span> <span class="br0">(</span>l <span class="sy0">&lt;=</span> middle <span class="sy0">&amp;&amp;</span> start2 <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
        <span class="br0">{</span>  
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="br0">)</span> 
                <span class="br0">{</span> 
			l<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> 
                <span class="br0">{</span> 
			<span class="kw4">int</span> val <span class="sy0">=</span> arr<span class="br0">[</span>start2<span class="br0">]</span><span class="sy0">;</span> 
			<span class="kw4">int</span> index <span class="sy0">=</span> start2<span class="sy0">;</span> 
			<span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">!=</span> r<span class="br0">)</span> 
                        <span class="br0">{</span> 
				arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
				Index<span class="sy0">++;</span> 
			<span class="br0">}</span> 
			arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">=</span> val<span class="sy0">;</span> 
		        l<span class="sy0">++;</span> 
			middle<span class="sy0">++;</span> 
			start2<span class="sy0">++;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>1. Merge sort uses which of the following algorithm to implement sorting?<br>
a) backtracking<br>
b) greedy algorithm<br>
c) divide and conquer<br>
d) dynamic programming<br>
</b></p><i>Answer: c<br>
Explanation: Merge sort uses the technique of divide and conquer in order to sort a given array. It divides the array into two halves and applies merge sort algorithm to each half individually after which the sorted versions of these halves are merged together.</i><p><b>2. What is the average case time complexity of standard merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The recurrence relation for merge sort is given by T(n) = 2T(n/2) + n. This can be solved using master’s theorem and is found equal to O(n log n).</i><p><b>3. What is the auxiliary space complexity of standard merge sort?<br>
a) O(1)<br>
b) O(log n)<br>
c) O(n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: The merging of two sorted arrays requires an additional space of n due to which the auxiliary space requirement of merge sort is O(n). Thus merge sort is not an in place sorting algorithm.</i><p><b>4. What is the auxiliary space complexity of bottom up merge sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: The auxiliary space complexity of bottom up merge sort is same as standard merge sort as both uses the same algorithm for merging the sorted arrays which takes o(n) space. But bottom up merge sort does not need to maintain a call stack. </i><p><b>5. What is the average time complexity of bottom up merge sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The merge function in the bottom up merge sort takes O(n) time which is placed inside the for loop. The loop runs for O(log n) time, thus the overall time complexity of the code becomes O(n log n).</i><p><b>6. Merge sort uses which of the following method to implement sorting?<br>
a) merging<br>
b) partitioning<br>
c) selection<br>
d) exchanging<br>
</b></p><i>Answer: a<br>
Explanation: Merge sort implements sorting by merging the sorted versions of smaller parts of the array. Thus its method of sorting is called merging.</i><p><b>9. Choose the correct statement about bottom up merge sort from the following?<br>
a) bottom up merge sort has greater time complexity than standard merge sort<br>
b) bottom up merge sort has lesser time complexity than standard merge sort<br>
c) bottom up merge sort saves auxiliary space required on call stack<br>
d) bottom up merge sort uses recursion.<br>
</b></p><i>Answer: b<br>
Explanation: Bottom up merge sort uses the iterative method in order to implement sorting. It begins by merging a pair of adjacent array of size 1 each and then merge arrays of size 2 each in the next step and so on.</i><p><b>10. Choose the correct option from the following that represents bottom up merge sort function?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> mergesort<span class="br0">(</span><span class="kw4">int</span> Arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> temp<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> m <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> m <span class="sy0">&lt;=</span> high <span class="sy0">-</span> low<span class="sy0">;</span> m <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
	<span class="br0">{</span>	
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> low<span class="sy0">;</span> i <span class="sy0">&lt;</span> high<span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> left <span class="sy0">=</span> i<span class="sy0">;</span>
			<span class="kw4">int</span> mid <span class="sy0">=</span> i <span class="sy0">+</span> m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
			<span class="kw4">int</span> right <span class="sy0">=</span> min<span class="br0">(</span>i <span class="sy0">+</span> <span class="nu0">2</span><span class="sy0">*</span>m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> high<span class="br0">)</span><span class="sy0">;</span>		
			merge<span class="br0">(</span>Arr<span class="sy0">,</span> temp<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> mergesort<span class="br0">(</span><span class="kw4">int</span> Arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> temp<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> m <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> m <span class="sy0">&lt;=</span> high <span class="sy0">-</span> low<span class="sy0">;</span> m <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
	<span class="br0">{</span>	
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> low<span class="sy0">;</span> i <span class="sy0">&lt;</span> high<span class="sy0">;</span> i <span class="sy0">+=</span> m<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> left <span class="sy0">=</span> i<span class="sy0">;</span>
			<span class="kw4">int</span> mid <span class="sy0">=</span> i <span class="sy0">+</span> m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
			<span class="kw4">int</span> right <span class="sy0">=</span> min<span class="br0">(</span>i <span class="sy0">+</span> <span class="nu0">2</span><span class="sy0">*</span>m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> high<span class="br0">)</span><span class="sy0">;</span>
			merge<span class="br0">(</span>Arr<span class="sy0">,</span> temp<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> mergesort<span class="br0">(</span><span class="kw4">int</span> Arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> temp<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> m <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> m <span class="sy0">&lt;=</span> high <span class="sy0">-</span> low<span class="sy0">;</span> m <span class="sy0">=</span> m<span class="br0">)</span>
	<span class="br0">{</span>	
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> low<span class="sy0">;</span> i <span class="sy0">&lt;</span> high<span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> left <span class="sy0">=</span> i<span class="sy0">;</span>
			<span class="kw4">int</span> mid <span class="sy0">=</span> i <span class="sy0">+</span> m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
			<span class="kw4">int</span> right <span class="sy0">=</span> min<span class="br0">(</span>i <span class="sy0">+</span> <span class="nu0">2</span><span class="sy0">*</span>m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> high<span class="br0">)</span><span class="sy0">;</span>
			merge<span class="br0">(</span>Arr<span class="sy0">,</span> temp<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> mergesort<span class="br0">(</span><span class="kw4">int</span> Arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> temp<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> m <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> m <span class="sy0">&lt;=</span> high <span class="sy0">-</span> low<span class="sy0">;</span> m <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
	<span class="br0">{</span>	
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> low<span class="sy0">;</span> i <span class="sy0">&lt;</span> high<span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">*</span>m<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw4">int</span> left <span class="sy0">=</span> i<span class="sy0">;</span>
			<span class="kw4">int</span> mid <span class="sy0">=</span> i <span class="sy0">+</span> m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
			<span class="kw4">int</span> right <span class="sy0">=</span> min<span class="br0">(</span>i <span class="sy0">+</span> m <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> high<span class="br0">)</span><span class="sy0">;</span>
			merge<span class="br0">(</span>Arr<span class="sy0">,</span> temp<span class="sy0">,</span> left<span class="sy0">,</span> mid<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Bottom up merge sort like standard merge sort is a stable sort. This implies that the relative position of equal valued elements in the input and sorted array remain same.</i><p><b>1. Which of the following sorting algorithms is the fastest?<br>
a) Merge sort<br>
b) Quick sort<br>
c) Insertion sort<br>
d) Shell sort<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort is the fastest known sorting algorithm because of its highly optimized inner loop.</i><p><b>3. What is the worst case time complexity of a quick sort algorithm?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: a<br>
Explanation: In quick sort, the array is divided into sub-arrays and then it is sorted (divide-and-conquer strategy).</i><p><b>4. Which of the following methods is the most effective for picking the pivot element?<br>
a) first element<br>
b) last element<br>
c) median-of-three partitioning<br>
d) random element<br>
</b></p><i>Answer: c<br>
Explanation: The worst case performance of a quick sort algorithm is mathematically found to be O(N<sup>2</sup>).</i><p><b>6. Which is the safest method to choose a pivot element?<br>
a) choosing a random element as pivot<br>
b) choosing the first element as pivot<br>
c) choosing the last element as pivot<br>
d) median-of-three partitioning method<br>
</b></p><i>Answer: c<br>
Explanation: Median-of-three partitioning is the best method for choosing an appropriate pivot element. Picking a first, last or random element as a pivot is not much effective.</i><p><b>7. What is the average running time of a quick sort algorithm?<br>
a) O(N<sup>2</sup>)<br>
b) O(N)<br>
c) O(N log N)<br>
d) O(log N)<br>
</b></p><i>Answer: d<br>
Explanation: Left element=8, right element=0,<br>
Centre=[position(left+right)/2]=6.</i><p><b>8. Which of the following sorting algorithms is used along with quick sort to sort the sub arrays?<br>
a) Merge sort<br>
b) Shell sort<br>
c) Insertion sort<br>
d) Bubble sort<br>
</b></p><i>Answer: a<br>
Explanation: This is the safest method to choose the pivot element since it is very unlikely that a random pivot would consistently provide a poor partition. </i><p><b>10. How many sub arrays does the quick sort algorithm divide the entire array into?<br>
a) one<br>
b) two<br>
c) three<br>
d) four<br>
</b></p><i>Answer: c<br>
Explanation: The best case and average case analysis of a quick sort algorithm are mathematically found to be O(N log N).</i><p><b>11. Which is the worst method of choosing a pivot element?<br>
a) first element as pivot<br>
b) last element as pivot<br>
c) median-of-three partitioning<br>
d) random element as pivot<br>
</b></p><i>Answer: c<br>
Explanation: Insertion sort is used along with quick sort to sort the sub arrays.<br>
It is used only at the end.</i><p><b>12. Which among the following is the best cut-off range to perform insertion sort within a quick sort?<br>
a) N=0-5<br>
b) N=5-20<br>
c) N=20-30<br>
d) N&gt;30<br>
</b></p><i>Answer: a<br>
Explanation: Quick sort uses join operation since join is a faster operation than merge.</i><p><b>1. Quick sort is a __________<br>
a) greedy algorithm<br>
b) divide and conquer algorithm<br>
c) dynamic programming algorithm<br>
d) backtracking algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort is a divide and conquer algorithm. Quick sort first partitions a large array into two smaller sub-arrays. And then recursively sorts the sub-arrays.</i><p><b>2. What is the worst case time complexity of the Quick sort?<br>
a) O(nlogn)<br>
b) O(n)<br>
c) O(n<sup>3</sup>)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The worst case running time for Quick sort is O(n<sup>2</sup>). In Quick sort, the worst case behaviour occurs when the partitioning routine produces two sub-arrays one with n – 1 element and other with 0 elements.</i><p><b>3. Apply Quick sort on a given sequence 7 11 14 6 9 4 3 12. What is the sequence after first phase, pivot is first element?<br>
a) 6 4 3 7 11 9 14 12<br>
b) 6 3 4 7 9 14 11 12<br>
c) 7 6 14 11 9 4 3 12<br>
d) 7 6 4 3 9 14 11 12<br>
</b></p><i>Answer: b<br>
Explanation: Let’s apply Quick sort on the given sequence,<br>
For first phase, pivot = 7<br>
	7 &nbsp;&nbsp;&nbsp;      11 &nbsp;&nbsp;&nbsp;	14 &nbsp;&nbsp;&nbsp;	6 &nbsp;&nbsp;&nbsp;	9 &nbsp;&nbsp;&nbsp;	4 &nbsp;&nbsp;&nbsp;	3 &nbsp;&nbsp;&nbsp;	12&nbsp;&nbsp;&nbsp;<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	i &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;					        j<br>
	7 &nbsp;&nbsp;&nbsp;	11 &nbsp;&nbsp;&nbsp;	14&nbsp;&nbsp;&nbsp; 	6 &nbsp;&nbsp;&nbsp;	9&nbsp;&nbsp;&nbsp; 	4 &nbsp;&nbsp;&nbsp;	3 &nbsp;&nbsp;&nbsp;	12&nbsp;&nbsp;&nbsp;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;				j<br>
	7 &nbsp;&nbsp;&nbsp;	3 &nbsp;&nbsp;&nbsp;	14 &nbsp;&nbsp;&nbsp;	6 &nbsp;&nbsp;&nbsp;	9 &nbsp;&nbsp;&nbsp;	4 &nbsp;&nbsp;&nbsp;	11 &nbsp;&nbsp;&nbsp;	12&nbsp;&nbsp;&nbsp;<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<br>
	7 &nbsp;&nbsp;&nbsp;	3 &nbsp;&nbsp;&nbsp;	4&nbsp;&nbsp;&nbsp; 	6 &nbsp;&nbsp;&nbsp;	9 &nbsp;&nbsp;&nbsp;	14&nbsp;&nbsp;&nbsp; 	11 &nbsp;&nbsp;&nbsp;	12&nbsp;&nbsp;&nbsp;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j<br>
	7 &nbsp;&nbsp;&nbsp;	3 &nbsp;&nbsp;&nbsp;	4 &nbsp;&nbsp;&nbsp;	6&nbsp;&nbsp;&nbsp; 	9&nbsp;&nbsp;&nbsp; 	14 &nbsp;&nbsp;&nbsp;	11 &nbsp;&nbsp;&nbsp;	12&nbsp;&nbsp;&nbsp;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i<br>
	6  &nbsp;&nbsp;&nbsp;	3  &nbsp;&nbsp;&nbsp;	4  &nbsp;&nbsp;&nbsp;	7  &nbsp;&nbsp;&nbsp;	9 &nbsp;&nbsp;&nbsp; 	14 &nbsp;&nbsp;&nbsp; 	11  &nbsp;&nbsp;&nbsp;	12 &nbsp;&nbsp;&nbsp;<br>
	</i><p><b>4. The best case behaviour occurs for quick sort is, if partition splits the array of size n  into __________<br>
a) n/2 : (n/2) – 1<br>
b) n/2 : n/3<br>
c) n/4 : 3n/2<br>
d) n/4 : 3n/4<br>
</b></p><i>Answer: a<br>
Explanation: The best case analysis of quick sort occurs when the partition splits the array into two subarrays, each of size no more than n/2 since one is of size n/2 and one of size (n/2) – 1.</i><p><b>6. Consider the Quick sort algorithm in which the partitioning procedure splits elements into two sub-arrays and each sub-array contains at least one-fourth of the elements. Let T(n) be the number of comparisons required to sort array of n elements. Then T(n)&lt;=?<br>
a) T(n) &lt;= 2 T(n/4) + cn<br>
b) T(n) &lt;= T(n/4) + T(3n/4) + cn<br>
c) T(n) &lt;= 2 T(3n/4) + cn<br>
d) T(n) &lt;= T(n/3) + T(3n/4) + cn<br>
</b></p><i>Answer: b<br>
Explanation: In stable sorting algorithm the records with equal keys appear in the same order in the sorted sequence as they appear in the input unsorted sequence. Quick sort does not preserve the relative order of equal sort items. Therefore, Quick sort is not a stable sort.</i><p><b>7. Consider the Quick sort algorithm which sorts elements in ascending order using the first element as pivot. Then which of the following input sequence will require a maximum number of comparisons when this algorithm is applied on it?<br>
a) 22 25 56 67 89<br>
b) 52 25 76 67 89<br>
c) 22 25 76 67 50<br>
d) 52 25 89 67 76<br>
</b></p><i>Answer: b<br>
Explanation: If there are n/4 elements in one sub-array then T(n/4) comparisons are needed for this sub-array. And T(3n/4) comparison are required for the rest 4n/5 elements, and cn is time required for finding the pivot. If there are more than n/4 elements in one sub-array then other sub-array will have less than 3n/4 elements and time complexity will be less than T(n/4) + T(3n/4) + cn.</i><p><b>8. A machine needs a minimum of 200 sec to sort 1000 elements by Quick sort. The minimum time needed to sort 200 elements will be approximately __________<br>
a) 60.2 sec<br>
b) 45.54 sec<br>
c) 31.11 sec<br>
d) 20 sec<br>
</b></p><i>Answer: a<br>
Explanation: If the input sequence is already sorted then worst case behaviour occurs for the Quick sort algorithm which use the first element as pivot. Therefore, the input sequence given in 22 25 56 67 89 will require a maximum number of comparisons.</i><p><b>9. Which one of the following sorting algorithm is best suited to sort an array of 1 million elements?<br>
a) Bubble sort<br>
b) Insertion sort<br>
c) Merge sort<br>
d) Quick sort<br>
</b></p><i>Answer: c<br>
Explanation: The Quick sort requires nlog2n comparisons in best case, where n is size of input array. So, 1000 * log21000 ≈ 9000 comparisons are required to sort 1000 elements, which takes 200 sec. To sort 200 elements minimum of 200 * log2200 ≈ 1400 comparisons are required. This will take 200 * 1400 / 9000 ≈ 31.11 sec.</i><p><b>10. Quick sort is a space-optimised version of ____<br>
a) Bubble sort<br>
b) Selection sort<br>
c) Insertion sort<br>
d) Binary tree sort<br>
</b></p><i>Answer: d<br>
Explanation: The Quick sort is best suited to sort the array of 1 million elements. The practical implementations of Quick sort use randomised version. In practice randomised Quick sort algorithms rarely shows worst case behaviour and is almost always O(nlogn). And Quick sort requires little additional space and exhibits good cache locality.</i><p><b>1. QuickSort can be categorized into which of the following?<br>
a) Brute Force technique<br>
b) Divide and conquer<br>
c) Greedy algorithm<br>
d) Dynamic programming<br>
</b></p><i>Answer: b<br>
Explanation: First you divide(partition) the array based on the pivot element and sort accordingly.</i><p><b>2. Select the appropriate recursive call for QuickSort.(arr is the array, low is the starting index and high is the ending index of the array, partition returns the pivot element, we will see the code for partition very soon)<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> quickSort<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> pivot<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>high<span class="sy0">&gt;</span>low<span class="br0">)</span>
	<span class="br0">{</span>
		pivot <span class="sy0">=</span> partition<span class="br0">(</span>arr, low, high<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, low, pivot<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, pivot<span class="sy0">+</span><span class="nu0">1</span>, high<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> quickSort<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> pivot<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>high<span class="sy0">&lt;</span>low<span class="br0">)</span>
	<span class="br0">{</span>
		pivot <span class="sy0">=</span> partition<span class="br0">(</span>arr, low, high<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, low, pivot<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, pivot<span class="sy0">+</span><span class="nu0">1</span>, high<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> quickSort<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> pivot<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>high<span class="sy0">&gt;</span>low<span class="br0">)</span>
	<span class="br0">{</span>
		pivot <span class="sy0">=</span> partition<span class="br0">(</span>arr, low, high<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, low, pivot<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, pivot, high<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">void</span> quickSort<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> pivot<span class="sy0">;</span>
	<span class="kw1">if</span><span class="br0">(</span>high<span class="sy0">&gt;</span>low<span class="br0">)</span>
	<span class="br0">{</span>
		pivot <span class="sy0">=</span> partition<span class="br0">(</span>arr, low, high<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, low, pivot<span class="br0">)</span><span class="sy0">;</span>
		quickSort<span class="br0">(</span>arr, pivot<span class="sy0">+</span><span class="nu0">2</span>, high<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Based on the pivot returned by the call to partition, recursive calls to quickSort sort the given array.</i><p><b>3. What is the worst case complexity of QuickSort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: When the input array is already sorted. </i><p><b>4. What is a randomized QuickSort?<br>
a) The leftmost element is chosen as the pivot<br>
b) The rightmost element is chosen as the pivot<br>
c) Any element in the array is chosen as the pivot<br>
d) A random number is generated which is used as the pivot<br>
</b></p><i>Answer: c<br>
Explanation: QuickSort is randomized by placing the input data in the randomized fashion in the array or by choosing a random element in the array as a pivot.</i><p><b>5. Which of the following code performs the partition operation in QuickSort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">private</span> <span class="kw1">static</span> <span class="kw4">int</span> partition<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> left, right, pivot_item <span class="sy0">=</span> arr<span class="br0">[</span>low<span class="br0">]</span><span class="sy0">;</span>
	left <span class="sy0">=</span> low<span class="sy0">;</span>
	right <span class="sy0">=</span> high<span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>left <span class="sy0">&gt;</span> right<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&lt;=</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			left<span class="sy0">++;</span>
		<span class="br0">}</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&gt;</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			right<span class="sy0">--;</span>
		<span class="br0">}</span>
		<span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
		<span class="br0">{</span>
			swap<span class="br0">(</span>arr, left, right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	arr<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
	arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> pivot_item<span class="sy0">;</span>
	<span class="kw1">return</span> right<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">private</span> <span class="kw1">static</span> <span class="kw4">int</span> partition<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> left, right, pivot_item <span class="sy0">=</span> arr<span class="br0">[</span>low<span class="br0">]</span><span class="sy0">;</span>
	left <span class="sy0">=</span> low<span class="sy0">;</span>
	right <span class="sy0">=</span> high<span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>left <span class="sy0">&lt;=</span> right<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&lt;=</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			left<span class="sy0">++;</span>
		<span class="br0">}</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&gt;</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			right<span class="sy0">--;</span>
		<span class="br0">}</span>
		<span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
		<span class="br0">{</span>
			swap<span class="br0">(</span>arr, left, right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	arr<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
	arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> pivot_item<span class="sy0">;</span>
	<span class="kw1">return</span> right<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">private</span> <span class="kw1">static</span> <span class="kw4">int</span> partition<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> left, right, pivot_item <span class="sy0">=</span> arr<span class="br0">[</span>low<span class="br0">]</span><span class="sy0">;</span>
	left <span class="sy0">=</span> low<span class="sy0">;</span>
	right <span class="sy0">=</span> high<span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>left <span class="sy0">&lt;=</span> right<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&gt;</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			left<span class="sy0">++;</span>
		<span class="br0">}</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;=</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			right<span class="sy0">--;</span>
		<span class="br0">}</span>
		<span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
		<span class="br0">{</span>
			swap<span class="br0">(</span>arr, left, right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	arr<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
	arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> pivot_item<span class="sy0">;</span>
	<span class="kw1">return</span> right<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1"><span class="kw1">private</span> <span class="kw1">static</span> <span class="kw4">int</span> partition<span class="br0">(</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr, <span class="kw4">int</span> low, <span class="kw4">int</span> high<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> left, right, pivot_item <span class="sy0">=</span> arr<span class="br0">[</span>low<span class="br0">]</span><span class="sy0">;</span>
	left <span class="sy0">=</span> low<span class="sy0">;</span>
	right <span class="sy0">=</span> high<span class="sy0">;</span>
	<span class="kw1">while</span><span class="br0">(</span>left <span class="sy0">&gt;</span> right<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&gt;</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			left<span class="sy0">++;</span>
		<span class="br0">}</span>
		<span class="kw1">while</span><span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;=</span> pivot_item<span class="br0">)</span>
		<span class="br0">{</span>
			right<span class="sy0">--;</span>
		<span class="br0">}</span>
		<span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
		<span class="br0">{</span>
			swap<span class="br0">(</span>arr, left, right<span class="br0">)</span><span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	arr<span class="br0">[</span>low<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
	arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> pivot_item<span class="sy0">;</span>
	<span class="kw1">return</span> right<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The array is partitioned such that the elements left to the pivot are lesser than the pivot while the elements right of the pivot are greater than the pivot.</i><p><b>6. What is the best case complexity of QuickSort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The array is partitioned into equal halves, using the Divide and Conquer master theorem, the complexity is found to be O(nlogn).</i><p><b>7. The given array is arr = {2,3,4,1,6}. What are the pivots that are returned as a result of subsequent partitioning?<br>
a) 1 and 3<br>
b) 3 and 1<br>
c) 2 and 6<br>
d) 6 and 2<br>
</b></p><i>Answer: a<br>
Explanation: The call to partition returns 1 and 3 as the pivot elements.</i><p><b>8. What is the average case complexity of QuickSort?<br>
a) O(nlogn)<br>
b) O(logn)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The position of partition(split) is unknown, hence all(n) possibilities are considered, the average is found by adding all and dividing by n.</i><p><b>9. The given array is arr = {2,6,1}. What are the pivots that are returned as a result of subsequent partitioning?<br>
a) 1 and 6<br>
b) 6 and 1<br>
c) 2 and 6<br>
d) 1<br>
</b></p><i>Answer: d<br>
Explanation: There is only one pivot with which the array will be sorted, the pivot is 1.</i><p><b>10. Which of the following is not true about QuickSort?<br>
a) in-place algorithm<br>
b) pivot position can be changed<br>
c) adaptive sorting algorithm<br>
d) can be implemented as a stable sort<br>
</b></p><i>Answer: b<br>
Explanation: Once a pivot is chosen, its position is finalized in the sorted array, it cannot be modified.</i><p><b>1. Quick sort uses which of the following algorithm to implement sorting?<br>
a) backtracking<br>
b) greedy algorithm<br>
c) divide and conquer<br>
d) dynamic programming<br>
</b></p><i>Answer: c<br>
Explanation: Quick sort uses the technique of divide and conquer in order to sort a given array. It divides the array into two parts about the pivot and then apply a quick sort to both the parts.</i><p><b>2. What is a randomized quick sort?<br>
a) quick sort with random partitions<br>
b) quick sort with random choice of pivot<br>
c) quick sort with random output<br>
d) quick sort with random input<br>
</b></p><i>Answer: b<br>
Explanation: Randomized quick sort chooses a random element as a pivot. It is done so as to avoid the worst case of quick sort in which the input array is already sorted.</i><p><b>3. What is the purpose of using randomized quick sort over standard quick sort?<br>
a) so as to avoid worst case time complexity<br>
b) so as to avoid worst case space complexity<br>
c) to improve accuracy of output<br>
d) to improve average case time complexity<br>
</b></p><i>Answer: a<br>
Explanation: Randomized quick sort helps in avoiding the worst case time complexity of O(n2) which occurs in case when the input array is already sorted. However the average case and best case time complexities remain unaltered.</i><p><b>4. What is the auxiliary space complexity of randomized quick sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: Auxiliary space complexity of randomized quick sort is O(log n) which is used for storing call stack formed due to recursion. Note that the algorithms with space complexity as O(log n) also qualifies as in place algorithms as the value of log n is close to 1.</i><p><b>5. What is the average time complexity of randomized quick sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The average case time complexity of randomized quick sort is same as that of standard quick sort as randomized quick sort only helps in preventing the worst case. It is equal to O(n log n).</i><p><b>6. Quick sort uses which of the following method to implement sorting?<br>
a) merging<br>
b) partitioning<br>
c) selection<br>
d) exchanging<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort makes partitions of the input array about the pivot in order to implement sorting. Thus its method of sorting is called partitioning.</i><p><b>9. What is the best case time complexity randomized quick sort?<br>
a) O(log n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: a<br>
Explanation: In-place algorithms requires constant or very less auxiliary space. Quick sort qualifies as an in place sorting algorithm as it has a very low auxiliary space requirement of O(log n).</i><p><b>10. Which of the following is incorrect about randomized quicksort?<br>
a) it has the same time complexity as standard quick sort<br>
b) it has the same space complexity as standard quick sort<br>
c) it is an in-place sorting algorithm<br>
d) it cannot have a time complexity of O(n<sup>2</sup>) in any case.<br>
</b></p><i>Answer: b<br>
Explanation: Randomized quick sort like standard quick sort is also not a stable sorting algorithm. It is because the elements with the same values are not guaranteed to appear in the same relative order in the output sorted array.</i><p><b>11. Which of the following function chooses a random index as pivot.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> partition_random<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span> 
<span class="br0">{</span>     
    <span class="kw3">srand</span><span class="br0">(</span><span class="kw3">time</span><span class="br0">(</span>NULL<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> random <span class="sy0">=</span> low <span class="sy0">+</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">;</span> 
    swap<span class="br0">(</span>arr<span class="br0">[</span>random<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>high<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> partition_random<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span> 
<span class="br0">{</span>    
    <span class="kw3">srand</span><span class="br0">(</span><span class="kw3">time</span><span class="br0">(</span>NULL<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> random <span class="sy0">=</span> high <span class="sy0">+</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">;</span> 
    swap<span class="br0">(</span>arr<span class="br0">[</span>random<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>high<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> partition_random<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span> 
<span class="br0">{</span>     
    <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> random <span class="sy0">=</span> low <span class="sy0">+</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="br0">)</span><span class="sy0">;</span> 
    swap<span class="br0">(</span>arr<span class="br0">[</span>random<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>high<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> partition_random<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> low<span class="sy0">,</span> <span class="kw4">int</span> high<span class="br0">)</span> 
<span class="br0">{</span>     
    <span class="kw3">srand</span><span class="br0">(</span><span class="kw3">time</span><span class="br0">(</span>NULL<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> random <span class="sy0">=</span> low <span class="sy0">+</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="br0">(</span>high <span class="sy0">-</span> low<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
    swap<span class="br0">(</span>arr<span class="br0">[</span>low<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>high<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Best case time complexity is given in the case when there is equal partitioning of the array about the pivot. It is given by the relation T(n) = 2T(n/2) + n which gives the result O(n log n).</i><p><b>12. What is the worst case time complexity of randomized quicksort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: d<br>
Explanation: Randomized quick sort prevents the worst case complexity of O(n<sup>2</sup>) in most of the cases. But in some rare cases the time complexity can become O(n<sup>2</sup>). The probability of such a case is however very low.  </i><p><b>1. Quick sort uses which of the following algorithm to implement sorting?<br>
a) backtracking<br>
b) greedy algorithm<br>
c) divide and conquer<br>
d) dynamic programming<br>
</b></p><i>Answer: c<br>
Explanation: Quick sort uses the technique of divide and conquer in order to sort a given array. It divides the array into two parts about the pivot and then applies quick sort to both the parts.</i><p><b>2. What is the median of three techniques in quick sort?<br>
a) quick sort with random partitions<br>
b) quick sort with random choice of pivot<br>
c) choosing median element as pivot<br>
d) choosing median of first, last and middle element as pivot<br>
</b></p><i>Answer: d<br>
Explanation: In the median of three technique the median of first, last and middle element is chosen as the pivot. It is done so as to avoid the worst case of quick sort in which the time complexity shoots to O(n<sup>2</sup>).</i><p><b>3. What is the purpose of using a median of three quick sort over standard quick sort?<br>
a) so as to avoid worst case time complexity<br>
b) so as to avoid worst case space complexity<br>
c) to improve accuracy of output<br>
d) to improve average case time complexity<br>
</b></p><i>Answer: a<br>
Explanation: Median of three quick sort helps in avoiding the worst case time complexity of O(n<sup>2</sup>) which occurs in case when the input array is already sorted. However, the average case and best case time complexities remain unaltered.</i><p><b>4. What is the auxiliary space complexity of a median of three quick sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: Auxiliary space complexity of median of three quick sort is O(log n) which is used for storing call stack formed due to recursion. Note that the algorithms with space complexity as O(log n) also qualifies as in place algorithms as the value of log n is close to 1.</i><p><b>5. What is the average time complexity of the median of three quick sort?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>2</sup> log n)<br>
d) O(n log n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The average case time complexity of median of three quick sort is the same as that of a standard quick sort as randomized quick sort only helps in preventing the worst case. It is equal to O(n log n).</i><p><b>6. Quick sort uses which of the following method to implement sorting?<br>
a) merging<br>
b) partitioning<br>
c) selection<br>
d) exchanging<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort makes partitions of the input array about the pivot in order to implement sorting. Thus its method of sorting is called partitioning.</i><p><b>9. What is the best case time complexity Median of three quick sort?<br>
a) O(log n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: a<br>
Explanation: In-place algorithms require constant or very less auxiliary space. Median of three quick sort qualifies as an in-place sorting algorithm. It has a very low auxiliary space requirement of O(log n).</i><p><b>10. Which of the following function chooses a random index as the pivot?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> Median<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> mid<span class="sy0">;</span>
    mid <span class="sy0">=</span> <span class="br0">(</span>left <span class="sy0">+</span> right<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>left<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//to swap arr[left],arr[right]       </span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>left<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">,</span> left<span class="br0">)</span><span class="sy0">;</span><span class="co1">//to swap arr[left],arr[mid]</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> right<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span><span class="co1">// to swap arr[right],arr[mid]</span>
    <span class="kw1">return</span> mid<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> Median<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> mid<span class="sy0">;</span>
    mid <span class="sy0">=</span> <span class="br0">(</span>left <span class="sy0">+</span> right<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>left<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//to swap arr[left],arr[right]       </span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>left<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">,</span> left<span class="br0">)</span><span class="sy0">;</span><span class="co1">//to swap arr[left],arr[mid]</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> right<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span><span class="co1">// to swap arr[right],arr[mid]</span>
    <span class="kw1">return</span> mid<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> Median<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> mid<span class="sy0">;</span>
    mid <span class="sy0">=</span> <span class="br0">(</span>left <span class="sy0">+</span> right<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//to swap arr[left],arr[right]       </span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">,</span> left<span class="br0">)</span><span class="sy0">;</span><span class="co1">//to swap arr[left],arr[mid]</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> right<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span><span class="co1">// to swap arr[right],arr[mid]</span>
    <span class="kw1">return</span> mid<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> Median<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> mid<span class="sy0">;</span>
    mid <span class="sy0">=</span> <span class="br0">(</span>left <span class="sy0">+</span> right<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>left<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="br0">)</span><span class="sy0">;</span> <span class="co1">//to swap arr[left],arr[right]       </span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>mid<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> mid<span class="sy0">,</span> left<span class="br0">)</span><span class="sy0">;</span><span class="co1">//to swap arr[left],arr[mid]</span>
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>right<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        Swap<span class="br0">(</span>arr<span class="sy0">,</span> right<span class="sy0">,</span> mid<span class="br0">)</span><span class="sy0">;</span><span class="co1">// to swap arr[right],arr[mid]</span>
    <span class="kw1">return</span> mid<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Median of three quick sort like standard quick sort is also not a stable sorting algorithm. It is because the elements with the same values are not guaranteed to appear in the same relative order in the output sorted array.</i><p><b>11. What will be the pivot for the array arr={8,2,4,9} for making the first partition when a median of three quick sort is implemented?<br>
a) 8<br>
b) 2<br>
c) 4<br>
d) 9<br>
</b></p><i>Answer: b<br>
Explanation: Best case time complexity is given in the case when there is equal partitioning of the array about the pivot. It is given by the relation T(n) = 2T(n/2) + n which gives the result O(n log n).</i><p><b>1. What is the other name for a shell sort algorithm?<br>
a) Diminishing increment sort<br>
b) Diminishing decrement sort<br>
c) Insertion sort<br>
d) Selection sort<br>
</b></p><i>Answer: a<br>
Explanation: The other name for a shell sort algorithm is diminishing decrement sort as the distance between comparisons decreases as the algorithm runs until the last phase.</i><p><b>2. The worst case running time of shell sort, using Shell’s increments is?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The lower bound of a shell sort algorithm is mathematically found to be O(N<sup>2</sup>).</i><p><b>3. Who invented the shell sort algorithm?<br>
a) John Von Neumann<br>
b) Donald Shell<br>
c) Tony Hoare<br>
d) Alan Shell<br>
</b></p><i>Answer: b<br>
Explanation: Shell sort algorithm is invented by Donald shell. Merge sort is invented by John Von Neumann. Quick sort is invented by Tony Hoare.</i><p><b>5. Shell sort algorithm is an example of?<br>
a) External sorting<br>
b) Internal sorting<br>
c) In-place sorting<br>
d) Bottom-up sorting<br>
</b></p><i>Answer: a<br>
Explanation: Shell sort broke the quadratic time barrier as it works by comparing elements that are distant.</i><p><b>7. Which of the following sorting algorithms is closely related to shell sort?<br>
a) Selection sort<br>
b) Merge sort<br>
c) Insertion sort<br>
d) Bucket sort<br>
</b></p><i>Answer: b<br>
Explanation: Shell sort is an example of internal sorting because sorting of elements is done internally using an array.</i><p><b>8. Why is Shell sort called as a generalization of Insertion sort?<br>
a) Shell sort allows an exchange of far items whereas insertion sort moves elements by one position<br>
b) Improved lower bound analysis<br>
c) Insertion is more efficient than any other algorithms<br>
d) Shell sort performs internal sorting<br>
</b></p><i>Answer: a<br>
Explanation: Shell sort uses an increment sequence h1, h2, h3… and this sequence will work as long as h1=1.</i><p><b>10. Which of the following statements is the basic for loop for a shell sort algorithm?<br>
a) for(increment=N/2;increment&gt;0;increment/=2)<br>
b) for(i=1;i&lt;n;i++)<br>
c) for(i=n/2;i&gt;=0;i- -)<br>
d) for(i=0;i&lt; n;i++;numelements- -)<br>
</b></p><i>Answer: c<br>
Explanation: Shell sort performs an insertion sort on hk independent arrays. It is mainly a variation of insertion sort.</i><p><b>11. On how many increment sequences does the worst case analysis of shell sort depends?<br>
a) one<br>
b) two<br>
c) three<br>
d) four<br>
</b></p><i>Answer: a<br>
Explanation: Shell sort is an extension of insertion sort because it swaps elements at far distances and at a faster rate.</i><p><b>12. What is the worst case running time of shell sort using Hibbard’s increments?<br>
a) O(N)<br>
b) O(N<sup>2</sup>)<br>
c) O(N<sup>1/2</sup>)<br>
d) O(N<sup>3/2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The general strategy to hk sort is for each position, i, in hk,, hk+1,…., N-1, place the element in the correct spot among i, i-hk,i-2hk, etc.</i><p><b>13. What is the general form of Shell’s increments?<br>
a) 1,2,3,…,n<br>
b) 1,3,7,….,2k-1<br>
c) 1,3,5,7,….,k-1<br>
d) 1,5,10,15,…, k-1<br>
</b></p><i>Answer: a<br>
Explanation: for(increment=N/2;increment&gt;0;increment/=2) represents shell sort, for(i=1;i&lt;n;i++) represents insertion sort, for(i=n/2;i&gt;=0;I- -) represents heap sort,  for(i=0;i&lt;n;i++;numelements- -) merge sort.</i><p><b>14. What is the worst case analysis of shell sort using Shell’s increments?<br>
a) O(N)<br>
b) O(N<sup>2</sup>)<br>
c) O(N<sup>1/2</sup>)<br>
d) O(N<sup>3/2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The worst case analysis of shell sort depends on two increment sequences- using Shell’s increments, Sedgewick’s and Hibbard’s increments.</i><p><b>15. What is the worst case analysis of Shell sort using Sedgewick’s increments?<br>
a) O(N<sup>2</sup>)<br>
b) O(N<sup>3/2</sup>)<br>
c) O(N<sup>4/3</sup>)<br>
d) O(N<sup>5/4</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: Mathematically, the lower bound analysis for shell sort using Hibbard’s increments is O(N<sup>3/2</sup>).</i><p><b>1. Shell sort is also known as _____________<br>
a) diminishing decrement sort<br>
b) diminishing increment sort<br>
c) partition exchange sort<br>
d) diminishing insertion sort<br>
</b></p><i>Answer: b<br>
Explanation: Shell sort is also known as diminishing increment sort since each pass is defined by an increment h such that only the records which are h units apart will be sorted.</i><p><b>3. Shell sort is applied on the elements 27 59 49 37 15 90 81 39 and the chosen decreasing sequence of increments is (5,3,1). The result after the first iteration will be<br>
a) 27 59 49 37 15 90 81 39<br>
b) 27 59 37 49 15 90 81 39<br>
c) 27 59 39 37 15 90 81 49<br>
d) 15 59 49 37 27 90 81 39<br>
</b></p><i>Answer: b<br>
Explanation: In Shell sort, the relative order of elements with equal values may change. Therefore, it is not a stable sorting algorithm. Shell sort is an in-place sorting algorithm as it requires O(1) auxiliary space.</i><p><b>4. Consider the following code snippet, which implements the Shell sort algorithm.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">shellSort<span class="br0">(</span> <span class="kw4">int</span> elements<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> num_elements <span class="sy0">,</span> <span class="kw4">int</span> incrmnts<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> num_incrmnts<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> incr<span class="sy0">,</span> j<span class="sy0">,</span> k<span class="sy0">,</span> span<span class="sy0">,</span> y<span class="sy0">;</span>
	<span class="kw1">for</span><span class="br0">(</span>incr <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> incr <span class="sy0">;&amp;</span>lt num_incrmnts<span class="sy0">;</span> incr<span class="sy0">++</span><span class="br0">)</span>
	<span class="br0">{</span>
		span <span class="sy0">=</span> incrmnts<span class="br0">[</span>incr<span class="br0">]</span><span class="sy0">;</span> data<span class="sy0">-</span>structure<span class="sy0">-</span>questions<span class="sy0">-</span>answers<span class="sy0">-</span>shell<span class="sy0">-</span>sort
		<span class="kw1">for</span><span class="br0">(</span> j <span class="sy0">=</span> span<span class="sy0">;</span> j <span class="sy0">&amp;</span>lt<span class="sy0">;</span> num_elements<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
		<span class="br0">{</span>
			k <span class="sy0">=</span> j<span class="sy0">;</span>
			y <span class="sy0">=</span> elements<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
			<span class="kw1">while</span> <span class="br0">(</span>________ <span class="br0">)</span>
			<span class="br0">{</span>
				elements <span class="br0">[</span> k<span class="br0">]</span>  <span class="sy0">=</span> elements<span class="br0">[</span>k <span class="sy0">-</span> span<span class="br0">]</span><span class="sy0">;</span>
				k <span class="sy0">=</span> k <span class="sy0">-</span> span<span class="sy0">;</span>
			<span class="br0">}</span>
			elements<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> y<span class="sy0">;</span>
		<span class="br0">}</span>
	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which condition will correctly implement the while loop?<br>
a) k &gt;= j &amp;&amp; y &lt; elements[k- span]&nbsp;&nbsp;&nbsp;&nbsp;<br>
b) k &gt;= span || y &lt; elements[k + span]&nbsp;&nbsp;&nbsp;&nbsp;<br>
c) k &gt;= j || y &lt; elements[k + span]&nbsp;&nbsp;&nbsp;&nbsp;<br>
d) k &gt;= span &amp;&amp; y &lt; elements[k- span]&nbsp;&nbsp;&nbsp;&nbsp;<br>
</b></p><i>Answer: c<br>
Explanation: Given elements 27 59 49 37 15 90 81 39,<br>
First Iteration (span = 5):<br>
<a href="https://www.sanfoundry.com/wp-content/uploads/2017/11/data-structures-questions-answers-shell-sort-q3.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2017/11/data-structures-questions-answers-shell-sort-q3.png" alt="data-structures-questions-answers-shell-sort-q3" width="300" height="141" class="alignnone size-full wp-image-218839" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20300%20141%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2017/11/data-structures-questions-answers-shell-sort-q3.png" alt="data-structures-questions-answers-shell-sort-q3" width="300" height="141" class="lazyload alignnone size-full wp-image-218839"></a><br>
So, the sequence after first iteration will be, 27 59 39 37 15 90 81 49.</i><p><b>5. Shell sort is an improvement on ____<br>
a) insertion sort<br>
b) selection sort<br>
c) binary tree sort<br>
d) quick sort<br>
</b></p><i>Answer: d<br>
Explanation: In Shell sort, for increment = h we sort the sub-arrays that start at arbitrary element and include every hth element.<br>
So, if h  = 4 the algorithms sorts:<br>
 		Sub-array formed with elements at positions 1, 5, 9, 13 … in original array<br>
 		Sub-array formed with elements at positions 2, 6, 10, 14 … in original array<br>
 		Sub-array formed with elements at positions 3, 7, 11, 15 … in original array<br>
 		Sub-array formed with elements at positions 4, 8, 12, 16 … in original array<br>
 Therefore, the condition given in option k &gt;= span &amp;&amp; y &lt; elements[k- span] will implement while loop correctly.</i><p><b>6. An array that is first 7-sorted, then 5-sorted becomes _________<br>
a) 7-ordered<br>
b) 5-ordered<br>
c) both 2-ordered and 5-ordered<br>
d) both 7-ordered and 5-ordered<br>
</b></p><i>Answer: a<br>
Explanation: Shell sort is an improvement on insertion sort that allows the exchange of elements that are far apart. Shell sort algorithm sorts separate sub-arrays of the original input array. These sub-arrays contains every hth element of the original array.</i><p><b>7. If Hibbard increments (h1= 1, h2= 3, h3= 7, …, hk = 2<sup>k</sup>–1) are used in a Shell sort implementation, then the best case time complexity will be ________<br>
a) O(nlogn)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: d<br>
Explanation: An array that is 7-sorted, becomes 7-ordered. And an array that is 5-sorted, becomes 5-ordered. If k-ordered array is h-sorted, it remains k-ordered. Thus, an array that is first 7-sorted, then 5-sorted becomes both 7-ordered and 5-ordered.</i><p><b>8. Records R1, R2, R3,.. RN  with keys K1, K2, K3,.. KN   are said to be h-ordered, if ________<br>
a) Ki &lt;= Ki+h  for 1&lt;= i*h &lt;= N<br>
b) Kh &lt;= Ki+h  for 1&lt;= i &lt;= N<br>
c) Ki &lt;= Kh  for 1&lt;= i &lt;= h<br>
d) Ki &lt;= Ki+h  for 1&lt;= i &lt;= N-h<br>
</b></p><i>Answer: a<br>
Explanation: The best case occurs when the array is already sorted. In best case the number of comparison for each of the increments-based insertion sorts is equal to length of array.<br>
Here 2k –1 &lt; n, where n is the number of records. So k &lt; log(n+1), thus the sorting time in best case is less the n * log(n+1). Therefore best case time complexity is O(nlogn).</i><p><b>10. Which of the following is true?<br>
a) Shell sort’s passes completely sort the elements before going on to the next-smallest gap while Comb sort’s passes do not completely sort the elements<br>
b) Shell sort’s passes do not completely sort the elements before going on to the next-smallest gap like in Comb sort<br>
c) Comb sort’s passes completely sort the elements before going on to the next-smallest gap like in Shell sort<br>
d) Shell sort’s passes do not completely sort the elements before going on to the next-smallest gap while Comb sort’s passes completely sort the elements<br>
</b></p><i>Answer: d<br>
Explanation: Records are h-ordered  if every hth element (starting anywhere) yields a sorted array. Therefore, given records with keys K1, K2, K3,.. KN   are said to be h-ordered, if Ki &lt;= Ki+h  for 1&lt;= i &lt;= N-h.</i><p><b>1. On which algorithm is heap sort based on?<br>
a) Fibonacci heap<br>
b) Binary tree<br>
c) Priority queue<br>
d) FIFO<br>
</b></p><i>Answer: c<br>
Explanation: Heap sort is based on the algorithm of priority queue and it gives the best sorting time.</i><p><b>2. In what time can a binary heap be built?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The basic strategy is to build a binary heap of N elements which takes O(N) time.</i><p><b>5. In what position does the array for heap sort contains data?<br>
a) 0<br>
b) 1<br>
c) -1<br>
d) anywhere in the array<br>
</b></p><i>Answer: b<br>
Explanation: Heap sort is slower than Shell sort because Shell sort uses Sedgewick’s increment sequence.</i><p><b>6. In heap sort, after deleting the last minimum element, the array will contain elements in?<br>
a) increasing sorting order<br>
b) decreasing sorting order<br>
c) tree inorder<br>
d) tree preorder<br>
</b></p><i>Answer: d<br>
Explanation: Constructing a max heap using the elements 97,53,59,26,41,58,31 will cause the heap to look like that.</i><p><b>7. What is the typical running time of a heap sort algorithm?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The array for heap sort contains data at position 0 whereas for a binary heap, array begins at 1. This is the reason for its complexity.</i><p><b>8. How many arrays are required to perform deletion operation in a heap?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: By logic, after deleting minimum element, the heap will contain elements in decreasing sorting order. We can change this by altering the ordering property.</i><p><b>9. What is the time taken to perform a delete min operation?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The total running time of a heap sort algorithm is mathematically found to be O(N log N).</i><p><b>11. What is the average number of comparisons used in a heap sort algorithm?<br>
a) N log N-O(N)<br>
b) O(N log N)-O(N)<br>
c) O(N log N)-1<br>
d) 2N log N + O(N)<br>
</b></p><i>Answer: b<br>
Explanation: To perform deletion operation in a heap, we require 2 arrays and that occupies extra memory space and hence increase in running time.</i><p><b>12. What is the time taken to copy elements to and from two arrays created for deletion?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The time taken to perform a deletion of a minimum element is mathematically found to be O( log N).</i><p><b>13. What is the average number of comparisons used to heap sort a random permutation of N distinct items?<br>
a) 2N log N-O(N)<br>
b) 2N log N-O(N log N)<br>
c) 2N log N-O(N log log N)<br>
d) 2N log N-O(log N)<br>
</b></p><i>Answer: a<br>
Explanation: Heap sort uses fewer comparisons than other sorting algorithms and hence it is an extremely stable algorithm.</i><p><b>1. Heap sort is an implementation of ____________ using a descending priority queue.<br>
a) insertion sort<br>
b) selection sort<br>
c) bubble sort<br>
d) merge sort<br>
</b></p><i>Answer: b<br>
Explanation: Heap sort is an implementation of selection sort using the input array as a heap representing a descending priority queue. Heap sort algorithm is divided into two phase. In first phase the max-heap is created and the second phase (selection phase) deletes the elements from the priority queue using siftdown operation.</i><p><b>2. Which one of the following is false?<br>
a) Heap sort is an in-place algorithm<br>
b) Heap sort has O(nlogn) average case time complexity<br>
c) Heap sort is stable sort<br>
d) Heap sort is a comparison-based sorting algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Heap sort is a comparison based sorting algorithm and has time complexity O(nlogn) in the average case. Heap sort is an in-place algorithm as it needs O(1) of auxiliary space. Heap sort uses heap and operations on heap can change the relative order of items with the same key values. Therefore, Heap sort is not a stable sort.</i><p><b>4. The descending heap property is ___________<br>
a) A[Parent(i)] = A[i] <br>
b) A[Parent(i)] &lt;= A[i] <br>
c) A[Parent(i)] &gt;= A[i] <br>
d) A[Parent(i)] &gt; 2 * A[i] <br>
</b></p><i>Answer: d<br>
Explanation:  In max-heap element at each node is smaller than or equal to the element at its parent node. On applying the heapify procedure on item at position 2, it will be in position 9 as shown below.<br>
<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp.png" alt="data-structures-questions-answers-heapsort-q3-exp" width="689" height="509" class="alignnone size-full wp-image-218849" srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp.png 689w, https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp-300x222.png 300w" sizes="(max-width: 689px) 100vw, 689px" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20689%20509%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp.png" alt="data-structures-questions-answers-heapsort-q3-exp" width="689" height="509" class="lazyload alignnone size-full wp-image-218849" data-srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp.png 689w, https://www.sanfoundry.com/wp-content/uploads/2018/07/data-structures-questions-answers-heapsort-q3-exp-300x222.png 300w" data-sizes="(max-width: 689px) 100vw, 689px"></a><br>
</i><p><b>5. What is its wort case time complexity of Heap sort?<br>
a) O(nlogn)<br>
b) O(n<sup>2</sup>logn)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The max-heap is also known as descending heap. Max-heap of size n is an almost complete binary tree of n nodes such that the element at each node is less than or equal to the element at its parent node. </i><p><b>7. Choose the correct option to fill? X so that the code given below implements the Heap sort.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">#include <span class="sy0">&lt;</span>stdio.<span class="me1">h</span><span class="sy0">&gt;</span> 
<span class="kw4">void</span> heapify<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> n, <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> largest <span class="sy0">=</span> i<span class="sy0">;</span> <span class="co1">// Initialize largest as root </span>
    <span class="kw4">int</span> l <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">*</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> <span class="co1">// left = 2*i + 1 </span>
    <span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">*</span>i <span class="sy0">+</span> <span class="nu0">2</span><span class="sy0">;</span> <span class="co1">// right = 2*i + 2 </span>
    <span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>largest<span class="br0">]</span><span class="br0">)</span> 
        largest <span class="sy0">=</span> l<span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>r <span class="sy0">&lt;</span> n <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>r<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>largest<span class="br0">]</span><span class="br0">)</span> 
        largest <span class="sy0">=</span> r<span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>largest <span class="sy0">!=</span> i<span class="br0">)</span> 
    <span class="br0">{</span> 
        swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span>, arr<span class="br0">[</span>largest<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        heapify<span class="br0">(</span>arr, n, largest<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> heapSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> n <span class="sy0">/</span> <span class="nu0">2</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span> 
        heapify<span class="br0">(</span>arr, n, i<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        X<span class="sy0">;</span>
        heapify<span class="br0">(</span>arr, i, <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArray<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
        printf<span class="br0">(</span>“<span class="sy0">%</span>d”,arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    printf<span class="br0">(</span>“\n”<span class="br0">)</span><span class="sy0">;</span>	    
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">12</span>, <span class="nu0">11</span>, <span class="nu0">13</span>, <span class="nu0">5</span>, <span class="nu0">6</span>, <span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> sizeof<span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span>sizeof<span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    heapSort<span class="br0">(</span>arr, n<span class="br0">)</span><span class="sy0">;</span> 
    printf<span class="br0">(</span>“Sorted array is \n<span class="st0">"); 
    printArray(arr, n); 
}</span></pre></div></div></div></div></div></div><p><b>a) swap(arr[0], arr[n])<br>
b) swap(arr[i], arr[n])<br>
c) swap(arr[0], arr[i])<br>
d) swap(arr[i], arr[2*i])<br>
</b></p><i>Answer: a<br>
Explanation: In Heap sort, the call to procedure build_Max-heap takes O(n) time and each of O(n) calls to the function max_Heapify takes O(logn) time. So the worst case complexity of Heap sort is O(nlogn).</i><p><b>8. Which one of the following is a variation of Heap sort?<br>
a) Comb sort<br>
b) Smooth sort<br>
c) Binary tree sort<br>
d) Shell sort<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort is more efficient than Heap sort because experiments indicate that Heap sort requires twice as much time as Quick sort for randomly sorted input.</i><p><b>9. Introsort algorithm is combination of _____________<br>
a) Quick sort and Heap sort<br>
b) Quick sort and Shell sort<br>
c) Heap sort and Merge sort<br>
d) Heap sort and insertion sort<br>
</b></p><i>Answer: c<br>
Explanation: Steps in heap sort are : (i) Build the max-heap, (ii) Swap the root element with the last element of the heap, (iii) Reduce the size of heap by 1 and heapify the root element, (iv) Repeat the steps form step number (v) until all the elements are sorted. Therefore the correct option is swap(arr[0], arr[i]).</i><p><b>10. How many elements can be sorted in O(logn) time using Heap sort?<br>
a) O(1)<br>
b) O(n/2)<br>
c) O(logn/log(logn))<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: Smooth sort is a variation of Heap sort. Smooth sort has O(nlogn) worst case time complexity like Heap sort. But Smooth sort takes O(n) time to sort the nearly sorted input array.</i><p><b>1. Which of the following sorting algorithm is used by C++ internally?<br>
a) quicksort<br>
b) introsort<br>
c) merge sort<br>
d) heap sort<br>
</b></p><i>Answer: b<br>
Explanation: Introsort is the in built sorting algorithm used by C++. It is an example of a hybrid sorting algorithm which means it uses more than one sorting algorithm as a routine.</i><p><b>2. Which of the following sorting algorithm is not a constituent of introsort?<br>
a) selection sort<br>
b) quicksort<br>
c) insertion sort<br>
d) heap sort<br>
</b></p><i>Answer: a<br>
Explanation: Introsort is a hybrid sorting algorithm which means it uses more than one sorting algorithm as a routine. It may use quick sort or heap sort or insertion sort depending on the given situation.</i><p><b>3. Introsort begins sorting the given array by using which of the following sorting algorithm?<br>
a) selection sort<br>
b) quick sort<br>
c) insertion sort<br>
d) heap sort<br>
</b></p><i>Answer: b<br>
Explanation: Introsort begins sorting any given array by using quick sort. Then it may switch to heap sort or insertion sort or may stick to quick sort depending upon the size of the partition.</i><p><b>4. Which of the following sorting algorithm is NOT stable?<br>
a) Introsort<br>
b) Brick sort<br>
c) Bubble sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options introsort is the only algorithm which is not stable. As it may use quick sort in some case to perform sorting which is itself not stable. Thus stability of introsort is not guaranteed.</i><p><b>5. Which of the following sorting algorithm is in-place?<br>
a) intro sort<br>
b) merge sort<br>
c) counting sort<br>
d) radix sort<br>
</b></p><i>Answer: a<br>
Explanation: Introsort may use quick sort or heap sort or insertion sort internally in order to sort the given input. All of the three algorithms are in place, thus making introsort to be an in-place sorting algorithm.</i><p><b>7. What is the best case time complexity of introsort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Quicksort, heap sort and insertion sort are comparison based sorts. Thus overall introsort also becomes a comparison based sort.</i><p><b>8. What is the worst case time complexity of introsort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Introsort is mainly governed by heap sort and quick sort. As the best case of both heap sort and quick sort is O(n log n) so the best case of introsort also becomes O(n log n).</i><p><b>9. What is the average time complexity of introsort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Worst case time complexity of quicksort is avoided when we implement introsort. Introsort switches to heap sort when there is a possibility of crossing the maximum depth limit.</i><p><b>10. What is the auxiliary space requirement of introsort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Average time complexity of introsort remains to be O(n log n) as for most of the cases quick sort and heap sort are used which have O(n log n) time complexity for an average case. </i><p><b>11. Why is heap sort preferred over merge sort for introsort implementation?<br>
a) Because heap sort is faster<br>
b) Because heap sort requires less space<br>
c) Because heap sort is easy to implement<br>
d) Because heap sort is easy to understand<br>
</b></p><i>Answer: d<br>
Explanation: Introsort is a hybrid of quick sort, heap sort and insertion sort. So like quick sort it may use O(log n) auxiliary space in the stack to store call statements.</i><p><b>12. Why is insertion sort preferred over other sorting algorithms (like selection sort, bubble sort etc.) for introsort implementation?<br>
a) Because insertion sort is faster and adaptive<br>
b) Because insertion sort requires less space<br>
c) Because insertion sort is easy to implement<br>
d) Because insertion sort is easy to understand<br>
</b></p><i>Answer: b<br>
Explanation: Both heap sort and merge sort have the same time complexity. But heap sort is an in-place sorting algorithm whereas merge sort requires O(n) auxiliary space which makes heap sort a more preferable option.</i><p><b>13. What is the cut-off for switching from quick sort to insertion sort in the implementation of introsort?<br>
a) 4<br>
b) 8<br>
c) 16<br>
d) 32<br>
</b></p><i>Answer: a<br>
Explanation: When small arrays need to be sorted then insertion sort proves to be the best choice. Also it is adaptive so it performs better than others when the given array is fully/partially sorted.</i><p><b>14. What is the cut-off for switching from quick sort to heap sort in the implementation of introsort?<br>
a) 16<br>
b) n<sup>2</sup><br>
c) n log(n)<br>
d) 2 log (n)<br>
</b></p><i>Answer: c<br>
Explanation: When small arrays needs to be sorted then insertion sort proves to be the best choice. So when the size of the partition is less than 16 introsort switches to insertion sort. This particular value has been deduced experimentally.</i><p><b>15. Which of the following sorting algorithm will be preferred when the size of partition is between 16 and 2 log(n) while implementing introsort?<br>
a) quick sort<br>
b) insertion sort<br>
c) heap sort<br>
d) merge sort<br>
</b></p><i>Answer: d<br>
Explanation: Quicksort has a worst case time complexity of O(n<sup>2</sup>) which is not preferable. So in order to avoid worst case of quicksort, introsort switches to heap sort when the depth is greater than 2 log(n). This particular value has been deduced experimentally.</i><p><b>16. What will be the output of the given C++ code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  
    sort<span class="br0">(</span>arr<span class="sy0">,</span> arr<span class="sy0">+</span>n<span class="sy0">,</span> greater<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw4">int</span> a<span class="sy0">;</span> 
    <span class="kw1">for</span> <span class="br0">(</span>a <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> a <span class="sy0">&lt;</span> n<span class="sy0">;</span> a<span class="sy0">++</span><span class="br0">)</span> 
        cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>a<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span>   
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2 3 4 5<br>
b) 1 3 4 2 5<br>
c) 5 4 3 2 1<br>
d) error<br>
</b></p><i>Answer: a<br>
Explanation: Quicksort proves to be the best sorting algorithm for mid sized arrays as it has low space and time complexity. Thus quick sort is preferred when size of partition is between 16 and 2 log(n).</i><p><b>17. What will be the output of the given C++ code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>   
    sort<span class="br0">(</span>arr<span class="sy0">,</span> arr<span class="sy0">+</span>n<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw4">int</span> a<span class="sy0">;</span>
    <span class="kw1">for</span> <span class="br0">(</span> a <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> a<span class="sy0">&lt;</span> n<span class="sy0">;</span> a<span class="sy0">++</span><span class="br0">)</span> 
        cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>a<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span>  
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2 3 4 5<br>
b) 1 3 4 2 5<br>
c) 5 4 3 2 1<br>
d) error<br>
</b></p><i>Answer: c<br>
Explanation: The given program sorts the input in descending order. It is due to the third parameter i.e. greater() which is passed to the function sort().</i><p><b>18. What will be the output of the given C++ code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	sort<span class="br0">(</span>arr<span class="sy0">+</span><span class="nu0">2</span><span class="sy0">,</span> arr<span class="sy0">+</span>n<span class="sy0">,</span> greater<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw4">int</span> a<span class="sy0">;</span>
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> a <span class="sy0">&lt;</span> n<span class="sy0">;</span> a<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>a<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2 3 4 5<br>
b) 1 5 4 3 2<br>
c) 5 4 3 2 1<br>
d) 1 3 5 4 2<br>
</b></p><i>Answer: a<br>
Explanation: The given program sorts the input in ascending order. Function sort() uses two parameters in the form of address of the first and last element of the array to sort the array.</i><p><b>1. Which of the following is Python’s standard sorting algorithm?<br>
a) quick sort<br>
b) introsort<br>
c) merge sort<br>
d) tim sort<br>
</b></p><i>Answer: d<br>
Explanation: Tim sort has been python’s standard sorting algorithm since its version 2.3. It is an example of hybrid sorting algorithm which means it uses more than one sorting algorithm as a routine.</i><p><b>2. Which of the following sorting algorithm is a constituent of tim sort?<br>
a) selection sort<br>
b) quick sort<br>
c) merge sort<br>
d) heap sort<br>
</b></p><i>Answer: c<br>
Explanation: Tim sort is a hybrid sorting algorithm which means it uses more than one sorting algorithm as a routine. It is derived from insertion sort and merge sort.</i><p><b>3. Tim sort begins sorting the given array by using which of the following sorting algorithm?<br>
a) selection sort<br>
b) quick sort<br>
c) insertion sort<br>
d) merge sort<br>
</b></p><i>Answer: c<br>
Explanation: Tim sort begins sorting any given array by using insertion sort for each run. The array is divided into smaller parts for this purpose, each part having a size equal to value of run. Then these small parts called runs are merged in order to obtain sorted array.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Tim sort<br>
b) Introsort<br>
c) Quick sort<br>
d) Heap sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options Tim sort is the only algorithm which is stable. As both constituents of Tim sort (I.e insertion sort and merge sort) are stable so Tim sort also becomes stable.</i><p><b>5. Which of the following sorting algorithm is not in-place?<br>
a) insertion sort<br>
b) tim sort<br>
c) quick sort<br>
d) intro sort<br>
</b></p><i>Answer: b<br>
Explanation: Tim sort is not an in-place sorting algorithm as it requires auxiliary space. It is because it requires to merge sorted runs which requires a third array of the size equal to the sum of the two runs. </i><p><b>7. What is the best case time complexity of Tim sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Merge sort and insertion sort are comparison based sorts. Thus overall Tim sort also becomes a comparison based sort.</i><p><b>8. What is the worst case time complexity of Tim sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Best case time complexity of Tim sort occurs when the input array is already sorted. In such a case only one run will be required.</i><p><b>9. What is the average time complexity of Tim sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Worst case time complexity of Tim sort is O(n log n). It is because the worst complexity of merge sort is O(n log n) and insertion sort is only applied for small arrays.</i><p><b>10. What is the auxiliary space requirement of Tim sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Average time complexity of Tim sort remains to be O(n log n). It is the same as the average case complexity of merge sort.</i><p><b>11. Which of the following algorithm is implemented internally in java when we use function arrays.sort()?<br>
a) intro sort<br>
b) quick sort<br>
c) tim sort<br>
d) merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Tim sort is a hybrid of merge sort and insertion sort. It requires to merge sorted runs which require a third array of the size equal to the sum of the two runs. So in worst case the auxiliary space requirement will be O(n).</i><p><b>12. Why is insertion sort preferred over other sorting algorithms (like selection sort, bubble sort etc.) for Tim sort implementation?<br>
a) Because insertion sort is faster and adaptive<br>
b) Because insertion sort requires less space<br>
c) Because insertion sort is easy to implement<br>
d) Because insertion sort is easy to understand<br>
</b></p><i>Answer: c<br>
Explanation: Java makes use of Tim sort internally for implementing arrays.sort(). It is mainly due to the fastness of this algorithm in comparison to other comparison based sorts.</i><p><b>13. In which case will tim sort will work as an insertion sort?<br>
a) when no. of elements are less than 64<br>
b) when no. of elements are greater than 64<br>
c) when no. of elements are less than size of run<br>
d) when no. of elements are less than 32<br>
</b></p><i>Answer: a<br>
Explanation: When small arrays need to be sorted then insertion sort proves to be the best choice. Also, it is adaptive so it performs better than others when the given array is fully/partially sorted.</i><p><b>14. What is the usual size of a run in tim sort?<br>
a) 32<br>
b) less than 32<br>
c) 32-64 depending on size of the array<br>
d) 64<br>
</b></p><i>Answer: c<br>
Explanation: Tim sort uses a hybrid of insertion and merge sort. It reduces to insertion sort when the size of array is less than the size of run as insertion sort is efficient in sorting small arrays.</i><p><b>15. What will be the output of the given Java code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">import java.<span class="me1">util</span>.<span class="me1">Arrays</span><span class="sy0">;</span> 
public class SortExample 
<span class="br0">{</span> 
	public <span class="kw4">static</span> <span class="kw4">void</span> main<span class="br0">(</span>String<span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="co1">// Our arr contains 8 elements </span>
		<span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">;</span> 
		Arrays.<span class="me1">sort</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">;</span> 
		System.<span class="me1">out</span>.<span class="kw3">printf</span><span class="br0">(</span>Arrays.<span class="me1">toString</span><span class="br0">(</span>arr<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) [4,5,7,8,9,10] <br>
b) [10,9,8,7,5,4] <br>
c) 4,5,7,8,9,10<br>
d) error<br>
</b></p><i>Answer: c<br>
Explanation: Usually the size of the run is chosen somewhere between 32 and 64. The size of run is preferably chosen in powers of 2 in order to maintain balance while merging the sorted runs.</i><p><b>16. What will be the output of the given Java code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">import java.<span class="me1">util</span>.<span class="me1">Arrays</span><span class="sy0">;</span> 
public class SortExample 
<span class="br0">{</span> 
	public <span class="kw4">static</span> <span class="kw4">void</span> main<span class="br0">(</span>String<span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span> arr <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">;</span> 
		Arrays.<span class="me1">sort</span><span class="br0">(</span>arr<span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span> 
		System.<span class="me1">out</span>.<span class="kw3">printf</span><span class="br0">(</span>Arrays.<span class="me1">toString</span><span class="br0">(</span>arr<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) [4,5,7,8,9,10] <br>
b) [10,9,8,7,5,4] <br>
c) [10,5,7,8,9,4] <br>
d) [10,7,9,5,8,4] <br>
</b></p><i>Answer: a<br>
Explanation: The given program sorts the input in ascending order by using the function Arrays.sort(). It uses Tim sort internally.</i><p><b>1. Which of the following is an example of parallel sorting technique?<br>
a) bogo sort<br>
b) sleep sort<br>
c) cube sort<br>
d) merge sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options only cube sort is a parallel sorting algorithm. It builds self balancing multi dimensional arrays from the input keys.</i><p><b>2. What is the worst case time complexity of cube sort?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(n log n)<br>
d) O(n2)<br>
</b></p><i>Answer: c<br>
Explanation: The worst case performance of cube sort is O(n log n). This is the fastest possible complexity with a comparison based sort.</i><p><b>3. What is the auxiliary space requirement of cube sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Cube sort requires an auxiliary space of O(n). This is the worst case of auxiliary space complexity.</i><p><b>4. What is the best case time complexity of cube sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(1)<br>
</b></p><i>Answer: b<br>
Explanation: Best case time complexity of cube sort occurs when the input array is almost sorted. So in such a case only O(n) time is required for sorting.   </i><p><b>5. What is the average case time complexity of cube sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n log n)<br>
c) O(log n)<br>
d) O(n)<br>
</b></p><i>Answer: b<br>
Explanation: The average case performance of cube sort is O(n log n). This is the fastest possible complexity with a comparison based sort.</i><p><b>6. Which of the following algorithm is stable?<br>
a) heap sort<br>
b) cube sort<br>
c) quick sort<br>
d) bogosort<br>
</b></p><i>Answer: d<br>
Explanation: Out of the given algorithms only cube sort is stable. This implies that the relative position of equal valued elements in the input and sorted array remains the same.</i><p><b>8. Which of the following is a disadvantage of cube sort?<br>
a) high memory overhead for small data<br>
b) high memory overhead for any data<br>
c) balancing is slow<br>
d) Iteration is slow<br>
</b></p><i>Answer: b<br>
Explanation: Cube sort has an auxiliary space complexity of O(n). So it does not qualify to be an in-place sort.</i><p><b>10. Which of the following sorting algorithm uses the method of insertion?<br>
a) cube sort<br>
b) bubble sort<br>
c) quick sort<br>
d) selection sort<br>
</b></p><i>Answer: a<br>
Explanation: In a general case the memory overhead of cube sort is low. But when the data set is small then in that case the memory overhead becomes high.</i><p><b>1. Consider the original array 17 8 12 4 26.  How many comparisons are needed to construct the BST on the original array?<br>
a) 5<br>
b) 4<br>
c) 7<br>
d) 10<br>
</b></p><i>Answer: d<br>
Explanation: Original array is 17 8 12 4 26. The BST built on this array is shown in the figure below.<br>
<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/binary-tree-sort-questions-answers-q1.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/binary-tree-sort-questions-answers-q1.png" alt="binary-tree-sort-questions-answers-q1" width="244" height="214" class="alignnone size-full wp-image-218852" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20244%20214%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/binary-tree-sort-questions-answers-q1.png" alt="binary-tree-sort-questions-answers-q1" width="244" height="214" class="lazyload alignnone size-full wp-image-218852"></a><br>
To built the BST, we travel down the tree until a leaf is reached. Therefore, for every element we compare the element with the internal nodes until we the leaves and then once again compare the element with its parent to decide whether it is right child or left child. So, for given array we need to perform 10 comparisons to build the BST.</i><p><b>2. In binary tree sort, we first construct the BST and then we perform _______ traversal to get the sorted order.<br>
a) inorder<br>
b) postorder<br>
c) preorder<br>
d) level order<br>
</b></p><i>Answer: a<br>
Explanation: In binary tree sort is a sort algorithm where a binary search tree is built from the elements to be sorted, and then we perform inorder traversal on the BST to get the elements in sorted order. </i><p><b>3. What is the worst case time complexity of the binary tree sort?<br>
a) O(n)<br>
b) O(nlogn)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: c<br>
Explanation: For the binary tree sort the worst case when the BST constructed is unbalanced. BST gets unbalanced when the elements are already sorted. So, in the worst case, O(n<sup>2</sup>) time is required to built the BST and O(n) time to traverse the tree. Therefore, the worst case time complexity is O(n<sup>2</sup>) + O(n) = O(n<sup>2</sup>).</i><p><b>4. The insert() procedure, given below, builds the BST on the input elements, which is the first step of the binary tree sort. Choose the correct to fill the condition.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> insert<span class="br0">(</span>Tree<span class="sy0">*</span> node<span class="sy0">,</span> <span class="kw4">int</span> newElement<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>node<span class="sy0">==</span> NULL<span class="br0">)</span>
	<span class="br0">{</span>
		node <span class="sy0">=</span> createNewNode<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		node<span class="sy0">-&gt;</span> value <span class="sy0">=</span> newElement<span class="sy0">;</span>
		node <span class="sy0">-&gt;</span> left <span class="sy0">=</span> NULL<span class="sy0">;</span>
		node <span class="sy0">-&gt;</span> right <span class="sy0">=</span> NULL<span class="sy0">;</span>
		<span class="kw1">return</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>__________________<span class="br0">)</span>
	<span class="br0">{</span>
		insert<span class="br0">(</span>node<span class="sy0">-&gt;</span>left<span class="sy0">,</span> newElement<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		insert<span class="br0">(</span>node<span class="sy0">-&gt;</span>right<span class="sy0">,</span> newElement<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) newElement &gt; node-&gt;value<br>
b) newElement &lt; node-&gt;value<br>
c) newElement == root-&gt;value<br>
d) newElement != root-&gt;value<br>
</b></p><i>Answer: b<br>
Explanation: In binary tree sort, the BST is built on the input elements and the tree is traversed in in-order to get the sorted order. While building the BST, we travel down the tree until a leaf is reached. While traveling dawn the tree, we travel on left subtree if the new element is less than the node or to the right if the element is greater or equal to the node. So, correct option is newElement &lt; node-&gt;value.</i><p><b>5. What is the best case time complexity of the binary tree sort?<br>
a) O(n)<br>
b) O(nlogn)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: The best case occurs when the BST is balanced. So, when tree is balanced we require O(nlogn) time to build the tree and O(n) time to traverse the tree. So, the best case time complexity of the binary tree sort is O(nlogn).</i><p><b>7. Which of the following is false?<br>
a) Binary tree sort and quick sort have same running time<br>
b) Binary tree sort used BST as work area<br>
c) As the number of elements to sort gets larger, binary tree sort gets more and more efficient<br>
d) Both quick sort and binary tree are in place sorting algorithms<br>
</b></p><i>Answer: b<br>
Explanation: In binary tree sort it is required to reserve one tree node for each array element. Its implementation requires two pointer variables for each node. So, it requires extra memory. The worst case space complexity of binary tree sort is Θ(n). Therefore, binary tree sort is not an in-place sorting algorithm.</i><p><b>8. Which of the following sorting algorithms can be considered as improvement to the binary tree sort?<br>
a) Heap sort<br>
b) Quick sort<br>
c) Selection sort<br>
d) Insertion sort<br>
</b></p><i>Answer: d<br>
Explanation: Binary tree sort and quick sort have same running time i.e O(nlogn)<br>
in average case and O(n<sup>2</sup>) in worst case. Binary tree is not in-place sorting algorithm.</i><p><b>1. Which of the following is an example of an unstable sorting algorithm?<br>
a) cycle sort<br>
b) insertion sort<br>
c) bubble sort<br>
d) merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options only cycle sort is an unstable sorting algorithm. This implies that the relative position of equal valued elements in the input and sorted array does not remain the same when we use cycle sort.</i><p><b>2. What is the worst case time complexity of cycle sort?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The worst case performance of cycle sort is O(n<sup>2</sup>). It is because it has to make n comparisons for each element of the array.</i><p><b>3. What is the auxiliary space requirement of cycle sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Cycle sort requires an auxiliary space of O(1). So this makes it an in-place sorting algorithm.</i><p><b>4. What is the best case time complexity of cycle sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(1)<br>
</b></p><i>Answer: a<br>
Explanation: Best case time complexity of cycle sort is O(n<sup>2</sup>). This shows that cycle sort is not an adaptive sorting algorithm and thus makes it undesirable when the given array is already almost sorted.</i><p><b>5. What is the average case time complexity of cycle sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n log n)<br>
c) O(log n)<br>
d) O(n)<br>
</b></p><i>Answer: a<br>
Explanation: The average case performance of cycle sort is O(n<sup>2</sup>). It is because it has to make n comparisons for each element of the array.</i><p><b>7. Which of the following sorting algorithm is in-place?<br>
a) Merge sort<br>
b) Cycle sort<br>
c) Counting sort<br>
d) Radix sort<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of cycle sort is O(n<sup>2</sup>) in any case. So cycle sort algorithm is not adaptive, as it will take the same time to sort an already sorted array and any other randomly arranged array.</i><p><b>8. Which of the following is an advantage of cycle sort?<br>
a) it can sort large arrays efficiently<br>
b) it has a low time complexity<br>
c) it requires minimal write operations<br>
d) it is an adaptive sorting algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Cycle sort has an auxiliary space complexity of O(1). So it qualifies to be an in-place sort. All other given options are not in place sorting algorithm.</i><p><b>10. Which of the following sorting algorithm uses the method of insertion?<br>
a) cycle sort<br>
b) bubble sort<br>
c) quick sort<br>
d) selection sort<br>
</b></p><i>Answer: c<br>
Explanation: Cycle sort is a slow sorting algorithm as compared to quick sort, merge sort etc. and is also not adaptive. But it offers an advantage that it performs minimal write operations which can be very useful in a situation where the write operation is expensive.</i><p><b>11. How many write operations will be required to sort the array arr={2,4,3,5,1} using cycle sort?<br>
a) 4<br>
b) 5<br>
c) 6<br>
d) 3<br>
</b></p><i>Answer: a<br>
Explanation: Cycle sort is a comparison based sorting algorithm. This is because it compares elements in order to sort them.   </i><p><b>12. Which of the following algorithm is best suited for the case where swap operation is expensive?<br>
a) bubble sort<br>
b) cycle sort<br>
c) cocktail sort<br>
d) merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Cycle sort is the only algorithm from the given ones that uses the method of insertion. Other than this, insertion sort also uses the method of insertion for sorting.  </i><p><b>1. Which of the following is a disadvantage of library sort when compared to insertion sort?<br>
a) library sort has greater time complexity<br>
b) library sort has greater space complexity<br>
c) library sort makes more comparisons<br>
d) it has no significant disadvantage<br>
</b></p><i>Answer: b<br>
Explanation: Library sort has a disadvantage that it takes up O(n) auxiliary space whereas insertion sort takes constant auxiliary space.</i><p><b>3. Library sort is a modified version of which of the following sorting algorithm?<br>
a) Bubble sort<br>
b) selection sort<br>
c) insertion sort<br>
d) quick sort<br>
</b></p><i>Answer: a<br>
Explanation: Library sort does not require the entire input data at the beginning itself in order to sort the array. It rather creates a partial solution in every step, so future elements are not required to be considered. Hence it is an online sorting algorithm like insertion sort.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Selection sort<br>
b) Quick sort<br>
c) Library sort<br>
d) Heap sort<br>
</b></p><i>Answer: c<br>
Explanation: Library sort requires the use of Insertion sort and binary search in its code. So it is a modified version of insertion sort.</i><p><b>5. Which of the following sorting algorithm requires the use of binary search in their implementation?<br>
a) radix sort<br>
b) library sort<br>
c) odd-even sort<br>
d) bead sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options library sort is the only algorithm which is stable. It is because the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>7. What is the average case time complexity of library sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Library sort makes use of a binary search algorithm. It is used to find the correct index in the array where the element should be inserted. Then after the insertion of the element re-balancing of the array takes place.</i><p><b>8. What is the best case time complexity of library sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In library sort, we need to compare elements in order to insert them at the correct index. So we can say that it uses comparisons in order to sort the array. Thus it qualifies as a comparison based sort.</i><p><b>9. What is the worst case time complexity of library sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Library sort uses binary search in order to insert elements in the sorted segment of the array which reduces its time complexity. So the average time complexity of library sort is O(n log n).</i><p><b>10. Which of the following is an alternate name of library sort?<br>
a) gapped insertion sort<br>
b) binary insertion sort<br>
c) recursive insertion sort<br>
d) binary gap sort<br>
</b></p><i>Answer: a<br>
Explanation: The best case time complexity of library sort is O(n). It occurs in the case when the input is already/almost sorted.</i><p><b>11. What is the advantage of library sort over insertion sort?<br>
a) Library sort has a better average time complexity<br>
b) Library sort has a better space complexity<br>
c) Library sort has better best case time complexity<br>
d) Library has better worst case time complexity<br>
</b></p><i>Answer: c<br>
Explanation: The worst case time complexity of library sort is the same as that of insertion sort. The worst case time complexity is O(n<sup>2</sup>).</i><p><b>12. What is the auxiliary space complexity of library sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Library sort is also known as gapped insertion sort because it uses insertion sort with gaps in between successive elements. These gaps allow for fast insertion.</i><p><b>13. Which of the following is an adaptive sorting algorithm?<br>
a) library sort<br>
b) merge sort<br>
c) heap sort<br>
d) selection sort<br>
</b></p><i>Answer: a<br>
Explanation: Library sort has a better average time complexity as compared to insertion sort because it uses binary search for finding the index where the element has to be inserted in the sorted array. This makes the process faster.</i><p><b>14. Which of the following sorting algorithm is not in place?<br>
a) library sort<br>
b) quick sort sort<br>
c) heap sort<br>
d) gnome sort<br>
</b></p><i>Answer: a<br>
Explanation: The auxiliary space required by library sort is O(n). This space is taken up by the gaps present in between successive elements.</i><p><b>15. Which of the following is not true about library sort?<br>
a) it uses binary search and insertion sort in its implementation<br>
b) gaps are created between successive elements in order to ensure faster insertion<br>
c) array needs to be re balanced after every insertion<br>
d) it is an in place sorting algorithm<br>
</b></p><i>Answer: a<br>
Explanation: Library sort is an adaptive algorithm. It is because the time complexity of the algorithm improves when the input array is almost sorted.</i><p><b>1. Which one of the following sorting algorithm requires recursion?<br>
a) pigeonhole sort<br>
b) strand sort<br>
c) insertion sort<br>
d) counting sort<br>
</b></p><i>Answer: b<br>
Explanation: Strand sort requires the use of recursion for implementing its algorithm. On the other hand, the sorting algorithms given in the remaining options use iterative methods.</i><p><b>2. Strand sort is most efficient for data stored in?<br>
a) linked list<br>
b) arrays<br>
c) trees<br>
d) graphs<br>
</b></p><i>Answer: a<br>
Explanation: Strand sort is most efficient when data is stored in a linked list as it involves many insertions and deletions which is performed quite efficiently with the help of a linked list. Using an array would increase time complexity significantly.</i><p><b>3. In which of the following case strand sort is most efficient?<br>
a) when input array is already sorted<br>
b) when input array is reverse sorted<br>
c) when input array is large<br>
d) when input array is has randomly spread elements<br>
</b></p><i>Answer: a<br>
Explanation: The best case of strand sort occurs when the input array is already sorted. In this case, it has linear time complexity.</i><p><b>4. What is the auxiliary space complexity of strand sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: The auxiliary space complexity of strand sort is O(n). It is because a sub-list of size n has to be maintained.</i><p><b>5. Which of the following sorting algorithm is not in place?<br>
a) quick sort<br>
b) strand sort<br>
c) cycle sort<br>
d) heap sort<br>
</b></p><i>Answer: b<br>
Explanation: Strand sort has an auxiliary space complexity of O(n). So it is not an in place sorting algorithm.</i><p><b>8. What is the average time complexity of strand sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: a<br>
Explanation: Pigeonhole sort is an example of a comparison based sorting algorithm. This is because it compares the value of elements present in a list in order to sort them.</i><p><b>9. What is the best case time complexity of strand sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: a<br>
Explanation: Strand sort is an example of a stable sorting algorithm. It is because the elements with identical values appear in the same order in the output array as they were in the input array. </i><p><b>10. What is the worst case time complexity of strand sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: c<br>
Explanation: Average case time complexity of strand sort is O(n2). So it is not as efficient as quick sort or merge sort.</i><p><b>11. Strand sort algorithm used which of the following method for sorting a list?<br>
a) merging<br>
b) selection<br>
c) insertion<br>
d) partitioning<br>
</b></p><i>Answer: a<br>
Explanation: Best case time complexity of strand sort is O(n). It occurs in the case where the input array is already sorted.</i><p><b>12. Which of the following is an adaptive sorting algorithm?<br>
a) heap sort<br>
b) strand sort<br>
c) selection sort<br>
d) merge sort<br>
</b></p><i>Answer: c<br>
Explanation: Worst case time complexity of strand sort is O(n<sup>2</sup>). It occurs in the case where the input array is in reverse sorted order.</i><p><b>1. Cocktail sort is also known as ________________<br>
a) bidirectional sort<br>
b) bubble sort<br>
c) brick sort<br>
d) ripple sort<br>
</b></p><i>Answer: d<br>
Explanation: Cocktail sort is also known by the name of ripple sort. It is also known by other names like – bidirectional bubble sort, cocktail shaker sort, shuttle sort, shuffle sort etc.</i><p><b>2. Cocktail sort is a variation of _____________<br>
a) Bubble sort<br>
b) Selection sort<br>
c) Insertion sort<br>
d) Gnome sort<br>
</b></p><i>Answer: a<br>
Explanation: Cocktail sort is very similar to bubble sort. It works by traversing an array in both directions alternatively. It compares the adjacent elements in each iteration and swaps the ones which are out of order.</i><p><b>3. Auxiliary space requirement of cocktail sort is _____________<br>
a) O(n)<br>
b) O(log n)<br>
c) O(1)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: In cocktail sort manipulation is done on the input array itself. So no extra space is required to perform sorting. Thus it requires constant auxiliary space.</i><p><b>4. Which of the following sorting algorithm is NOT stable?<br>
a) Quick sort<br>
b) Cocktail sort<br>
c) Bubble sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options quick sort is the only algorithm which is not stable. Cocktail sort like bubble sort is a stable sorting algorithm.</i><p><b>5. Which of the following sorting algorithm is in place?<br>
a) cocktail sort<br>
b) merge sort<br>
c) counting sort<br>
d) radix sort<br>
</b></p><i>Answer: a<br>
Explanation: Cocktail sort is an in place sorting technique as it only requires constant auxiliary space for manipulating the input array. Rest all other options are not in place.</i><p><b>7. Cocktail sort uses which of the following methods for sorting the input?<br>
a) selection<br>
b) partitioning<br>
c) merging<br>
d) exchanging<br>
</b></p><i>Answer: a<br>
Explanation: Cocktail sort compares the value of different elements in the array for sorting. Thus, it is a comparison based sort.</i><p><b>8. What is the worst case time complexity of cocktail sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: d<br>
Explanation: Cocktail sort uses a method of exchanging as it swaps the elements which are out of order. This swapping is done in two phases i.e. forward phase and backward phase.</i><p><b>9. What is the best case time complexity of cocktail sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: Worst case complexity is observed when the input array is reverse sorted. This is the same as the worst case complexity of bubble sort.</i><p><b>10. What is the average case time complexity of odd-even sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Best case complexity is observed when the input array is already sorted. This is the same as the best case complexity of bubble sort.</i><p><b>11. How many iterations are required to sort the array arr={2,3,4,5,1} using bubble sort and cocktail sort respectively?<br>
a) 4,2<br>
b) 5,3<br>
c) 5,2<br>
d) 4,3<br>
</b></p><i>Answer: c<br>
Explanation: Cocktail sort takes O(n<sup>2</sup>) time on average as it keeps on applying bubble sort on the elements in two phases until they are sorted. This is the same as the average time complexity of bubble sort.</i><p><b>12. The following function represents which sorting?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Sorting<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	bool swap <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
	<span class="kw4">int</span> first <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw4">int</span> last <span class="sy0">=</span> n <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">while</span> <span class="br0">(</span>swap<span class="br0">)</span> 
        <span class="br0">{</span> 
&nbsp;
		swap <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> first<span class="sy0">;</span> i <span class="sy0">&lt;</span> last<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
                <span class="br0">{</span> 
			<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
                        <span class="br0">{</span> 
				swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
				swap <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
			<span class="br0">}</span> 
		<span class="br0">}</span> 
&nbsp;
		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>swap<span class="br0">)</span> 
			<span class="kw2">break</span><span class="sy0">;</span> 
&nbsp;
		swap <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
&nbsp;
		<span class="sy0">--</span>last<span class="sy0">;</span> 
&nbsp;
&nbsp;
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> last <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&gt;=</span> first<span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
                <span class="br0">{</span> 
			<span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
                        <span class="br0">{</span> 
				swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
				swap <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
			<span class="br0">}</span> 
		<span class="br0">}</span> 
&nbsp;
		<span class="sy0">++</span>first<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Bubble sort<br>
b) Selection sort<br>
c) Bidirectional bubble sort<br>
d) Odd-even sort<br>
</b></p><i>Answer: a<br>
Explanation: Cocktail sort applies bubble sort in two phases until the array gets sorted. So here bubble sort will take 4 iterations to sort the given array whereas cocktail sort takes only 2 iterations. This shows cocktail sort has a comparatively better performance.</i><p><b>1. Comb sort is an improved version of _______<br>
a) Selection sort<br>
b) Bubble sort<br>
c) Insertion sort<br>
d) Merge sort<br>
</b></p><i>Answer: b<br>
Explanation: Comb sort compares two elements at a variable gap from each other in each iteration unlike bubble sort where the gap remains 1. This reduces the average time complexity of comb sort.</i><p><b>2. The gap between two elements being compared shrinks by a factor of _______ after every iteration.<br>
a) 1.1<br>
b) 1.2<br>
c) 1.3<br>
d) 1.4<br>
</b></p><i>Answer: c<br>
Explanation:  It has been found experimentally that the gap between the two elements should shrink by a factor of 1.3 after each iteration for the most efficient sorting.</i><p><b>3. The initial gap between two elements being compared _______<br>
a) is equal to number of elements in the array<br>
b) is equal to 1.3<br>
c) depends on the number of iterations<br>
d) depends on the compiler being used<br>
</b></p><i>Answer: a<br>
Explanation: Initial gap is taken to be equal to the number of elements in the array and shrinks by a factor of 1.3 in each iteration, initial gap is independent of the number of iterations and compiler being used.</i><p><b>4. What is the worst case time complexity of comb sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n log n)<br>
c) O(n)<br>
d) O(n<sup>2</sup>/2<sup>a</sup>) (a=number of increment)<br>
</b></p><i>Answer: a<br>
Explanation: Worst case complexity is observed when the input array is reverse sorted. This is same as the worst case complexity of bubble sort.</i><p><b>5. The gap value after 3 iterations in an array with 6 elements will be _______<br>
a) 4<br>
b) 3<br>
c) 2<br>
d) 1<br>
</b></p><i>Answer: c<br>
Explanation: Initially the gap value will be 6. For the first iteration, it will be 6/1.3=4 then 4/1.3=3 for second iteration and 3/1.3=2 for the third iteration.</i><p><b>6. Auxiliary space used by comb sort is _______<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Auxiliary space used by comb sort is O(1) as it does not use any extra space for manipulating the input.</i><p><b>7. The given array is arr={7,4,5,8,1,2}. The number of iterations required to sort the array using comb sort and bubble sort respectively will be _______<br>
a) 7 and 8<br>
b) 5 and 6<br>
c) 5 and 5<br>
d) 4 and 5<br>
</b></p><i>Answer: d<br>
Explanation: Comb sort takes 1 iteration less as compared to bubble sort as it makes use of variable gap value whereas bubble sort uses a constant gap value of 1.</i><p><b>9. What is the best case time complexity of comb sort and bubble sort respectively?<br>
a) O(n<sup>2</sup>) and O(n log n)<br>
b) O(n log n) and O(n)<br>
c) O(n) and O(n<sup>2</sup>)<br>
d) O(n<sup>2</sup>/2<sup>a</sup>) (a=number of increment) and O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Comb sort is not a stable sorting algorithm as it does not sort the repeated elements in the same order as they appear in the input.</i><p><b>10. What is the advantage of comb sort over merge sort?<br>
a) Comb sort is an in place sorting algorithm<br>
b) Comb sort is a stable sorting algorithm<br>
c) Comb sort is more efficient<br>
d) It has no advantage<br>
</b></p><i>Answer: b<br>
Explanation: Best case complexity for comb sort and bubble sort is O(n log n) and O(n) respectively. It occurs when the input array is already sorted.</i><p><b>1. Gnome sort is also called __________<br>
a) Smart sort<br>
b) Stupid sort<br>
c) Bogo sort<br>
d) Special sort<br>
</b></p><i>Answer: b<br>
Explanation: Gnome sort was originally named as stupid sort but later on it got renamed as gnome sort.</i><p><b>2. How many loops are required to implement gnome sorting algorithm?<br>
a) Single loop<br>
b) 2 nested loops<br>
c) 3 nested loops<br>
d) It does not require any loop<br>
</b></p><i>Answer: a<br>
Explanation:  In this sorting algorithm the variable representing the index number is not incremented in case the adjacent pair of elements are out of place. In such a case its value is decremented instead. Thus it is able to implement sorting using a single loop.</i><p><b>3. Which of the following pair of sorting algorithms are stable?<br>
a) gnome sort and quick sort<br>
b) merge sort and selection sort<br>
c) gnome sort and merge sort<br>
d) heap sort and merge sort<br>
</b></p><i>Answer: c<br>
Explanation: Gnome sort and merge sort are stable sorting algorithms as the elements with identical values appear in the same order in the output array as they were in the input array when any of these sorting algorithms are implemented.</i><p><b>4. Auxiliary space used by gnome sort is _________<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation:  Auxiliary space used by gnome sort is O(1) as it does not use any extra space for manipulating the input. Thus it also qualifies as an in place sorting algorithm.</i><p><b>5.  The given array is arr = {1,2,4,3,5}.The number of iterations required to sort the array using gnome sort will be _________<br>
a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: 6 iterations will be required as one pair of elements i.e. {4,3} is out of place which causes the loop to take one step backward.</i><p><b>6. Gnome sort uses which of the following method to implement sorting?<br>
a) Merging<br>
b) Partitioning<br>
c) Selection<br>
d) Exchanging<br>
</b></p><i>Answer: d<br>
Explanation: Gnome sort implements sorting by exchanging the adjacent elements which are out of order. Thus its method of sorting is called exchanging.</i><p><b>7. What is the best case time complexity of gnome sort?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: When the input array is already sorted then in that case there will be no need to decrease the value of the index variable at any stage. So only O(n) time is required in this case as we keep on increasing its value after each iteration.</i><p><b>8. Select the appropriate code that performs gnome sort.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">&gt;</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">else</span> 
        <span class="br0">{</span> 
            swap<span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
            index<span class="sy0">--;</span> 
        <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">&lt;</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">&lt;=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">else</span> 
        <span class="br0">{</span> 
            swap<span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
            index<span class="sy0">--;</span> 
        <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">&lt;</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">&gt;=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">else</span> 
        <span class="br0">{</span> 
            swap<span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
            index<span class="sy0">--;</span> 
        <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">while</span> <span class="br0">(</span>index <span class="sy0">&lt;</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
            Index<span class="sy0">--;</span> 
        <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">&gt;=</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            index<span class="sy0">++;</span> 
        <span class="kw1">else</span> 
        <span class="br0">{</span> 
            swap<span class="br0">(</span>arr<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>index <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
            Index<span class="sy0">++;</span> 
        <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The first if statement increments the value of index if found to be 0 so that comparison can take place for this element. Second if statement checks whether the adjacent pair of elements are in order or not. If found out of order they are swapped under the else statement and index is decremented. </i><p><b>9. What is the worst case time complexity of gnome sort?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Worst case occurs when the input array is reverse sorted as it will have the maximum number of decrements while sorting. This causes the algorithm to have a time complexity of O(n<sup>2</sup>) in this case.</i><p><b>10. What is the average case time complexity of gnome sort?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: In gnome sort the loop has to take one step backwards every time any adjacent pair of elements is out of place which causes it to have time complexity of O(n<sup>2</sup>) on an average.</i><p><b>1. Which of the following is not an alternative name of bogosort?<br>
a) stupid sort<br>
b) permutation sort<br>
c) donkey sort<br>
d) monkey sort<br>
</b></p><i>Answer: c<br>
Explanation: Bogosort is also known by names like stupid sort, monkey sort, permutation sort, slow sort and shotgun sort.These names are particularly chosen due to its inefficient algorithm. </i><p><b>2. Bogosort works by __________<br>
a) generating random permutations of its input<br>
b) partitioning the array<br>
c) dividing the value of input elements<br>
d) generating permutations according to the value of first element of array<br>
</b></p><i>Answer: a<br>
Explanation: Bogosort algorithm successively generates permutations of its input. This process is repeated until the sorted version of the array is found.</i><p><b>3. What is the auxiliary space requirement of bogosort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Bogosort algorithm do not require any extra space for sorting the input array. Thus its auxiliary space requirement is O(1).</i><p><b>4. What is the best case time complexity of bogosort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(1)<br>
</b></p><i>Answer: b<br>
Explanation: Best case time complexity of bogosort occurs when the input array is already sorted. So in such a case we only need to check whether all the elements are sorted which can be done in O(n) time. </i><p><b>5. What is the worst case time complexity of bogosort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n*n!)<br>
c) O(infinity)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: There is no upper bound to the worst case of this algorithm. It can go on to take very large amount of time if the array has many elements. So the worst case of this algorithm can be taken as O(infinity).</i><p><b>6. Which of the following sorting algorithm is not stable __________<br>
a) insertion sort<br>
b) bubble sort<br>
c) merge sort<br>
d) bogosort<br>
</b></p><i>Answer: d<br>
Explanation: Out of the given algorithms only bogosort is not stable. This is because it creates permutations of the input array in order to obtain the sorted version. So there is no guarantee that the sorted version obtained by such a method gives a stable output.    </i><p><b>7. Which of the following is an in-place sorting algorithm?<br>
a) Merge sort<br>
b) Bogosort<br>
c) Radix sort<br>
d) Counting sort<br>
</b></p><i>Answer: b<br>
Explanation: Out of the given algorithms only bogosort is an in-place sorting algorithm. It is because bogosort algorithm do not require any extra space for sorting the input array. </i><p><b>9. What is the average case time complexity of bogosort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n*n!)<br>
c) O(infinity)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: If we sort an array using sleep sort then there is no guarantee that the output we get is correctly sorted. So even though sleep sort is better than bogosort in time complexity but it cannot be preferred due to its inaccuracy.</i><p><b>10. Which of the following code correctly implements bogosort algorithm?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
    <span class="kw1">while</span> <span class="br0">(</span> isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: For calculating the average we first need to calculate the number of possible permutations an array of size n can have. This will be equal to n!. As each permutation also needs to be checked whether it is sorted or not so this takes another n time. Thus overall time complexity becomes O(n*n!).</i><p><b>1. Which of the following header file is a must to implement sleep sort algorithm?<br>
a) string.h<br>
b) math.hw<br>
c) bios.h<br>
d) windows.h<br>
</b></p><i>Answer: d<br>
Explanation: To implement sleep sort algorithm we need functions like WaitForMultipleObjects(), _beginthread(). These are included in the header file windows.h.</i><p><b>2. Sleep sort does not work for ___________<br>
a) negative numbers<br>
b) large numbers<br>
c) small numbers<br>
d) positive numbers<br>
</b></p><i>Answer: a<br>
Explanation: Sleep sort algorithm does not work for negative numbers. It is because thread cannot sleep for negative amount of time.</i><p><b>3. In how many comparisons does the array arr={1,4,2,3,5} gets sorted if we use sleep sort?<br>
a) 5<br>
b) 3<br>
c) 1<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: Sleep sort makes different elements of the array to sleep for an amount of time that is proportional to its magnitude. So it does not require to perform any comparison in order to sort the array.</i><p><b>4. Sleep sort works by ___________<br>
a) making elements to sleep for a time that is proportional to their magnitude<br>
b) making elements to sleep for a time that is inversely proportional to their magnitude<br>
c) partitioning the input array<br>
d) dividing the value of input elements<br>
</b></p><i>Answer: a<br>
Explanation: In sleep sort each element is made to sleep for a time that is proportional to its magnitude. Then the elements are printed in the order in which they wake up.</i><p><b>5. Sleep sort code cannot compile online because ___________<br>
a) it has very high time complexity<br>
b) it has very high space complexity<br>
c) it requires multithreading process<br>
d) online compilers are not efficient<br>
</b></p><i>Answer: c<br>
Explanation: Sleep sort requires multithreading process for making the elements to sleep. This process happens in the background at the core of the OS and so cannot be compiled on an online compiler.</i><p><b>6. Time complexity of sleep sort can be approximated to be ___________<br>
a) O(n + max(input))<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n + max(input))<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: As the sleep() function creates multiple threads by using priority queue which takes n log n time for insertion. Also the output is obtained when all the elements wake up. This time is proportional to the max(input). So its time complexity is approximately O(n log n + max(input)).  </i><p><b>7. Sleep sort can be preferred over which of the following sorting algorithms for large number of input elements?<br>
a) Quick sort<br>
b) Bubble sort<br>
c) Selection sort<br>
d) No sorting algorithm is preferred<br>
</b></p><i>Answer: d<br>
Explanation: Sleep sort is not preferred over any of the given sorting algorithms as sleep sort does not guarantee a correct output every time. So sleep sort is not a reliable sorting technique.</i><p><b>8. Auxiliary space requirement of sleep sort is ___________<br>
a) O(n)<br>
b) O(1)<br>
c) O(max(input))<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: All the major processes involved in sleep sort takes place internally in the OS. So it does not require any auxiliary space to sort the elements.</i><p><b>9. Sleep sort does gives a correct output when ___________<br>
a) any input element is negative<br>
b) input array is reverse sorted<br>
c) any input element is positive<br>
d) when there is a very small number to the left of very large number<br>
</b></p><i>Answer: c<br>
Explanation: Sleep sort gives a sorted output when the array elements are positive. But when any other case than this occur out of the above given cases then we may not see a correct output. This makes sleep sort very unreliable sorting technique.</i><p><b>10. Which of the following sorting algorithm is most closely related to the OS?<br>
a) gnome sort<br>
b) sleep sort<br>
c) radix sort<br>
d) bogo sort<br>
</b></p><i>Answer: b<br>
Explanation: Sleep sort is most closely related to the operating system. It is because most of the major steps of this algorithm takes place at the core of OS.</i><p><b>1. How many comparisons will be made to sort the array arr={1,5,3,8,2} using pigeonhole sort?<br>
a) 5<br>
b) 7<br>
c) 9<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: As pigeonhole sort is an example of a non-comparison sort so it is able to sort an array without making any comparison. So 0 comparisons are required.</i><p><b>2. Which of the following is a non-comparison sort?<br>
a) heap sort<br>
b) quick sort<br>
c) merge sort<br>
d) pigeonhole sort<br>
</b></p><i>Answer: d<br>
Explanation: Heap sort, merge sort and quick sort are examples of comparison sort as it needs to compare array elements in order to sort an array. Whereas pigeonhole sort is a non-comparison based sort.</i><p><b>3. In which of the following case pigeonhole sort is most efficient?<br>
a) when range of input is less than number of elements<br>
b) when range of input is more than number of elements<br>
c) when range of input is comparable to the number of elements<br>
d) when the given array is almost sorted<br>
</b></p><i>Answer: c<br>
Explanation: Pigeonhole sort is a non-comparison based sort. It is most efficient in the case where the number of elements are comparable to the input range.</i><p><b>4. What is the space complexity of pigeonhole sort (k=range of input)?<br>
a) O(n*k)<br>
b) O(n)<br>
c) O(k)<br>
d) O(n+k)<br>
</b></p><i>Answer: d<br>
Explanation: Pigeonhole sort algorithm requires two arrays. The first one is required to store the input elements so its size is n. The second one is the pigeonhole array and has a size equal to range k. Overall space complexity becomes O(n+k).</i><p><b>5. The auxiliary array used in pigeonhole sorting is called ______________<br>
a) bucket<br>
b) pigeon<br>
c) hole<br>
d) pigeonhole<br>
</b></p><i>Answer: d<br>
Explanation: The auxiliary array used in pigeonhole sorting is called pigeonhole. It is used to store every element in its corresponding hole.</i><p><b>8. What is the average time complexity of pigeonhole sort (k=range of input)?<br>
a) O(n)<br>
b) O(n+k)<br>
c) O(n<sup>2</sup>)<br>
d) O(n*k)<br>
</b></p><i>Answer: a<br>
Explanation: Pigeonhole sort is an example of a stable sorting algorithm. It is because the elements with identical values appear in the same order in the output array as they were in the input array. </i><p><b>9. The complexity of which of the following sorting algorithms remains to be the same in its best, average and worst case?<br>
a) quick sort<br>
b) insertion sort<br>
c) pigeonhole sort<br>
d) bubble sort<br>
</b></p><i>Answer: b<br>
Explanation: Pigeonhole sort requires space of O(n+k). So it does not qualify to be an in place sorting algorithm.</i><p><b>10. Choose the correct statement from the following.<br>
a) pigeonhole sort is a comparison based sort<br>
b) any comparison based sorting can be made stable<br>
c) quick sort is not a comparison based sort<br>
d) any comparison based sort requires at least O(n<sup>2</sup>) time<br>
</b></p><i>Answer: b<br>
Explanation: Time complexity of pigeonhole sort is O(n+k). It has two loops. One of the loops runs from 0 to range(k) and the other one runs from 0 to n so the time complexity becomes O(n+k).</i><p><b>11. What is the advantage of pigeonhole sort over merge sort?<br>
a) pigeonhole sort has lesser time complexity when range is comparable to number of input elements<br>
b) pigeonhole sort has lesser space complexity<br>
c) counting sort is not a comparison based sorting technique<br>
d) pigeonhole sort is adaptive<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of pigeonhole remains unvaried in all three cases. It is given by O(n+k). But it is efficient only when the number of elements is comparable to the input range.</i><p><b>12. Which of the following function represents pigeonhole sort correctly?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Sorting<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw4">int</span> minimum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> maximum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> minimum<span class="br0">)</span> 
			minimum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> maximum<span class="br0">)</span> 
			maximum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> maximum <span class="sy0">-</span> minimum <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> p_holes<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		p_holes<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span>minimum<span class="br0">]</span>.<span class="me1">push_back</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> ind <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;::</span><span class="me2">iterator</span> it<span class="sy0">;</span> 
	    <span class="kw1">for</span> <span class="br0">(</span>it <span class="sy0">=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> it <span class="sy0">!=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>it<span class="br0">)</span> 
			arr<span class="br0">[</span>ind<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="sy0">*</span>it<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Sorting<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw4">int</span> minimum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> maximum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> minimum<span class="br0">)</span> 
			minimum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> maximum<span class="br0">)</span> 
			maximum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> maximum <span class="sy0">-</span> minimum <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> p_holes<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		p_holes<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span>minimum<span class="br0">]</span>.<span class="me1">push_back</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> ind <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;::</span><span class="me2">iterator</span> it<span class="sy0">;</span> 
	    <span class="kw1">for</span> <span class="br0">(</span>it <span class="sy0">=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> it <span class="sy0">!=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>it<span class="br0">)</span> 
			arr<span class="br0">[</span>ind<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="sy0">*</span>it<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Sorting<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw4">int</span> minimum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> maximum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> minimum<span class="br0">)</span> 
			minimum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> maximum<span class="br0">)</span> 
			maximum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> maximum <span class="sy0">-</span> minimum <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> p_holes<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		p_holes<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span>minimum<span class="br0">]</span>.<span class="me1">push_back</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> ind <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;::</span><span class="me2">iterator</span> it<span class="sy0">;</span> 
	    <span class="kw1">for</span> <span class="br0">(</span>it <span class="sy0">=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> it <span class="sy0">!=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>it<span class="br0">)</span> 
			arr<span class="br0">[</span>ind<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="sy0">*</span>it<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Sorting<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw4">int</span> minimum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> maximum <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> minimum<span class="br0">)</span> 
			minimum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> maximum<span class="br0">)</span> 
			maximum <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> maximum <span class="sy0">-</span> minimum <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> p_holes<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		p_holes<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span>minimum<span class="br0">]</span>.<span class="me1">push_back</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> ind <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    vector<span class="sy0">&lt;</span>int<span class="sy0">&gt;::</span><span class="me2">iterator</span> it<span class="sy0">;</span> 
	    <span class="kw1">for</span> <span class="br0">(</span>it <span class="sy0">=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> it <span class="sy0">!=</span> p_holes<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>it<span class="br0">)</span> 
			arr<span class="br0">[</span>ind<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="sy0">*</span>it<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Any comparison based sorting technique can be made stable by considering the position as criteria while making comparisons. Pigeonhole sort is a stable sort.</i><p><b>13. Which of the following algorithm takes linear time for sorting?<br>
a) pigeonhole sort<br>
b) heap sort<br>
c) comb sort<br>
d) cycle sort<br>
</b></p><i>Answer: a<br>
Explanation: Pigeonhole sort is efficient in the cases where the range is comparable to a number of input elements as it performs sorting in linear time. Whereas merge sort takes O(n log n) in any case.</i><p><b>1. Which of the following is the distribution sort?<br>
a) Heap sort<br>
b) Smooth sort<br>
c) Quick sort<br>
d) LSD radix sort<br>
</b></p><i>Answer: d<br>
Explanation: In Distribution sort the inputted values are distributed to multiple intermediate structures which are then combined and placed on the output. And LSD radix sort distributes values into buckets based on the digits within values, so it is a distribution sort.</i><p><b>2. What is the worst case time complexity of LSD radix sort?<br>
a) O(nlogn)<br>
b) O(wn)<br>
c) O(n)<br>
d) O(n + w)<br>
</b></p><i>Answer: b<br>
Explanation: Time complexity of LSD radix sort depends upon the word size and the number on items. It runs in O(wn) time in worst case, where n is the number of inputted elements and w is the number of digits in the largest number.</i><p><b>3. LSD radix sort requires _____ passes to sort N elements.<br>
a) (w/logR)<br>
b) N(w/logR)<br>
c) (w/log(RN))<br>
d) (wN/log(N))<br>
</b></p><i>Answer: a<br>
Explanation: LSD radix sort sorts the N elements in  (w/logR) passes where w is the number of digits in largest number and R(radix) is extra space required for performing the sorting operation.</i><p><b>4. Which of the following is false?<br>
a) LSD radix sort is an integer sorting algorithm<br>
b) LSD radix sort is a comparison sorting algorithm<br>
c) LSD radix sort is a distribution sort<br>
d) LSD radix sort uses bucket sort<br>
</b></p><i>Answer: b<br>
Explanation: LSD radix sort uses bucket sort for grouping the keys based on the digits at that value. And as it grouped the keys based on the digits at that values, it is integer sorting algorithm.</i><p><b>5. Which of the following sorting algorithm is stable?<br>
a) Heap sort<br>
b) Selection sort<br>
c) In-place MSD radix sort<br>
d) LSD radix sort<br>
</b></p><i>Answer: d<br>
Explanation: In LSD radix sort after sorting the multiple elements with the same key will be in the same order as they were in the input array. So LSD radix sort is stable sort.</i><p><b>7. Which of the following should be used to sort a huge database on a fixed-length key field?<br>
a) Insertion sort<br>
b) Merge sort<br>
c) LSD radix sort<br>
d) Quick sort<br>
</b></p><i>Answer: b<br>
Explanation: LSD radix sort is faster than comparison sorts when the word size is less than logn. But LSD radix sort runs slowly for elements with larger word size and smaller radix.</i><p><b>8. Which of the following is a combination of LSD and MSD radix sorts?<br>
a) Forward radix sort<br>
b) 3-way radix quick sort<br>
c) Trie base radix sort<br>
d) Flash sort<br>
</b></p><i>Answer: c<br>
Explanation: LSD radix requires only w passes to sort a fixed-length string, where w is a length of the strings. So, LSD radix sort is best suited to sort a huge database on a fixed-length key field.</i><p><b>9. Which of the following is true for the LSD radix sort?<br>
a) works best for variable length strings<br>
b) accesses memory randomly<br>
c) inner loop has less instructions<br>
d) sorts the keys in left-to-right order<br>
</b></p><i>Answer: a<br>
Explanation: Forward radix sort combines the advantages of LSD and MSD radix sort. Forward radix sort inspects a complete horizontal strip at a time just like LSD radix sort.</i><p><b>1. How many comparisons will be made to sort the array arr = {1, 5, 3, 8, 2} using MSD radix sort?<br>
a) 5<br>
b) 7<br>
c) 9<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: As MSD radix sort is an example of non comparison sort so it is able to sort an array without making any comparison. So the answer should be 0.</i><p><b>2. What is the full form of MSD in MSD radix sort?<br>
a) most significant digit<br>
b) many significant digit<br>
c) more significant digit<br>
d) must significant digit<br>
</b></p><i>Answer: a<br>
Explanation: MSD stands for Most Significant Digit. It is named so because in this algorithm the processing begins from the most significant digit.</i><p><b>3. Which of the following combines qualities of MSD radix sort and LSD radix sort?<br>
a) in-place MSD radix sort<br>
b) stable MSD radix sot<br>
c) 3 way radix quick sort<br>
d) forward radix sort<br>
</b></p><i>Answer: d<br>
Explanation: Forward radix sort combines the qualities of MSD and LSD radix sort. The sorting is done by separating the strings into groups.</i><p><b>4. Which of the following is the most suitable definition of radix sort?<br>
a) It is a non comparison based integer sort<br>
b) It is a comparison based integer sort<br>
c) It is a non comparison based non integer sort<br>
d) It is a comparison based non integer sort<br>
</b></p><i>Answer: a<br>
Explanation: Radix sort is a non-comparison based integer sort. It sorts the given data by grouping keys which share the same significant position value.</i><p><b>5. Which of the following is an alternate name of MSD radix sort?<br>
a) bottom up radix sort<br>
b) top down radix sort<br>
c) forward radix sort<br>
d) backward radix sort<br>
</b></p><i>Answer: b<br>
Explanation: Top down radix sort is an alternate name of MSD radix sort. It is because in this algorithm the processing starts from the most significant digit and end at least significant digit. </i><p><b>6. Which of the following is not true about MSD radix sort?<br>
a) its processing starts from the most significant digit<br>
b) it is not a stable sort<br>
c) it is an in place sorting algorithm<br>
d) it is non comparison based sort<br>
</b></p><i>Answer: c<br>
Explanation: MSD radix sort takes non constant time for sorting the input data. So it is not an in place sorting algorithm. </i><p><b>8. What is the average time complexity of MSD radix sort (w= bits required to store each key)?<br>
a) O(n + w)<br>
b) O(n.w)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: MSD radix sort is not a stable sort whereas LSD radix sort is stable. So when we require to preserve the original order then in that case we should prefer LSD radix sort.</i><p><b>10. Which of the following statement is not a stable sorting algorithm?<br>
a) LSD radix sort<br>
b) MSD radix sort<br>
c) Counting sort<br>
d) Pigeonhole sort<br>
</b></p><i>Answer: b<br>
Explanation: Time complexity of radix sort is O(n.w). It performs better than quick sort when we have log n bits for every digit.</i><p><b>11. Which of the following is not true about radix sort?<br>
a) Radix sort performs better than quick sort when we have log n bits for every digit<br>
b) Radix sort has better cache performance than quick sort<br>
c) Radix sort has higher values of constant factor in asymptotic notation<br>
d) Radix sort takes more space than quick sort<br>
</b></p><i>Answer: b<br>
Explanation: MSD radix sort takes non constant time for sorting the input data. So it is not an in place sorting algorithm. </i><p><b>12. What is the advantage of radix sort over quick sort?<br>
a) radix sort performs better than quick sort when we have log n bits for every digit<br>
b) radix sort has lesser space complexity<br>
c) radix sort is not a comparison based sorting technique<br>
d) radix sort has better cache performance than quick sort<br>
</b></p><i>Answer: b<br>
Explanation: MSD radix sort is not a stable sort. It is because the elements with identical values do not appear in the same order in the output array as they were in the input array.</i><p><b>13. What will be the order of elements of the array arr = {23, 67, 143, 654, 43} after first iteration of MSD sort is complete?<br>
a) 23, 43, 67, 143, 654<br>
b) 23, 67, 43, 143, 654<br>
c) 23, 67, 143, 654, 43<br>
d) 23, 143, 43, 654, 67<br>
</b></p><i>Answer: b<br>
Explanation: Quick sort has a better cache performance than radix sort. Radix sort also takes more space as compared to quick sort.</i><p><b>1. How many comparisons will be made to sort the array arr={1,5,3,8,2} using counting sort?<br>
a) 5<br>
b) 7<br>
c) 9<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: As counting sort is an example of non comparison sort so it is able to sort an array without making any comparison. </i><p><b>2. Which of the following is not an example of non comparison sort?<br>
a) bubble sort<br>
b) counting sort<br>
c) radix sort<br>
d) bucket sort<br>
</b></p><i>Answer: a<br>
Explanation: Bubble sort is not an example of non comparison sort as it needs to compare array elements in order to sort an array.</i><p><b>3. Which of the following sorting techniques is most efficient if the range of input data is not significantly greater than a number of elements to be sorted?<br>
a) selection sort<br>
b) bubble sort<br>
c) counting sort<br>
d) insertion sort<br>
</b></p><i>Answer: c<br>
Explanation: Time complexity of counting sort is given as O(n+k) where n is the number of input elements and k is the range of input. So if range of input is not significantly larger than number of elements in the array then it proves to be very efficient.</i><p><b>4. What is the auxiliary space requirement of counting sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n+k) k=range of input<br>
</b></p><i>Answer: d<br>
Explanation: Counting sort uses two extra arrays to get the input array sorted. First array is required to store the count of all the elements which fall in the range of input data elements, so its size is k. The second array is required to store the input elements in sorted manner, so its size is n. Thus overall auxiliary space required becomes O(n+k).</i><p><b>6. Which of the following sorting techniques is stable?<br>
a) quick sort<br>
b) counting sort<br>
c) heap sort<br>
d) selection sort<br>
</b></p><i>Answer: b<br>
Explanation: It is possible to extend the counting sort algorithm for negative numbers as well. In such a case we store the minimum element at the 0th index.</i><p><b>7. Which of the following uses the largest amount of auxiliary space for sorting?<br>
a) Bubble sort<br>
b) Counting sort<br>
c) Quick sort<br>
d) Heap sort<br>
</b></p><i>Answer: b<br>
Explanation: Counting sort is an example of stable sorting algorithm as the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>8. What is the average time complexity of counting sort?<br>
a) O(n)<br>
b) O(n+k) k=range of input<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Counting sort requires auxiliary space of O(n+k) whereas quick sort, bubble sort and heap sort are in place sorting techniques. Thus counting sort requires most auxiliary space.</i><p><b>9. The complexity of which of the following sorting algorithms remains to be the same in its best, average and worst case?<br>
a) quick sort<br>
b) insertion sort<br>
c) counting sort<br>
d) gnome sort<br>
</b></p><i>Answer: b<br>
Explanation: Time complexity of counting sort is O(n+k) as counting the occurrence of each element in the input range takes k time and then finding the correct index value of each element in the sorted array takes n time.</i><p><b>10. Which of the following statement is true about comparison based sorting?<br>
a) counting sort is a comparison based sort<br>
b) any comparison based sorting can be made stable<br>
c) bubble sort is not a comparison based sort<br>
d) any comparison based sort requires at least O(n<sup>2</sup>) time<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of counting sort remains unvaried in all the three cases. It is given by O(n+k).</i><p><b>12. What is the advantage of counting sort over quick sort?<br>
a) counting sort has lesser time complexity when range is comparable to number of input elements<br>
b) counting sort has lesser space complexity<br>
c) counting sort is not a comparison based sorting technique<br>
d) it has no advantage<br>
</b></p><i>Answer: b<br>
Explanation: Any comparison based sorting technique can be made stable by considering a position as criteria while making comparisons.</i><p><b>13. which of the following represents the algorithm of counting sort correctly?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">  <span class="kw2">function</span> countingSort<span class="br0">(</span>array<span class="sy0">,</span> k<span class="br0">)</span> is
  count ← new array of k zeros
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span> to length<span class="br0">(</span>array<span class="br0">)</span> <span class="kw1">do</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">2</span> to k <span class="kw1">do</span>
    count<span class="br0">[</span>i<span class="br0">]</span> ← count<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> count<span class="br0">[</span>i <span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> length<span class="br0">(</span>array<span class="br0">)</span> downto <span class="nu0">1</span> <span class="kw1">do</span>
    output<span class="br0">[</span>count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="br0">]</span> ← array<span class="br0">[</span>i<span class="br0">]</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span>
  <span class="kw1">return</span> output</pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">  <span class="kw2">function</span> countingSort<span class="br0">(</span>array<span class="sy0">,</span> k<span class="br0">)</span> is
  count ← new array of k zeros
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span> to length<span class="br0">(</span>array<span class="br0">)</span> <span class="kw1">do</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">2</span> to k <span class="kw1">do</span>
    count<span class="br0">[</span>i<span class="br0">]</span> ← count<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> count<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> length<span class="br0">(</span>array<span class="br0">)</span> downto <span class="nu0">1</span> <span class="kw1">do</span>
    output<span class="br0">[</span>count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="br0">]</span> ← array<span class="br0">[</span>i<span class="br0">]</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span>
  <span class="kw1">return</span> output</pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">  <span class="kw2">function</span> countingSort<span class="br0">(</span>array<span class="sy0">,</span> k<span class="br0">)</span> is
  count ← new array of k zeros
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span> to length<span class="br0">(</span>array<span class="br0">)</span> <span class="kw1">do</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span> to k <span class="kw1">do</span>
    count<span class="br0">[</span>i<span class="br0">]</span> ← count<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> count<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> length<span class="br0">(</span>array<span class="br0">)</span> downto <span class="nu0">1</span> <span class="kw1">do</span>
    output<span class="br0">[</span>count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="br0">]</span> ← array<span class="br0">[</span>i<span class="br0">]</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span>
  <span class="kw1">return</span> output</pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">  <span class="kw2">function</span> countingSort<span class="br0">(</span>array<span class="sy0">,</span> k<span class="br0">)</span> is
  count ← new array of k zeros
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">1</span> to length<span class="br0">(</span>array<span class="br0">)</span> <span class="kw1">do</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">2</span> to k <span class="kw1">do</span>
    count<span class="br0">[</span>i<span class="br0">]</span> ← count<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> count<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span>
  <span class="kw1">for</span> i <span class="sy0">=</span> length<span class="br0">(</span>array<span class="br0">)</span> downto <span class="nu0">1</span> <span class="kw1">do</span>
    output<span class="br0">[</span>count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="br0">]</span> ← array<span class="br0">[</span>i<span class="br0">]</span>
    count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> ← count<span class="br0">[</span>array<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">1</span>
  <span class="kw1">return</span> output</pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Counting sort is used as a sub routine for radix sort as it is a stable and non comparison based sorting algorithm.</i><p><b>14. What is the disadvantage of counting sort?<br>
a) counting sort has large time complexity<br>
b) counting sort has large space complexity<br>
c) counting sort is not a comparison based sorting technique<br>
d) counting sort cannot be used for array with non integer elements<br>
</b></p><i>Answer: a<br>
Explanation: Counting sort is very efficient in the cases where range is comparable to number of input elements as it performs sorting in linear time.</i><p><b>15. Which of the following algorithm takes non linear time for sorting?<br>
a) counting sort<br>
b) quick sort<br>
c) bucket sort<br>
d) radix sort<br>
</b></p><i>Answer: b<br>
Explanation: The first loop counts the number of occurrences of each element. Second loop performs prefix sum on count to determine position range where items having that key should be placed in. The third loop places each element at its correct position.</i><p><b>1. How many comparisons will be made to sort the array arr={1, 5, 3, 8, 2} using bucket sort?<br>
a) 5<br>
b) 7<br>
c) 9<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: As bucket sort is an example of a non-comparison sort so it is able to sort an array without making any comparison. So the answer should be 0.</i><p><b>2. What is the alternate name of bucket sort?<br>
a) group sort<br>
b) radix sort<br>
c) bin sort<br>
d) uniform sort<br>
</b></p><i>Answer: c<br>
Explanation: Bucket sort is also known as bin sort. It is an example of a non-comparison sort.</i><p><b>3. Which of the following non-comparison sort can also be considered as a comparison based sort?<br>
a) counting sort<br>
b) MSD radix sot<br>
c) bucket sort<br>
d) pigeonhole sort<br>
</b></p><i>Answer: c<br>
Explanation: Bucket sort can also be considered as a comparison based sort. It is because it can also be implemented with comparisons.</i><p><b>4. Which of the following is not true about bucket sort?<br>
a) It is a non comparison based integer sort<br>
b) It is a distribution sort<br>
c) It can also be considered as comparison based sort<br>
d) It is in place sorting algorithm<br>
</b></p><i>Answer: d<br>
Explanation: Bucket sort is a non comparison based integer sort. It sorts the given data by distributing the array elements into a number of buckets. It is not an in place sorting technique.</i><p><b>5. Which of the following don’t affect the time complexity of bucket sort?<br>
a) algorithm implemented for sorting individual buckets<br>
b) number of buckets used<br>
c) distribution of input<br>
d) input values<br>
</b></p><i>Answer: d<br>
Explanation: Time complexity of bucket sort is affected by various factors. These include algorithm implemented for sorting individual buckets, number of buckets used and distribution of input. It doesnot depend on the input value. It can be either positive or negative or zero.</i><p><b>6. Bucket sort is most efficient in the case when __________<br>
a) the input is non uniformly distributed<br>
b) the input is uniformly distributed<br>
c) the input is randomly distributed<br>
d) the input range is large<br>
</b></p><i>Answer: b<br>
Explanation: Bucket sort works by distributing the array elements into a number of buckets. So bucket sort is most efficient in the case when the input is uniformly distributed.</i><p><b>7. Bucket sort is a generalization of which of the following sort?<br>
a) LSD radix sort<br>
b) Pigeonhole sort<br>
c) Counting sort<br>
d) MSD radix sort<br>
</b></p><i>Answer: b<br>
Explanation: Pigeonhole sort is a particular case of bucket sort. Bucket sort is also closely related to MSD radix sort.</i><p><b>8. What is the worst case time complexity of bucket sort (k = number of buckets)?<br>
a) O(n + k)<br>
b) O(n.k)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: Time complexity of bucket sort is O(n<sup>2</sup>) in the worst case. So if bucket sort does not get the inputs in the desired manner then it becomes very inefficient. </i><p><b>9. What is the best time complexity of bucket sort (k= number of buckets)?<br>
a) O(n + k)<br>
b) O(n.k)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Time complexity of bucket sort is O(n+k). It performs better than any comparison based sort if there is a uniform input distribution.</i><p><b>10. Which of the following is not necessarily a stable sorting algorithm?<br>
a) bucket sort<br>
b) counting sort<br>
c) merge sort<br>
d) pigeonhole sort<br>
</b></p><i>Answer: a<br>
Explanation: Bucket sort is not necessarily a stable sorting algorithm. This is because its stability depends on the stability of the algorithm that we have used to sort the individual buckets.</i><p><b>12. What is the worst space complexity of bucket sort (k = number of buckets)?<br>
a) O(n + k)<br>
b) O(n.k)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Bucket sort is not an in place sorting algorithm. It requires an auxiliary space of O(n k) in the worst case.</i><p><b>1. Bead sort is also known as _________<br>
a) gravity sort<br>
b) strand sort<br>
c) abacus sort<br>
d) counting sort<br>
</b></p><i>Answer: a<br>
Explanation: Bead sort is also known as gravity sort. It is because this algorithm was designed by keeping the natural phenomenon of falling objects in mind.</i><p><b>2. Which of the following sorting algorithm was inspired by the natural phenomenon of falling objects?<br>
a) bogo sort<br>
b) heap sort<br>
c) bead sort<br>
d) strand sort<br>
</b></p><i>Answer: c<br>
Explanation: The algorithm of bead sort was inspired by the natural phenomenon of falling objects. Thus, it is also known by the name of gravity sort.</i><p><b>3. Which of the following sorting algorithm is only applicable to positive integers?<br>
a) quick sort<br>
b) heap sort<br>
c) bead sort<br>
d) strand sort<br>
</b></p><i>Answer: c<br>
Explanation: Bead sort algorithm is only applicable to positive integers. This is because it works by placing number of beads equal to key value, in each row.</i><p><b>4. What is the auxiliary space complexity of bead sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: The auxiliary space complexity of bead sort is O(n<sup>2</sup>). It is because an array of size maximum_element*n (maximum_element is the maximum element that is present in the array and n is the size of the array) has to be maintained.</i><p><b>5. Which of the following sorting algorithm is not in place?<br>
a) quick sort<br>
b) bead sort<br>
c) cycle sort<br>
d) heap sort<br>
</b></p><i>Answer: b<br>
Explanation: Bead sort has an auxiliary space complexity of O(n2). So it is not an in place sorting algorithm.</i><p><b>7. How many comparisons will be required to sort the array arr={5, 4, 7, 1, 9} using bead sort?<br>
a) 5<br>
b) 4<br>
c) 6<br>
d) 0<br>
</b></p><i>Answer: b<br>
Explanation: Bead sort is an example of non comparison based sorting algorithm. This is because it does not compare the value of elements present in a list in order to sort them.</i><p><b>8. What is the average time complexity of bead sort (S = sum of input elements)?<br>
a) O(n)<br>
b) O(S)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: d<br>
Explanation: Bead sort is an example of a non-comparison based sorting algorithm. So no comparison is required to be performed in order to sort the array.</i><p><b>9. What is the best case time complexity of bead sort (S = sum of input elements)?<br>
a) O(n)<br>
b) O(S)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Average case time complexity of bead sort is O(S). It is because we drop each bead as a separate operation.</i><p><b>10. What is the worst case time complexity of bead sort (S= sum of input elements)?<br>
a) O(n)<br>
b) O(S)<br>
c) O(n<sup>2</sup>)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Best case time complexity of bead sort is O(n). It is when a row of beads is dropped as a distinct operation and since the number of rows is equal to n.</i><p><b>11. Which of the following code fragment puts sorted values in an array using beads correctly?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
<span class="br0">{</span> 
         <span class="kw4">int</span> j<span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> max<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="co1">//max is the maximum value element of given array a[]  </span>
        a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> j<span class="sy0">;</span> 
i<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
<span class="br0">{</span> 
         <span class="kw4">int</span> j<span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> max <span class="sy0">&amp;&amp;</span> beads<span class="br0">[</span>i <span class="sy0">*</span> max <span class="sy0">+</span> j<span class="br0">]</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="co1">//max is the maximum value element of given array a[]</span>
        a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> j<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
<span class="br0">{</span> 
         <span class="kw4">int</span> j<span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> beads<span class="br0">[</span>i <span class="sy0">*</span> max <span class="sy0">+</span> j<span class="br0">]</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span> 
       <span class="co1">//max is the maximum value element of given array a[]  </span>
        a<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
<span class="br0">{</span> 
         <span class="kw4">int</span> j<span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> max <span class="sy0">&amp;&amp;</span> beads<span class="br0">[</span>i <span class="sy0">*</span> max <span class="sy0">+</span> j<span class="br0">]</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span> 
       <span class="co1">//max is the maximum value element of given array a[]  </span>
        a<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Worst case time complexity of bead sort is O(S). It is because we drop each bead as a separate operation.</i><p><b>1. What is the time complexity for a given pancake sort given it undergoes “n” flip operations?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(2n)<br>
</b></p><i>Answer: b<br>
Explanation: Most sorting algorithms try to sort making the least number of comparisons but in pancake sort we try to sort using as few reversals as possible. Because the total number of flip operations performed in a pancake sort is O(n), the overall time complexity is O(n<sup>2</sup>).</i><p><b>2. Which operation is most essential to the process of pancake sort?<br>
a) Flip the given data<br>
b) Find the largest of given data<br>
c) Finding the least of given data<br>
d) Inserting something into the given data<br>
</b></p><i>Answer: a<br>
Explanation: When we use pancake sort, we sort the array to find the largest, and then flip the array at that point to bring that value to the bottom of the pancake stack. The size of the array that we are dealing with is then reduced and the process continues. Flip operation is the most important function in the pancake sort technique.</i><p><b>3. There is one small error in the following flip routine. Find out which line it is on.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">	<span class="nu0">1</span>	<span class="kw4">void</span> flip<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> i<span class="br0">)</span>
	<span class="nu0">2</span>	<span class="br0">{</span>
	<span class="nu0">3</span>	      <span class="kw4">int</span> t, init <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	<span class="nu0">4</span>	      <span class="kw1">while</span> <span class="br0">(</span>init <span class="sy0">&lt;</span> i<span class="br0">)</span>
	<span class="nu0">5</span>	      <span class="br0">{</span>
	<span class="nu0">6</span>		    t <span class="sy0">=</span> arr<span class="br0">[</span>init<span class="br0">]</span><span class="sy0">;</span>
	<span class="nu0">7</span>		    arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>init<span class="br0">]</span> <span class="sy0">;</span>
	<span class="nu0">8</span>		    arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> t<span class="sy0">;</span>
	<span class="nu0">9</span>		    init<span class="sy0">++;</span>
	<span class="nu0">10</span>		    i<span class="sy0">--;</span>
	<span class="nu0">11</span>	      <span class="br0">}</span>
	<span class="nu0">12</span>	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Line 3<br>
b) Line 5<br>
c) Line 7<br>
d) Line 9<br>
</b></p><i>Answer: c<br>
Explanation: After initialization of the array titled arr; for each while loop iteration of increasing init, we should make arr[init]=arr[i]. This makes sure that the changes will be made in order to flip the order of the array that was to be flipped. Here in line 7 it has been written in reverse and is incorrect. </i><p><b>4. How many flips does the simplest of pancake sorting techniques require?<br>
a) 3n−3 flips<br>
b) 2n-4 flips<br>
c) 2n-3 flips<br>
d) 3n-2 flips<br>
</b></p><i>Answer: c<br>
Explanation: The minimum number of flips required to sort any stack of n pancakes has been shown to lie between 1.087n and 1.636n. using average of that 1.36n and extracting that for values of n&gt;1. We have 1.36, 2.72, 4.08 etc. This matches best with 2n-3 which is equal to 1, 3, 5, 7, 9, etc. An upper bound of 2n-3 comes by iteratively using the next largest element in its correct place using two flips. </i><p><b>5. Pancake Sorting appears in which of the following?<br>
a) Frequency Scaling<br>
b) Storage Virtualization<br>
c) Parallel Processing<br>
d) Neural Networking<br>
</b></p><i>Answer: c<br>
Explanation: Pancake Sorting finds application in educational use not to mention parallel processing networks by providing optimal routing algorithms between networks. </i><p><b>6. In addition to the pancake sorting problem, there is the case of the burnt pancake problem in which we are dealing with pancakes (discs) that are burnt on one side only. In this case it is taken that the burnt side must always end up _______<br>
a) Faced down<br>
b) Faced up<br>
c) It doesn’t matter<br>
d) Both sides are burnt<br>
</b></p><i>Answer: a<br>
Explanation: A varation of this pancake is with burnt pancakes. Here each pancake has a burnt side and all pancakes must, in addition, end up with the burnt side on bottom. It is a more difficult version of the regular pancake problem.</i><p><b>7. In a computational complexity theory, a problem with decision making is said to be NP-complete when it is both in NP and NP-hard. What does NP mean?<br>
a) Non Polynomial time<br>
b) Non-deterministic Probabilistic<br>
c) Non-deterministic Polynomial time<br>
d) Non Probabilistic time<br>
</b></p><i>Answer: c<br>
Explanation: Although any given solution to an NP-complete problem can be validated quickly in polynomial time; there is no way to efficiently locate a solution to begin with. The unique characteristic of NP-complete problems is that no fast solution to them is known and hence NP-complete problems are said to be non-deterministic polynomial time.</i><p><b>8. When we realize a specific implementation of a pancake algorithm, every move when we find the greatest of the sized array and flipping can be modeled through __________<br>
a) Combinations<br>
b) Exponential functions<br>
c) Logarithmic functions<br>
d) Permutations<br>
</b></p><i>Answer: d<br>
Explanation: Here when we flipping the array or stack, we have to take utmost priority to preserve the order of the list so that that sorting doesnt become invalid. Hence we use permutations, we are ensuring that order matters. </i><p><b>9. The Pancake Problems (1975, 1979, 1973) did NOT involve which of the following people?<br>
a) Bill Gates<br>
b) Jacob Goodman<br>
c) Christos Papadimitriou<br>
d) John Goodman<br>
</b></p><i>Answer: d<br>
Explanation: (Jacob Goodman – 1975) What is the maximum number of flips needed to sort a permutation of [n] into ascending order?<br>
(Bill Gates and Christos Papadimitriou – 1979) What is the maximum number of flips needed to sort a signed permutation of [n] into ascending order with all positive signs? </i><p><b>10. There is a one line error in the following routine. Find that line.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="java"><pre class="de1">		<span class="nu0">1</span>.	<span class="kw4">int</span> Max<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span>, <span class="kw4">int</span> n<span class="br0">)</span>
		<span class="nu0">2</span>.	<span class="br0">{</span>
		<span class="nu0">3</span>.		  <span class="kw4">int</span> mi, i<span class="sy0">;</span>
		<span class="nu0">4</span>.		  <span class="kw1">for</span> <span class="br0">(</span>mi <span class="sy0">=</span> <span class="nu0">0</span>, i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
		<span class="nu0">5</span>.		  <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>mi<span class="br0">]</span><span class="br0">)</span>
		<span class="nu0">6</span>.		  <span class="me1">mi</span> <span class="sy0">=</span> i<span class="sy0">;</span>
		<span class="nu0">7</span>.		  <span class="kw1">return</span> mi<span class="sy0">;</span>
		<span class="nu0">8</span>.	<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Line 2<br>
b) Line 4<br>
c) Line 6<br>
d) Line 5<br>
</b></p><i>Answer: b<br>
Explanation: The increment condition in the for loop declaration is incorrect. We should use ++i instead of i++.</i><p><b>1. Odd-even sort is also known as ____________<br>
a) stupid sort<br>
b) smart sort<br>
c) brick sort<br>
d) bogo sort<br>
</b></p><i>Answer: c<br>
Explanation: Odd-even sort is also known by the name of a brick sort. This algorithm was first proposed by Habermann in 1972 and was initially invented for parallel computation of local interconnection.</i><p><b>2. Odd-even sort is a variation of ___________<br>
a) Bubble sort<br>
b) Selection sort<br>
c) Insertion sort<br>
d) Gnome sort<br>
</b></p><i>Answer: a<br>
Explanation: Odd-even sort is very similar to bubble sort. It works by applying bubble sort in two phases I.e odd phase and even phase. In odd phase bubble sort is applied on odd indexed elements and in even phase bubble sort is applied on even indexed elements.</i><p><b>3. Auxiliary space requirement of odd-even sort is ___________<br>
a) O(n)<br>
b) O(log n)<br>
c) O(1)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: In odd-even sort manipulation is done on the input array itself. So no extra space is required to perform sorting. Thus it requires constant auxiliary space.</i><p><b>4. Which of the following sorting algorithm is NOT stable?<br>
a) Quick sort<br>
b) Brick sort<br>
c) Bubble sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options quick sort is the only algorithm which is not stable. Brick sort like bubble sort is a stable sorting algorithm.</i><p><b>5. Which of the following sorting algorithm is in place?<br>
a) brick sort<br>
b) merge sort<br>
C) counting sort<br>
D) radix sort<br>
</b></p><i>Answer: a<br>
Explanation: Brick sort is an in place sorting technique as it only requires constant auxiliary space for manipulating the input array.</i><p><b>7. Brick sort uses which of the following methods for sorting the input?<br>
a) selection<br>
b) partitioning<br>
c) merging<br>
d) exchanging<br>
</b></p><i>Answer: a<br>
Explanation: Odd-even sort compares the value of different elements in the array for sorting. Thus, it is a comparison based sort.</i><p><b>8. What is the worst case time complexity of odd-even sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: d<br>
Explanation: Brick sort uses the method of exchanging as it swaps the elements which are out of order. This swapping is done in two phases i.e. odd phase and even phase.</i><p><b>9. What is the best case time complexity of odd-even sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: Worst case complexity is observed when the input array is reverse sorted. This is the same as the worst case complexity of bubble sort.</i><p><b>10. What is the average case time complexity of odd-even sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Best case complexity is observed when the input array is already sorted. This is the same as the best case complexity of bubble sort.</i><p><b>11. How many odd and even phases are required respectively to sort the given array using odd-even sort.arr={3,2,3,8,5,6,2,1}.<br>
a) 3,3<br>
b) 4,4<br>
c) 3,4<br>
d) 4,3<br>
</b></p><i>Answer: c<br>
Explanation: Odd-even sort takes O(n<sup>2</sup>) time on average as it keeps on applying bubble sort on the elements in two phases until they are sorted.</i><p><b>12. Which of the following function correctly represents odd-even sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> oddEvenSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
	bool Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
        <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>Sorted<span class="br0">)</span>
	<span class="br0">{</span>
		Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> oddEvenSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
	bool Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
        <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>Sorted<span class="br0">)</span>
	<span class="br0">{</span>
		Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> oddEvenSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
	bool Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
        <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>Sorted<span class="br0">)</span>
	<span class="br0">{</span>
		Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">2</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> oddEvenSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
	bool Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
        <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>Sorted<span class="br0">)</span>
	<span class="br0">{</span>
		Sorted <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span>
	        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">=</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
			<span class="br0">{</span>
				swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
				Sorted <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
	<span class="kw1">return</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Odd-even sort applies bubble sort in two phases until the array gets sorted. So here 8 phases will be required in totality to sort the array. Out of these 4 phases will be odd phase and the other 4 will be even phase.</i><p><b>1. Which one of the following sorting algorithm requires recursion?<br>
a) odd even sort<br>
b) stooge sort<br>
c) selection sort<br>
d) counting sort<br>
</b></p><i>Answer: b<br>
Explanation: Stooge sort requires the use of recursion for implementing its algorithm. On the other hand, the sorting algorithms given in the remaining options use iterative methods.</i><p><b>2. What is the recurrence relation for stooge sort?<br>
a) T(n) = 2T(2/3n) + O(n)<br>
b) T(n) = 2T(2/3n) + O(1)<br>
c) T(n) = 3T(2/3n) + O(n)<br>
d) T(n) = 3T(2/3n) + O(1)<br>
</b></p><i>Answer: d<br>
Explanation: In stooge sort recursion is applied to 2/3 part of the array 3 times. Rest of the portion of code has a constant time complexity. So the overall recurrence relation becomes T(n) = 3T(2/3n) + O(1).</i><p><b>3. In which of the following case stooge sort is most efficient (in terms of time complexity)?<br>
a) when input array is already sorted<br>
b) when input array is reverse sorted<br>
c) when input array is large<br>
d) it has the same time complexity in any case<br>
</b></p><i>Answer: d<br>
Explanation: Stooge sort has the same time complexity under any case. It is given by the recurrence relation T(n) = 3T(2/3n) + O(1).</i><p><b>4. What is the space complexity of stooge sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: The space complexity of the stooge sort is O(n). It is used to store the input array.</i><p><b>5. What is the first step in the algorithm of stooge sort(after base case)?<br>
a) apply stooge sort on first 2/3 elements of array<br>
b) apply stooge sort on last 2/3 elements of array<br>
c) apply stooge sort on first 1/3 elements of array<br>
d) compare first and last element of the array<br>
</b></p><i>Answer: d<br>
Explanation: The first step in the algorithm of stooge sort is to compare the first and last element of the array and switch them if found out of order. In the second step stooge sort is applied on the first 2/3 elements of the array.</i><p><b>8. What is the average time complexity of stooge sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n<sup>3</sup>)<br>
c) O(n<sup>2.6</sup>)<br>
d) O(n<sup>2.7</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Stooge sort is an example of a comparison based sorting algorithm. This is because it compares the value of elements present in a list in order to sort them.</i><p><b>9. How many recursive statements are used in the algorithm of stooge sort?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: Stooge sort is not a stable sorting algorithm. It is because the elements with identical values do not appear in the same order in the output array as they were in the input array. </i><p><b>10. Which of the following sorting algorithm has the same time complexity in every case?<br>
a) stooge sort<br>
b) strand sort<br>
c) quick sort<br>
d) bubble sort<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation of stooge sort is given as T(n) = 3T(2/3n) + O(1). It is found to be equal to O(n<sup>2.7</sup>) using the master’s theorem.</i><p><b>11. Which of the following sorting algorithm is worst in terms of time complexity?<br>
a) bubble sort<br>
b) selection sort<br>
c) insertion sort<br>
d) stooge sort<br>
</b></p><i>Answer: d<br>
Explanation: The algorithm of stooge sort uses 3 recursive statements in its algorithm. The first and third recursive statement applies stooge sort to the first 2/3 elements of the array and the second recursive statement applies stooge sort to last 2/3 elements of the array.</i><p><b>12. Which of the following is not an adaptive sorting algorithm?<br>
a) insertion sort<br>
b) strand sort<br>
c) stooge sort<br>
d) bubble sort<br>
</b></p><i>Answer: a<br>
Explanation: Stooge sort has the same time complexity of O(n<sup>2.7</sup>) in any case. This also shows that it is not an adaptive sorting algorithm.</i><p><b>13. Choose the correct function for stooge sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> stooge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">&gt;=</span> r<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>r<span class="br0">]</span><span class="br0">)</span> 
		swap<span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>h<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&gt;</span> <span class="sy0">=</span><span class="nu0">3</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> p <span class="sy0">=</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">3</span><span class="sy0">;</span> 	
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 		
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l <span class="sy0">+</span> p<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 		
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> stooge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">&gt;=</span> r<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>r<span class="br0">]</span><span class="br0">)</span> 
		swap<span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>h<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&gt;=</span><span class="nu0">3</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> p <span class="sy0">=</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">3</span><span class="sy0">;</span> 	
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 		
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l <span class="sy0">+</span> p<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 		
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> stooge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">&gt;=</span> r<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>r<span class="br0">]</span><span class="br0">)</span> 
		swap<span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>h<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&gt;</span> <span class="sy0">=</span><span class="nu0">3</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> p <span class="sy0">=</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">3</span><span class="sy0">;</span> 	
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
                stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l <span class="sy0">+</span> p<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> stooge_sort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">&gt;=</span> r<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>r<span class="br0">]</span><span class="br0">)</span> 
		swap<span class="br0">(</span>arr<span class="br0">[</span>l<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>h<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&gt;=</span><span class="nu0">3</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		<span class="kw4">int</span> p <span class="sy0">=</span> <span class="br0">(</span>r <span class="sy0">-</span> l <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">3</span><span class="sy0">;</span> 
&nbsp;
	       stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l <span class="sy0">+</span> p<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
		stooge_sort<span class="br0">(</span>arr<span class="sy0">,</span> l<span class="sy0">,</span> r <span class="sy0">-</span> p<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: Stooge sort has a time complexity of O(n<sup>2.7</sup>) which is the worst out of the given options. This shows that stooge sort is even less efficient than bubble sort which is itself considered to be a very inefficient sort.</i><p><b>1. Which of the following is not an alternative name of permutation sort?<br>
a) stupid sort<br>
b) bogo sort<br>
c) donkey sort<br>
d) monkey sort<br>
</b></p><i>Answer: c<br>
Explanation: Permutation sort is also known by names like stupid sort, monkey sort, bogo sort, slow sort and shotgun sort. These names are particularly chosen due to its inefficient algorithm. </i><p><b>2. Permutation sort works by __________<br>
a) generating random permutations of its input<br>
b) partitioning the array<br>
c) dividing the value of input elements<br>
d) generating permutations according to the value of first element of array<br>
</b></p><i>Answer: a<br>
Explanation: Permutation sort algorithm successively generates permutations of its input. This process is repeated until the sorted version of the array is found.</i><p><b>3. What is the auxiliary space requirement of permutation sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Permutation sort algorithm does not require any extra space for sorting the input array. Thus its auxiliary space requirement is O(1).</i><p><b>4. What is the best case time complexity of permutation sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(1)<br>
</b></p><i>Answer: b<br>
Explanation: Best case time complexity of permutation sort occurs when the input array is already sorted. So in such a case we only need to check whether all the elements are sorted which can be done in O(n) time. </i><p><b>5. What is the worst case time complexity of permutation sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n*n!)<br>
c) O(infinity)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: There is no upper bound to the worst case of this algorithm. It can go on to take a very large amount of time if the array has many elements. So the worst case of this algorithm can be taken as O(infinity).</i><p><b>6. Which of the following sorting algorithm is not stable __________<br>
a) insertion sort<br>
b) bubble sort<br>
c) merge sort<br>
d) bogosort<br>
</b></p><i>Answer: d<br>
Explanation: Out of the given algorithms only bogosort is not stable. This is because it creates permutations of the input array in order to obtain the sorted version. So there is no guarantee that the sorted version obtained by such a method gives a stable output.    </i><p><b>7. Which of the following is an in-place sorting algorithm?<br>
a) Merge sort<br>
b) Permutation sort<br>
c) Radix sort<br>
d) Counting sort<br>
</b></p><i>Answer: b<br>
Explanation: Out of the given algorithms only permutation sort is an in-place sorting algorithm. It is because the permutation sort algorithm does not require any extra space for sorting the input array. </i><p><b>9. What is the average case time complexity of permutation sort?<br>
a) O(n<sup>2</sup>)<br>
b) O(n*n!)<br>
c) O(infinity)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: If we sort an array using sleep sort then there is no guarantee that the output we get is correctly sorted. So even though sleep sort is better than bogosort in time complexity but it cannot be preferred due to its inaccuracy.</i><p><b>10. Which of the following code correctly implements the permutation sort algorithm?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>   
&nbsp;
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">!</span>isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool isSorted<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> <span class="sy0">--</span>n <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="br0">)</span> 
        <span class="kw1">if</span> <span class="br0">(</span>a<span class="br0">[</span>n<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
            <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">void</span> shuffle<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        swap<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">void</span> bogosort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">while</span> <span class="br0">(</span> isSorted<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span> <span class="br0">)</span> 
        shuffle<span class="br0">(</span>a<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: For calculating the average we first need to calculate the number of possible permutations an array of size n can have. This will be equal to n!. As each permutation also needs to be checked whether it is sorted or not so this takes another n time. Thus overall time complexity becomes O(n*n!).</i><p><b>1. Which of the following is an advantage of recursive bubble sort over its iterative version?<br>
a) it has better time complexity<br>
b) it has better space complexity<br>
c) it is easy to implement<br>
d) it has no significant advantage<br>
</b></p><i>Answer: d<br>
Explanation: Recursive bubble sort has no significant advantage over iterative bubble sort. It is just a different way to implement the same.</i><p><b>2. Bubble sort is also known as ___________<br>
a) stupid sort<br>
b) ship sort<br>
c) sinking sort<br>
d) shell sort<br>
</b></p><i>Answer: c<br>
Explanation: Bubble sort is also referred to as sinking sort. It continuously compares the value of adjacent elements as it traverses through an array and swaps the elements which are out of order.</i><p><b>3. What will be the recurrence relation of the code of recursive bubble sort?<br>
a) T(n) = 2T(n/2) + n<br>
b) T(n) = 2T(n/2) + c<br>
c) T(n) = T(n-1) + n<br>
d) T(n) = T(n-1) + c<br>
</b></p><i>Answer: c<br>
Explanation: The recurrence relation of the code of recursive bubble sort is T(n) = T(n-1) + n. It can be solved by the method of substitution and is found to be equal to n<sup>2</sup>.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Selection sort<br>
b) Quick sort<br>
c) Bubble sort<br>
d) Heap sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options bubble sort is the only algorithm which is stable. It is because the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>5. Which of the following is a variation of bubble sort?<br>
a) selection sort<br>
b) odd even sort<br>
c) cocktail sort<br>
d) stupid sort<br>
</b></p><i>Answer: b<br>
Explanation: Odd even sort is a variation of bubble sort. But unlike bubble sort, odd even sort traverses the array in two phases- odd phase and even phase.</i><p><b>7. What is the average case time complexity of recursive bubble sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In bubble sort, we need to compare elements in order to find the minimum element in each iteration. So we can say that it uses comparisons in order to sort the array. Thus it qualifies as a comparison based sort.</i><p><b>8. What is the best case time complexity of recursive bubble sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: The overall recurrence relation of recursive bubble sort is given by T(n) = T(n-1) + n. It is found to be equal to O(n<sup>2</sup>).</i><p><b>9. What is the worst case time complexity of recursive bubble sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: The best case time complexity of recursive bubble sort is O(n). It occurs in the case when the input is already/almost sorted.</i><p><b>10. What are the number of swaps required to sort the array arr={1, 2, 4, 3, 7, 5, 6} using recursive bubble sort?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The overall recurrence relation of recursive bubble sort is given by T(n) = T(n-1) + n. It is found to be equal to O(n<sup>2</sup>).</i><p><b>11. What will be the base case for the code of recursive bubble sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">&lt;</span> <span class="nu0">1</span><span class="br0">)</span>
<span class="kw1">return</span><span class="sy0">;</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="kw1">return</span><span class="sy0">;</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
<span class="kw1">return</span><span class="sy0">;</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">If<span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
<span class="kw1">return</span><span class="sy0">;</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The first swap takes place between 4 and 3 then the second swap takes place between 7 and 5 and then finally 6 and 7 are swapped which sorts our array.</i><p><b>12. What is the auxiliary space complexity of recursive bubble sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The most appropriate condition for the base case of recursive bubble sort is when n equal 1 then return. It is because we know that an array with only 1 element is always sorted.</i><p><b>14. Which of the following sorting algorithm is in place?<br>
a) recursive bubble sort<br>
b) merge sort<br>
c) radix sort<br>
d) counting sort<br>
</b></p><i>Answer: b<br>
Explanation: The auxiliary space required by recursive bubble sort is O(1). So it qualifies as an in-place sorting algorithm.</i><p><b>15. Choose the correct function for recursive bubble sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> rec_bubbleSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
			swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="br0">}</span>
	rec_bubbleSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> rec_bubbleSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
			swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="br0">}</span>
	rec_bubbleSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> rec_bubbleSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
			swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="br0">}</span>
&nbsp;
	rec_bubbleSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> rec_bubbleSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
			swap<span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        <span class="br0">}</span>
&nbsp;
	rec_bubbleSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Bubble sort is an adaptive algorithm. It is because the time complexity of the algorithm improves when the input array is almost sorted.</i><p><b>1. Which of the following is an advantage of binary insertion sort over its standard version?<br>
a) it has better time complexity<br>
b) it has better space complexity<br>
c) it makes less number of comparisons<br>
d) it has no significant advantage<br>
</b></p><i>Answer: c<br>
Explanation: Binary insertion sort makes less number of comparisons as compared to the standard version of insertion sort. Binary insertion sort makes log n comparisons in the worst case as compared to n comparisons made in the standard version.</i><p><b>3. How many comparisons will be made in the worst case when an array of size n will be sorted by using a binary insertion sort algorithm?<br>
a) n<br>
b) 1<br>
c) log n<br>
d) n log n<br>
</b></p><i>Answer: a<br>
Explanation: Binary Insertion sort does not require the entire input data at the beginning itself in order to sort the array. It rather creates a partial solution in every step, so future elements are not required to be considered. Hence it is an online sorting algorithm.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Selection sort<br>
b) Quick sort<br>
c) Binary insertion sort<br>
d) Heap sort<br>
</b></p><i>Answer: c<br>
Explanation: Binary insertion sort makes log n comparisons in the worst case. Whereas the standard version makes n comparisons in the worst case.</i><p><b>5. Which of the following sorting algorithm uses a binary search?<br>
a) radix sort<br>
b) binary insertion sort<br>
c) odd-even sort<br>
d) bead sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options binary insertion sort is the only algorithm which is stable. It is because the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>7. What is the average case time complexity of binary insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Binary insertion sort makes use of a binary search algorithm. It is used to find the correct index in the array where the element should be inserted.</i><p><b>8. What is the best case time complexity of binary insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In insertion sort, we need to compare elements in order to find the minimum element in each iteration. So we can say that it uses comparisons in order to sort the array. Thus it qualifies as a comparison based sort.</i><p><b>9. What is the worst case time complexity of binary insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity does not change when we use binary insertion sort in place of standard insertion sort. So the average case time complexity is O(n<sup>2</sup>).</i><p><b>10. Choose the correct statement regarding binary insertion sort?<br>
a) It has a better time complexity as compared to the standard version<br>
b) It has a better space complexity as compared to the standard version<br>
c) it takes less number of comparisons in the best case as compared to the standard version<br>
d) it takes less number of comparisons in the worst case as compared to the standard version<br>
</b></p><i>Answer: a<br>
Explanation: The best case time complexity of binary insertion sort is O(n). It occurs in the case when the input is already/almost sorted.</i><p><b>11. What will be the base case in the function of binary search used in the code of binary insertion sort? (high and low are the rightmost and leftmost index of array respectively and item is the element whose correct position is to be determined by the binary search function)<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">If<span class="br0">(</span>high<span class="sy0">&lt;=</span>low<span class="br0">)</span> 
<span class="br0">{</span> 
    If<span class="br0">(</span>Item<span class="sy0">&gt;</span>a<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span>
    <span class="kw1">return</span> low<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">return</span> low<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">If<span class="br0">(</span>high<span class="sy0">&gt;=</span>low<span class="br0">)</span>
<span class="br0">{</span>
    If<span class="br0">(</span>Item<span class="sy0">&lt;</span>a<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span>
    <span class="kw1">return</span> low<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">return</span> low<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">If<span class="br0">(</span>high<span class="sy0">&lt;=</span>low<span class="br0">)</span>
<span class="br0">{</span>
    If<span class="br0">(</span>Item<span class="sy0">&lt;</span>a<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span>
    <span class="kw1">return</span> low<span class="sy0">;</span>
    <span class="kw1">return</span> low<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">If<span class="br0">(</span>high<span class="sy0">&lt;=</span>low<span class="br0">)</span>
<span class="br0">{</span>  
    If<span class="br0">(</span>Item<span class="sy0">&gt;</span>a<span class="br0">[</span>low<span class="br0">]</span><span class="br0">)</span>
    <span class="kw1">return</span> low<span class="sy0">;</span>
    <span class="kw1">return</span> low<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The time complexity does not change when we use binary insertion sort in place of standard insertion sort. So the worst case time complexity is O(n<sup>2</sup>).</i><p><b>12. What is the auxiliary space complexity of binary insertion sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: Binary insertion sort has the advantage that it takes less number of comparisons in the worst case as compared to the standard version. In the best case, both standard insertion sort and binary insertion sort makes only 1 comparison.</i><p><b>13. Which of the following is an adaptive sorting algorithm?<br>
a) binary insertion sort<br>
b) merge sort<br>
c) heap sort<br>
d) selection sort<br>
</b></p><i>Answer: c<br>
Explanation: The base case of binary search has to be made such that even when the element is not found in the array the function still returns the required index back to the function of insertion sort.</i><p><b>14. Which of the following sorting algorithm is in place?<br>
a) binary insertion sort<br>
b) merge sort<br>
c) radix sort<br>
d) counting sort<br>
</b></p><i>Answer: b<br>
Explanation: The auxiliary space required by a binary insertion sort is O(1). So it qualifies as an in place sorting algorithm.</i><p><b>15. Choose the correct function for binary insertion sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> BinaryinsertionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> key<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw4">int</span> j <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
        key <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
       <span class="co1">//function binarySearch() returns the index</span>
        <span class="kw4">int</span> index <span class="sy0">=</span> binarySearch<span class="br0">(</span>a<span class="sy0">,</span> key<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span>  
       <span class="co1">//where the key should be inserted        </span>
        <span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> index<span class="br0">)</span> 
        <span class="br0">{</span> 
            a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> a<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
            j<span class="sy0">--;</span> 
        <span class="br0">}</span> 
        a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> BinaryinsertionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> key<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="sy0">=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw4">int</span> j <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
        key <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
        <span class="co1">//function binarySearch() returns the index</span>
        <span class="kw4">int</span> index <span class="sy0">=</span> binarySearch<span class="br0">(</span>a<span class="sy0">,</span> key<span class="sy0">,</span> j<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>  
        <span class="co1">//where the key should be inserted</span>
        <span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> index<span class="br0">)</span> 
        <span class="br0">{</span> 
            a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> a<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
            J<span class="sy0">++;</span> 
        <span class="br0">}</span> 
        a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> BinaryinsertionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> key<span class="sy0">;</span>   
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw4">int</span> j <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
        key <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
        <span class="co1">//function binarySearch() returns the index</span>
        <span class="kw4">int</span> index <span class="sy0">=</span> binarySearch<span class="br0">(</span>a<span class="sy0">,</span> key<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span>  
        <span class="co1">//where the key should be inserted        </span>
        <span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&lt;=</span> index<span class="br0">)</span> 
        <span class="br0">{</span> 
            a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> a<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
            j<span class="sy0">--;</span> 
        <span class="br0">}</span> 
        a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> BinaryinsertionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> key<span class="sy0">;</span> 
&nbsp;
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw4">int</span> j <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
        key <span class="sy0">=</span> a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
        <span class="co1">//function binarySearch() returns the index</span>
        <span class="kw4">int</span> index <span class="sy0">=</span> binarySearch<span class="br0">(</span>a<span class="sy0">,</span> key<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span> 
        <span class="co1">//where the key should be inserted        </span>
        <span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&lt;=</span> index<span class="br0">)</span> 
        <span class="br0">{</span> 
            a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> a<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
            J<span class="sy0">++;</span> 
        <span class="br0">}</span> 
        a<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: Binary insertion sort is an adaptive algorithm. It is because the time complexity of the algorithm improves when the input array is almost sorted.</i><p><b>1. Which of the following is an advantage of recursive insertion sort over its iterative version?<br>
a) it has better time complexity<br>
b) it has better space complexity<br>
c) it is easy to implement<br>
d) it has no significant advantage<br>
</b></p><i>Answer: d<br>
Explanation: Recursive insertion sort has no significant advantage over iterative insertion sort. It is just a different way to implement the same.</i><p><b>3. What will be the recurrence relation of the code of recursive insertion sort?<br>
a) T(n) = 2T(n/2) + n<br>
b) T(n) = 2T(n/2) + c<br>
c) T(n) = T(n-1) + n<br>
d) T(n) = T(n-1) + c<br>
</b></p><i>Answer: a<br>
Explanation: Insertion sort does not require the entire input data in the beginning itself in order to sort the array. It rather creates a partial solution in every step, so future elements are not required to be considered. Hence it is an online sorting algorithm.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Selection sort<br>
b) Quick sort<br>
c) Insertion sort<br>
d) Heap sort<br>
</b></p><i>Answer: c<br>
Explanation: The recurrence relation of the code of recursive insertion sort is T(n) = T(n-1) + n. It can be solved by the method of substitution and is found to be equal to n<sup>2</sup>.</i><p><b>5. Which of the following is a variant of insertion sort?<br>
a) selection sort<br>
b) shell sort<br>
c) odd-even sort<br>
d) stupid sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options insertion sort is the only algorithm which is stable. It is because the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>7. What is the average case time complexity of recursive insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Shell sort is a variation of insertion sort. It has a better running time in practical applications. </i><p><b>8. What is the best case time complexity of recursive insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In insertion sort, we need to compare elements in order to find the minimum element in each iteration. So we can say that it uses comparisons in order to sort the array. Thus it qualifies as a comparison based sort.</i><p><b>9. What is the worst case time complexity of recursive insertion sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: c<br>
Explanation: The overall recurrence relation of recursive insertion sort is given by T(n) = T(n-1) + n. It is found to be equal to O(n<sup>2</sup>).</i><p><b>10. How many swaps will be required in the worst case to sort an array having n elements using binary insertion sort?<br>
a) n<br>
b) 1<br>
c) n * log n<br>
d) log n<br>
</b></p><i>Answer: a<br>
Explanation: The best case time complexity of recursive insertion sort is O(n). It occurs in the case when the input is already/almost sorted.</i><p><b>12. What is the auxiliary space complexity of recursive insertion sort?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The overall recurrence relation of recursive insertion sort is given by T(n) = T(n-1) + n. It is found to be equal to O(n<sup>2</sup>).</i><p><b>13. Which of the following is an adaptive sorting algorithm?<br>
a) recursive insertion sort<br>
b) merge sort<br>
c) heap sort<br>
d) selection sort<br>
</b></p><i>Answer: d<br>
Explanation: In a normal insertion sort at most n comparisons are required to sort the array. But if we also implement the concept of a binary sort in insertion sort then we can sort by having log n comparisons only.</i><p><b>14. Which of the following sorting algorithm is in place?<br>
a) recursive insertion sort<br>
b) merge sort<br>
c) radix sort<br>
d) counting sort<br>
</b></p><i>Answer: c<br>
Explanation: The most appropriate condition for the base case of recursive insertion sort is when n is less than or equal 1 then return. It is because we know that an array with only 1 element is always sorted.</i><p><b>15.Choose the correct function for recursive insertion sort?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> RecInsertionSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">&lt;=</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	RecInsertionSort<span class="br0">(</span> arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw4">int</span> key <span class="sy0">=</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw4">int</span> j <span class="sy0">=</span> n<span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> 	
	<span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
	<span class="br0">{</span> 
		arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
		j<span class="sy0">--;</span> 
	<span class="br0">}</span> 
	arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> RecInsertionSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">&lt;</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
&nbsp;
	RecInsertionSort<span class="br0">(</span> arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw4">int</span> key <span class="sy0">=</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw4">int</span> j <span class="sy0">=</span> n<span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">||</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
	<span class="br0">{</span> 
		arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
		j<span class="sy0">--;</span> 
	<span class="br0">}</span> 
	arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> RecInsertionSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">&lt;</span><span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	RecInsertionSort<span class="br0">(</span> arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw4">int</span> key <span class="sy0">=</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw4">int</span> j <span class="sy0">=</span> n<span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
	<span class="br0">{</span> 
		arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
		j<span class="sy0">--;</span> 
	<span class="br0">}</span> 
	arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> RecInsertionSort<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">&lt;=</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
&nbsp;
	RecInsertionSort<span class="br0">(</span> arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw4">int</span> key <span class="sy0">=</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw4">int</span> j <span class="sy0">=</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">while</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">||</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> key<span class="br0">)</span> 
	<span class="br0">{</span> 
		arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
		j<span class="sy0">--;</span> 
	<span class="br0">}</span> 
	arr<span class="br0">[</span>j<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> key<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The auxiliary space required by recursive insertion sort is O(1). So it qualifies as an in place sorting algorithm.</i><p><b>1. Which of the following data structure is required for the implementation of tree sort?<br>
a) any ordinary tree<br>
b) balanced tree<br>
c) binary search tree<br>
d) unbalanced tree<br>
</b></p><i>Answer: c<br>
Explanation: Tree sort uses a binary search tree for sorting the given elements. Tree sort can also be performed by using an unbalanced binary search tree.</i><p><b>3. Which of the following traversal in a binary search tree results in a sorted output?<br>
a) in order traversal<br>
b) pre order traversal<br>
c) post order traversal<br>
d) breadth first traversal<br>
</b></p><i>Answer: a<br>
Explanation: Tree sort does not require the entire input data at the beginning itself in order to sort the array. It rather creates a partial solution in every step, so future elements are not required to be considered. Hence it is an online sorting algorithm.</i><p><b>4. Which of the following sorting algorithm is stable?<br>
a) Selection sort<br>
b) Quick sort<br>
c) Tree sort<br>
d) Heap sort<br>
</b></p><i>Answer: a<br>
Explanation: Tree sort uses a binary search tree for sorting the given elements. First a BST is formed by using the input data elements and then the BST is traversed in an in order fashion which gives a sorted output. </i><p><b>5. Which of the following sorting algorithm uses a binary search tree?<br>
a) radix sort<br>
b) tree sort<br>
c) odd-even sort<br>
d) bead sort<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options Tree sort is the only algorithm which is stable. It is because the elements with identical values appear in the same order in the output array as they were in the input array.</i><p><b>6. Which of the following is a comparison based sort?<br>
a) tree sort<br>
b) radix sort<br>
c) counting sort<br>
d) pigeonhole sort<br>
</b></p><i>Answer: b<br>
Explanation: Tree sort makes use of a binary search tree. It is because every time when a BST is traversed in an in order fashion it gives a sorted output.</i><p><b>7. What is the average case time complexity of tree sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In tree sort, we need to compare elements as we insert them in the binary search tree. Thus it qualifies as a comparison based sort.</i><p><b>8. What is the best case time complexity of tree sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: As on an average every element takes log n time for insertion in a binary search tree so for n elements O(n log n) time will be required on an average.</i><p><b>9. What is the worst case time complexity of tree sort (when implemented with a balanced tree)?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: The best case time complexity of tree sort is the same as its average case complexity. So best case time complexity is O(n log n).</i><p><b>10. What is the worst case time complexity of tree sort (when implemented with an unbalanced tree)?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: The worst case time complexity of tree sort depends on whether the tree used in the implementation is balanced or not. If the tree is balanced then the worst case complexity is O(n log n).</i><p><b>11. What is the auxiliary space complexity of tree sort?<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: The worst case time complexity of tree sort depends on whether the tree used in the implementation is balanced or not. If the tree is unbalanced then the worst case complexity is O(n<sup>2</sup>).</i><p><b>12. In which of the following case does a tree sort become adaptive?<br>
a) when implemented with an unbalanced tree<br>
b) when implemented with a balanced tree<br>
c) when implemented with a splay tree as BST<br>
d) when implemented with AVL tree as BST<br>
</b></p><i>Answer: b<br>
Explanation: Tree sort requires auxiliary space for maintaining a binary search tree. So the auxiliary space complexity of tree sort is O(n).</i><p><b>13. Which of the following is not true about tree sort?<br>
a) it is not an in place sorting algorithm<br>
b) its every implementation is adaptive<br>
c) it requires in order traversal of BST for sorting input elements<br>
d) it is a stable sort<br>
</b></p><i>Answer: c<br>
Explanation: Tree sort becomes an adaptive sort when it is implemented with a splay tree as a BST. In such a case the best case time complexity is better than (n log n).</i><p><b>14. Which of the following sorting algorithm is not in place?<br>
a) insertion sort<br>
b) quick sort<br>
c) tree sort<br>
d) gnome sort<br>
</b></p><i>Answer: b<br>
Explanation: Every implementation of tree sort is not adaptive. It becomes adaptive only when implemented with a splay tree as BST.</i><p><b>16. Which of the following is not an advantage of tree sort?<br>
a) it has a low space complexity<br>
b) it has good time complexity for balanced BST<br>
c) it is an online sorting algorithm<br>
d) it is stable sorting algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options tree sort is the only algorithm which is not in place. It is because the auxiliary space required by tree sort is O(n). </i><p><b>17. Which of the following version of tree sort will have the highest worst case time complexity?<br>
a) using AVL tree as BST<br>
b) using red black tree as BST<br>
c) using splay tree as BST<br>
d) using ordinary BST<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of tree sort is affected when implemented with an unbalanced tree or a balanced tree. In case of a balanced tree it is O(n log n) and in case of unbalanced tree it is O(n<sup>2</sup>).</i><p><b>1. What is a Rabin and Karp Algorithm?<br>
a) String Matching Algorithm<br>
b) Shortest Path Algorithm<br>
c) Minimum spanning tree Algorithm<br>
d) Approximation Algorithm<br>
</b></p><i>Answer: a<br>
Explanation: The string matching algorithm which was proposed by Rabin and Karp, generalizes to other algorithms and for two-dimensional pattern matching problems.</i><p><b>2. What is the pre-processing time of Rabin and Karp Algorithm?<br>
a) Theta(m<sup>2</sup>)<br>
b) Theta(mlogn)<br>
c) Theta(m)<br>
d) Big-Oh(n)<br>
</b></p><i>Answer: c<br>
Explanation: The for loop in the pre-processing algorithm runs for m(length of the pattern) times. Hence the pre-processing time is Theta(m).</i><p><b>4. What is the basic formula applied in Rabin Karp Algorithm to get the computation time as Theta(m)?<br>
a) Halving rule<br>
b) Horner’s rule<br>
c) Summation lemma<br>
d) Cancellation lemma<br>
</b></p><i>Answer: a<br>
Explanation: Rabin Karp Algorithm makes use of elementary theoretic number notions such as the equivalence of two numbers modulo a third number.</i><p><b>5. What is the worst case running time of Rabin Karp Algorithm?<br>
a) Theta(n)<br>
b) Theta(n-m)<br>
c) Theta((n-m+1)m)<br>
d) Theta(nlogm)<br>
</b></p><i>Answer: b<br>
Explanation: The pattern can be evaluated in time Theta(m) using Horner’s rule:<br>
p = P[m] + 10(P[m-1] + 10(P[m-2] +…+ 10(P[2]+10P[1])…)).</i><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to n
<span class="kw1">do</span> t0<span class="sy0">=</span><span class="br0">(</span>dt0 <span class="sy0">+</span> P<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q 
p<span class="sy0">=</span><span class="br0">(</span>dp<span class="sy0">+</span>T<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q</pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to n
<span class="kw1">do</span> p<span class="sy0">=</span><span class="br0">(</span>dp <span class="sy0">+</span> P<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q 
t0<span class="sy0">=</span><span class="br0">(</span>dt0<span class="sy0">+</span>T<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q</pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to m
<span class="kw1">do</span> t0<span class="sy0">=</span><span class="br0">(</span>dp <span class="sy0">+</span> P<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q 
p<span class="sy0">=</span><span class="br0">(</span>dt0<span class="sy0">+</span>T<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q</pre></div></div></div></div></div></div><p><b>8. If n is the length of text(T) and m is the length of the pattern(P) identify the correct matching algorithm.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to m
<span class="kw1">do</span> p<span class="sy0">=</span><span class="br0">(</span>dp <span class="sy0">+</span> P<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q 
t0<span class="sy0">=</span><span class="br0">(</span>dt0<span class="sy0">+</span>T<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>mod q</pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The worst case running time of Rabin Karp Algorithm is Theta(n-m+1)m). We write Theta(n-m+1) instead of Theta(n-m) because there are n-m+1 different values that the given text takes on.</i><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> s<span class="sy0">=</span><span class="nu0">0</span> to n
		<span class="kw1">do</span> <span class="kw1">if</span> p<span class="sy0">=</span>t0	
			then <span class="kw1">if</span> P<span class="br0">[</span><span class="nu0">1</span>..<span class="me1">m</span><span class="br0">]</span><span class="sy0">=</span>T<span class="br0">[</span>s<span class="sy0">+</span><span class="nu0">1</span>..<span class="me1">s</span><span class="sy0">+</span>m<span class="br0">]</span>
				then print “Pattern occurs with shift” s</pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> s<span class="sy0">=</span><span class="nu0">0</span> to n<span class="sy0">-</span>m
		<span class="kw1">do</span> <span class="kw1">if</span> p<span class="sy0">=</span>ts	
			then <span class="kw1">if</span> P<span class="br0">[</span><span class="nu0">1</span>..<span class="me1">m</span><span class="br0">]</span><span class="sy0">=</span>T<span class="br0">[</span>s<span class="sy0">+</span><span class="nu0">1</span>..<span class="me1">s</span><span class="sy0">+</span>m<span class="br0">]</span>
				then print “Pattern occurs with shift” s</pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="kw1">for</span> s<span class="sy0">=</span><span class="nu0">0</span> to m
		<span class="kw1">do</span> <span class="kw1">if</span> p<span class="sy0">=</span>ts	
			then <span class="kw1">if</span> P<span class="br0">[</span><span class="nu0">1</span>..<span class="me1">m</span><span class="br0">]</span><span class="sy0">=</span>T<span class="br0">[</span>s<span class="sy0">+</span><span class="nu0">1</span>..<span class="me1">s</span><span class="sy0">+</span>m<span class="br0">]</span>
				then print “Pattern occurs with shift” s</pre></div></div></div></div></div></div><p><b>9. What happens when the modulo value(q) is taken large?<br>
a) Complexity increases<br>
b) Spurious hits occur frequently<br>
c) Cost of extra checking is low<br>
d) Matching time increases<br>
</b></p><i>Answer: a<br>
Explanation: Since Rabin-Karp algorithm is a pattern detecting algorithm in a text or string, it can be used for detecting plagiarism in a sentence. </i><p><b>10. Given a pattern of length-5 window, find the suitable modulo value.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="kw1">for</span> s<span class="sy0">=</span><span class="nu0">0</span> to n<span class="sy0">-</span>m
		<span class="kw1">do</span> <span class="kw1">if</span> p<span class="sy0">!=</span>ts	
			then <span class="kw1">if</span> P<span class="br0">[</span><span class="nu0">1</span>..<span class="me1">m</span><span class="br0">]</span><span class="sy0">=</span>T<span class="br0">[</span>s<span class="sy0">+</span><span class="nu0">1</span>..<span class="me1">s</span><span class="sy0">+</span>m<span class="br0">]</span>
				then print “Pattern occurs with shift” s</pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The pre-processing algorithm runs m (the length of pattern) times. This algorithm is used to compute p as the value of P[1….m] mod q and t0 as the value of T[1….m]mod q. </i><p><b>a) 13<br>
b) 14<br>
c) 12<br>
d) 11<br>
</b></p><i>Answer: b<br>
Explanation: The matching algorithm runs for n-m times. Rabin Karp algorithm explicitly verifies every valid shift. If the required pattern matches with the given text then the algorithm prints pattern found as result.</i><p><b>11. Given a pattern of length- 5 window, find the valid match in the given text.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">					4 3 2 5 0</pre></div></div></div></div></div></div><p><b>a) 11-16<br>
b) 3-8<br>
c) 13-18<br>
d) 15-20<br>
</b></p><i>Answer: c<br>
Explanation: If the modulo value(q) is large enough then the spurious hits occur infrequently enough that the cost of extra checking is low.</i><p><b>12. Given a pattern of length- 5 window, find the spurious hit in the given text string.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">Pattern: 2 1 9 3 6 
Modulus: 21
Index: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
Text:   9 2 7 2 1 8 3 0 5 7 1   2   1   2   1   9   3   6   2   3   9  7</pre></div></div></div></div></div></div><p><b>a) 6-10<br>
b) 12-16<br>
c) 3-7<br>
d) 13-17<br>
</b></p><i>Answer: a<br>
Explanation: The modulus q is typically chosen as a prime number that is large enough to reduce the complexity when p is very large.</i><p><b>13.  If the expected number of valid shifts is small and modulus is larger than the length of pattern what is the matching time of Rabin Karp Algorithm?<br>
a) Theta(m)<br>
b) Big-Oh(n+m)<br>
c) Theta(n-m)<br>
d) Big-Oh(n)<br>
</b></p><i>Answer: c<br>
Explanation: The pattern 2 1 9 3 6 occurs in the text starting from position 13 to 18. In the given pattern value is computed as 12 by having the modulus as 21. The same text string values are computed for each possible position of a 5 length window. </i><p><b>14. What is the basic principle in Rabin Karp algorithm?<br>
a) Hashing<br>
b) Sorting<br>
c) Augmenting<br>
d) Dynamic Programming<br>
</b></p><i>Answer: d<br>
Explanation: The sub string in the range 13-17, 6 7 3 9 9 produces the same value 7 as the given pattern. But the pattern numbers don’t match with sub string identified, hence it is a spurious hit.</i><p><b>15. Who created the Rabin Karp Algorithm?<br>
a) Joseph Rabin and Michael Karp<br>
b) Michael Rabin and Joseph Karp<br>
c) Richard Karp and Michael Rabin<br>
d) Michael Karp and Richard Rabin<br>
</b></p><i>Answer: b<br>
Explanation: When the number of valid shifts(v) is Big-Oh(1) and q&gt;=m then the matching time is given by  O(n)+O(m(v+n/q)) is simplified as O(n+m).</i><p><b>1. Which of the following is the fastest algorithm in string matching field?<br>
a) Boyer-Moore’s algorithm<br>
b) String matching algorithm<br>
c) Quick search algorithm<br>
d) Linear search algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Quick search algorithm is the fastest algorithm in string matching field whereas Linear search algorithm searches for an element in an array of elements.</i><p><b>2. Which of the following algorithms formed the basis for the Quick search algorithm?<br>
a) Boyer-Moore’s algorithm<br>
b) Parallel string matching algorithm<br>
c) Binary Search algorithm<br>
d) Linear Search algorithm<br>
</b></p><i>Answer: a<br>
Explanation: Quick search algorithm was originally formed to overcome the drawbacks of Boyer-Moore’s algorithm and also for increased speed and efficiency.</i><p><b>3. What is the time complexity of the Quick search algorithm?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(m+n)<br>
d) O(mn)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the Quick search algorithm was found to be O(m+n) and is proved to be faster than Boyer-Moore’s algorithm.</i><p><b>4. What character shift tables does quick search algorithm use?<br>
a) good-character shift tables<br>
b) bad-character shift tables<br>
c) next-character shift tables<br>
d) both good and bad character shift tables<br>
</b></p><i>Answer: b<br>
Explanation: Quick search algorithm uses only bad character shift tables and it is one of the reasons for its increased speed than Boyer-Moore’s algorithm.</i><p><b>5. What is the space complexity of quick search algorithm?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(m+n)<br>
d) O(mn)<br>
</b></p><i>Answer: a<br>
Explanation: The space complexity of quick search algorithm is mathematically found to be O(n) where n represents the input size.</i><p><b>7. What character shift tables does Boyer-Moore’s search algorithm use?<br>
a) good-character shift tables<br>
b) bad-character shift tables<br>
c) next-character shift tables<br>
d) both good and bad character shift tables<br>
</b></p><i>Answer: b<br>
Explanation: Quick search algorithm starts searching from the left most character to the right and it uses only bad character shift tables.</i><p><b>8. What is the worst case running time in searching phase of Boyer-Moore’s algorithm?<br>
a) O(n)<br>
b) O(log n)<br>
c) O(m+n)<br>
d) O(mn)<br>
</b></p><i>Answer: d<br>
Explanation: Boyer-Moore’s search algorithm uses both good and bad character shift tables whereas quick search algorithm uses only bad character shift tables.</i><p><b>10. Given input string = “ABCDABCATRYCARCABCSRT” and pattern string = “CAT”. Find the first index of the pattern match using quick search algorithm.<br>
a) 2<br>
b) 6<br>
c) 11<br>
d) 14<br>
</b></p><i>Answer: d<br>
Explanation: If the pattern occurs in the text, the worst case running time of Boyer-Moore’s algorithm is found to be O(mn).</i><p><b>1. Euclid’s algorithm is used for finding ___________<br>
a) GCD of two numbers<br>
b) GCD of more than three numbers<br>
c) LCM of two numbers<br>
d) LCM of more than two numbers<br>
</b></p><i>Answer: a<br>
Explanation: Euclid’s algorithm is basically used to find the GCD of two numbers. It cannot be directly applied to three or more numbers at a time.</i><p><b>2. Who invented Euclid’s algorithm?<br>
a) Sieve<br>
b) Euclid<br>
c) Euclid-Sieve<br>
d) Gabriel lame<br>
</b></p><i>Answer: b<br>
Explanation: Euclid invented Euclid’s algorithm. Sieve provided an algorithm for finding prime numbers. Gabriel lame proved a theorem in Euclid’s algorithm.</i><p><b>3. If 4 is the GCD of 16 and 12, What is the GCD of 12 and 4?<br>
a) 12<br>
b) 6<br>
c) 4<br>
d) 2<br>
</b></p><i>Answer: c<br>
Explanation: Euclid’s algorithm states that the GCD of two numbers does not change even if the bigger number is replaced by a difference of two numbers. So, GCD of 16 and 12 and 12 and (16-12)=4 is the same.</i><p><b>4. Which of the following is not an application of Euclid’s algorithm?<br>
a) Simplification of fractions<br>
b) Performing divisions in modular arithmetic<br>
c) Solving quadratic equations<br>
d) Solving diophantine equations<br>
</b></p><i>Answer: c<br>
Explanation: Solving quadratic equations is not an application of Euclid’s algorithm whereas the rest of the options are mathematical applications of Euclid’s algorithm.</i><p><b>6. According to Gabriel lame, how many steps does Euclid’s algorithm require to solve a problem?<br>
a) Less than five times the number of digits<br>
b) More than five times the number of digits<br>
c) Less than two times the number of digits<br>
d) More than two times the number of digits<br>
</b></p><i>Answer: a<br>
Explanation: The Euclid’s algorithm runs efficiently if the remainder of two numbers is divided by the minimum of two numbers until the remainder is zero. This improvement in efficiency was put forth by Gabriel Lame.</i><p><b>7. Which of the following is the correct mathematical application of Euclid’s algorithm?<br>
a) Determination of prime numbers<br>
b) Lagrange’s four square theorem<br>
c) Cauchy-Euler theorem<br>
d) Residue theorem<br>
</b></p><i>Answer: a<br>
Explanation: The Euclid’s algorithm requires less than five times the number of digits. It runs by dividing two numbers. It stops when a remainder zero is reached.</i><p><b>8. If GCD of two numbers is 1, then the two numbers are said to be ________<br>
a) Co-prime numbers<br>
b) Prime numbers<br>
c) Composite numbers<br>
d) Rational numbers<br>
</b></p><i>Answer: b<br>
Explanation: Lagrange’s four square theorem is one of the mathematical applications of Euclid’s algorithm and it is the basic tool for proving theorems in number theory. It can be generalized into other types of numbers like the Gaussian integers.</i><p><b>9. What is the total running time of Euclid’s algorithm?<br>
a) O(N)<br>
b) O(N log M)<br>
c) O(N log N)<br>
d) O(log N +1)<br>
</b></p><i>Answer: a<br>
Explanation: If GCD of two numbers is 1, they are called as co-prime or relatively prime numbers. It does not mean that they are prime numbers. They don’t have any prime factors in common.</i><p><b>11. What is the formula for Euclidean algorithm?<br>
a) GCD (m,n) = GCD (n, m mod n)<br>
b) LCM(m,n)=LCM(n, m mod n)<br>
c) GCD(m,n,o,p) = GCD (m, m mod n, o, p mod o)<br>
d) LCM (m,n,o,p) = LCM (m, m mod n, o, p mod o)<br>
</b></p><i>Answer: a<br>
Explanation: The total running time of Euclid’s algorithm according to Lame’s analysis is found to be O(N).</i><p><b>12. What is the total running time of the binary GCD algorithm?<br>
a) O(N)<br>
b) O(N<sup>2</sup>)<br>
c) O(log N)<br>
d) O(N log N)<br>
</b></p><i>Answer: a<br>
Explanation: Euclid’s algorithm does not require the calculation of prime factors. We derive the answer straight away using formula. And also, factorization is complex.</i><p><b>13. What is the GCD of 20 and 12 using Euclid’s algorithm?<br>
a) 8<br>
b) 2<br>
c) 4<br>
d) 6<br>
</b></p><i>Answer: a<br>
Explanation: The formula for computing GCD of two numbers using Euclidean algorithm is given as GCD (m,n)= GCD (n, m mod n). It is used recursively until zero is obtained as a remainder.</i><p><b>1. Strassen’s algorithm is a/an_____________ algorithm.<br>
a) Non- recursive<br>
b) Recursive<br>
c) Approximation<br>
d) Accurate<br>
</b></p><i>Answer: b<br>
Explanation: Strassen’s Algorithm for matrix multiplication is a recursive algorithm since the present output depends on previous outputs and inputs.</i><p><b>2. What is the running time of Strassen’s algorithm for matrix multiplication?<br>
a) O(n<sup>2.81</sup>)<br>
b) O(n<sup>3</sup>)<br>
c) O(n<sup>1.8</sup>)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Strassen’s matrix algorithm requires only 7 recursive multiplications of n/2 x n/2 matrix and Theta(n<sup>2</sup>) scalar additions and subtractions yielding the running time as O(n<sup>2.81</sup>).</i><p><b>3. What is the running time of naïve matrix multiplication algorithm?<br>
a) O(n<sup>2.81</sup>)<br>
b) O(n<sup>4</sup>)<br>
c) O(n)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The traditional matrix multiplication algorithm takes O(n<sup>3</sup>) time. The number of recursive multiplications involved in this algorithm is 8. </i><p><b>4. Strassen’s matrix multiplication algorithm follows ___________ technique.<br>
a) Greedy technique<br>
b) Dynamic Programming<br>
c) Divide and Conquer<br>
d) Backtracking<br>
</b></p><i>Answer: c<br>
Explanation: Strassen’s matrix multiplication algorithm follows divide and conquer technique. In this algorithm the input matrices are divided into n/2 x n/2 sub matrices and then the recurrence relation is applied.</i><p><b>5. The number of scalar additions and subtractions used in Strassen’s matrix multiplication algorithm is ________<br>
a) O(n<sup>2.81</sup>)<br>
b) Theta(n<sup>2</sup>)<br>
c) Theta(n)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Using Theta(n<sup>2</sup>) scalar additions and subtractions, 14 matrices are computed each of which is n/2 x n/2. Then seven matrix products are computed recursively.</i><p><b>7. Given the program of naïve method.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to n <span class="kw1">do</span>
   <span class="kw1">for</span> j<span class="sy0">=</span><span class="nu0">1</span> to n <span class="kw1">do</span>
       Z<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">for</span> k<span class="sy0">=</span><span class="nu0">1</span> to n <span class="kw1">do</span> 
            ___________________________</pre></div></div></div></div></div></div><p><b>Fill in the blanks with appropriate formula<br>
a) Z[i][j] = Z[i][j] + X[i][k]*Y[k][j] <br>
b) Z[i][j] = Z[i][j] + X[i][k] + Y[k][j] <br>
c) Z[i][j] = Z[i][j] * X[i][k]*Y[k][j] <br>
d) Z[i][j] = Z[i][j] * X[i][k] + Y[k][j] <br>
</b></p><i>Answer: a<br>
Explanation: Strassen’s Algorithm requires only 7 recursive multiplications when compared with the naïve Theta(n<sup>3</sup>) method which reuires 9 recursive multiplications to compute the product.</i><p><b>8. Who demonstrated the difference in numerical stability?<br>
a) Strassen<br>
b) Bailey<br>
c) Lederman<br>
d) Higham<br>
</b></p><i>Answer: a<br>
Explanation: In the naïve method of matrix multiplication the number of iterating statements involved are 3, because of the presence of rows and columns. The element in each row of one matrix is multiplied with each element in the column of the second matrix. The computed value is placed in the new matrix Z[i][j].</i><p><b>9. What is the recurrence relation used in Strassen’s algorithm?<br>
a) 7T(n/2) + Theta(n<sup>2</sup>)<br>
b) 8T(n/2) + Theta(n<sup>2</sup>)<br>
c) 7T(n/2) + O(n<sup>2</sup>)<br>
d) 8T(n/2) + O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The difference in the numerical stability was demonstrated by Higham. He overemphasized that Strassen’s algorithm is numericaly unstable for some applications. </i><p><b>10. Who discussed techniques for reducing the memory requirements for Strassen’s algorithm?<br>
a) Strassen<br>
b) Lederman<br>
c) Bailey<br>
d) Higham<br>
</b></p><i>Answer: a<br>
Explanation: The recurrence relation used in Strassen’s algorithm is 7T(n/2) + Theta(n<sup>2</sup>) since there are only 7 recursive multiplications and Theta(n<sup>2</sup>) scalar additions and subtractions involved for computing the product.</i><p><b>11. What is the formula to calculate the element present in second row, first column of the product matrix?<br>
a) M1+M7<br>
b) M1+M3<br>
c) M2+M4 – M5 + M7<br>
d) M2+M4<br>
</b></p><i>Answer: c<br>
Explanation: The submatrices formed at the levels of recursion consume space. Hence in order to overcome that Bailey discussed techniques for reducing the memory required.   </i><p><b>12. Strassen’s Matrix Algorithm was proposed by _____________<br>
a) Volker Strassen<br>
b) Andrew Strassen<br>
c) Victor Jan<br>
d) Virginia Williams<br>
</b></p><i>Answer: d<br>
Explanation: The element at second row, first column can be found by the formula M2 + M4, where M2 and M4 can be calculated by<br>
M2= (A(2,1) + A(2,2)) B(1,1)<br>
M4=A(2,2)(B(1,2) – B(1,1)).</i><p><b>13. How many iterating statements are involved in the naïve method of matrix multiplication?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: a<br>
Explanation: Strassen’s matrix multiplication algorithm was first published by Volker Strassen in the year 1969 and proved that the n<sup>3</sup> general matrix multiplication algorithm wasn’t optimal.</i><p><b>1. What is pseudo random number generator?<br>
a) an algorithm that generates random numbers with help of mathematical formula<br>
b) an algorithm that generates random numbers according to user activity<br>
c) an algorithm that generates random numbers according to time<br>
d) an algorithm that generates random numbers with help of user input<br>
</b></p><i>Answer: a<br>
Explanation: A pseudo random number generator generates random numbers with the help of a mathematical formula. We can seed the random number generator with a different value everytime if we want unique random numbers to be generated.</i><p><b>2. What should be the return type of rand() function?<br>
a) int<br>
b) float<br>
c) long<br>
d) double<br>
</b></p><i>Answer: a<br>
Explanation: The return type of rand () is int. It can generate random numbers from 0 to RAND_MAX. </i><p><b>3. What is the purpose of using function srand()?<br>
a) to set the seed of rand() function<br>
b) to generate random numbers<br>
c) to enable rand() function<br>
d) to improve efficiency of rand()<br>
</b></p><i>Answer: a<br>
Explanation: The function srand() sets the seed of rand(). It can be used to generate a unique set of random numbers every time.</i><p><b>4. What is the range of rand()?<br>
a) 0 to RAND_MAX<br>
b) 0 to infinity<br>
c) 0 to 2147483647<br>
d) 0 to 32767<br>
</b></p><i>Answer: a<br>
Explanation: The function rand() generates random numbers in the range 0 to RAND_MAX. The value of RAND_MAX is minimum 32,767.</i><p><b>5.What is the correct formula for generating random numbers in the range (lower,upper) using rand()?<br>
a) rand() % (upper – lower)<br>
b) rand() + lower<br>
c) (rand()%(upper-lower)) + lower<br>
d) (rand()%(upper-lower+1)) + lower<br>
</b></p><i>Answer: d<br>
Explanation: The correct formula for generating random numbers in the range (lower,upper) using rand() is (rand()%(upper-lower+1)) + lower. The function rand() generates random numbers in the range 0 to RAND_MAX.</i><p><b>6. Which of the following will generate random numbers in the range 1-100 (both inclusive)?<br>
a) rand() % 100<br>
b) rand() % 101<br>
c) (rand() % (101)) + 1<br>
d) (rand() % (100)) + 1<br>
</b></p><i>Answer: d<br>
Explanation: Formula for generating random numbers in the range (lower,upper) using rand() is (rand()%(upper-lower+1)) + lower. So the correct answer will be (rand() % (100)) + 1.</i><p><b>7. What is the minimum value of RAND_MAX possible in any implementation?<br>
a) 0<br>
b) 32767<br>
c) 2147483647<br>
d) 128<br>
</b></p><i>Answer: b<br>
Explanation: The value of RAND_MAX varies according to implementation. But it is guaranteed to be at least 32767.</i><p><b>9. What is the default value of seed if function rand() is called before srand()?<br>
a) srand(0)<br>
b) srand(1)<br>
c) srand(time(null))<br>
d) srand(-1)<br>
</b></p><i>Answer: b<br>
Explanation: Function rand() does not generate unique random numbers every time. For achieving this we have to use srand() along with rand().</i><p><b>11. Predict the output of the following code.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) compilation error<br>
b) random number between 0 to RAND_MAX<br>
c) cannot be predicted<br>
d) 0<br>
</b></p><i>Answer: b<br>
Explanation: If srand() is not called before the call to the function rand() then the value of seed is taken as srand(1) by default. We should use srand() before rand() in order to use our own seed.</i><p><b>12. Which header file contains the function rand() in C language?<br>
a) stdlib<br>
b) iostream<br>
c) stdio<br>
d) time<br>
</b></p><i>Answer: b<br>
Explanation: Pseudo random number generators cannot be used for data encryption as the random numbers generated by them are predictable. For data encryption the numbers should be absolutely unpredictable.</i><p><b>13. Predict the output of the following code.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) compilation error<br>
b) random number between 0 to 50 (both inclusive)<br>
c) random number between 0 to 51 (both inclusive)<br>
d) random number between 0 to 49 (both inclusive)<br>
</b></p><i>Answer: b<br>
Explanation: The function rand() generates random numbers in the range 0 to RAND_MAX. The function srand() seeds rand(). We get unique set of random numbers if rand() is seeded with a different value every time.</i><p><b>14. Which of the following code will generate unique random numbers every time?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="kw3">time</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: In C language the header file stdlib contains the function rand(). It generates pseudo random numbers.</i><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>15. Which of the following code will give an error?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">srand</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="kw3">time</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: Formula for generating random numbers in the range (lower,upper) using rand() is (rand()%(upper-lower+1)) + lower. So the given code will generate random numbers between 0 to 49.</i><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
     <span class="kw3">srand</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdlib.h&gt; </span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">%</span><span class="nu19">50</span><span class="br0">)</span><span class="sy0">;</span> 
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>1. The dictionary ordering of elements is known as?<br>
a) Lexicographical order<br>
b) Colexicographical order<br>
c) Well order<br>
d) Sorting<br>
</b></p><i>Answer: a<br>
Explanation: Lexicographical order is also known as dictionary order. It is a generalized method of the way words are alphabetically ordered in a dictionary.</i><p><b>2. How many permutations will be formed from the array arr={1,2,3}?<br>
a) 2<br>
b) 4<br>
c) 6<br>
d) 8<br>
</b></p><i>Answer: c<br>
Explanation: No.of permutations for an array of size n will be given by the formula nPn. So for the given problem, we have 3P3=6 or 3!=6.</i><p><b>3. What will be the lexicographical order of permutations formed from the array arr={1,2,3}?<br>
a) {{2,1,3},{3,2,1},{3,1,2},{2,3,1},{1,2,3},{1,3,2}}<br>
b) {{1,2,3},{1,3,2},{2,3,1},{2,1,3},{3,2,1},{3,1,2}}<br>
c) {{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}<br>
d) {{2,1,3},{3,1,2},{3,2,1},{2,3,1},{1,2,3},{1,3,2}}<br>
</b></p><i>Answer: c<br>
Explanation: The number of permutations for the problem will be 6 according to the formula 3P3. When ordered in lexicographical manner these will be {{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}}.</i><p><b>4. What is the name given to the algorithm depicted in the pseudo code below?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">procedure generate<span class="br0">(</span>n <span class="sy0">:</span> integer<span class="sy0">,</span> Arr <span class="sy0">:</span> array<span class="br0">)</span><span class="sy0">:</span>
    <span class="kw1">if</span> n <span class="sy0">=</span> <span class="nu0">1</span> then
          output<span class="br0">(</span>Arr<span class="br0">)</span>
    <span class="kw1">else</span>
        <span class="kw1">for</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> i <span class="sy0">++</span> <span class="kw1">do</span>
            generate<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> Arr<span class="br0">)</span>
            <span class="kw1">if</span> n is even then
                swap<span class="br0">(</span>Arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> Arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
            <span class="kw1">else</span>
                swap<span class="br0">(</span>Arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> Arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
            end <span class="kw1">if</span>
        end <span class="kw1">for</span>
        generate<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">,</span> Arr <span class="br0">)</span>
    end <span class="kw1">if</span></pre></div></div></div></div></div></div><p><b>a) bubble sort<br>
b) heap sort<br>
c) heap’s algorithm<br>
d) prim’s algorithm<br>
</b></p><i>Answer: c<br>
Explanation: The given algorithm is called Heap’s algorithm. It is used for generating permutations of a given list.</i><p><b>6. What is the time complexity of Heap’s algorithm?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n*n!)<br>
d) O(n!)<br>
</b></p><i>Answer: b<br>
Explanation: Heap’s algorithm does not require any extra array for generating permutations. Thus it is able to keep its space requirement to a very low level. This makes it preferable algorithm for generating permutations.</i><p><b>7. What will be the output for following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;string.h&gt; </span>
<span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">void</span> swap<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>x<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> temp<span class="sy0">;</span> 
	temp <span class="sy0">=</span> <span class="sy0">*</span>x<span class="sy0">;</span> 
	<span class="sy0">*</span>x <span class="sy0">=</span> <span class="sy0">*</span>y<span class="sy0">;</span> 
	<span class="sy0">*</span>y <span class="sy0">=</span> temp<span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>a<span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
<span class="kw4">int</span> i<span class="sy0">;</span> 
<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">==</span> r<span class="br0">)</span> 
	cout<span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” <span class="sy0">,</span>”<span class="sy0">;</span> 
<span class="kw1">else</span>
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> l<span class="sy0">;</span> i <span class="sy0">&lt;=</span> r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
		func<span class="br0">(</span>a<span class="sy0">,</span> l<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"AB"</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) AB,BA,<br>
b) BA,AB,<br>
c) AB,BA<br>
d) BA,AB,<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation for the heap’s algorithm is given by the expression T(n)=n * T(n-1). It is calculated by using substitution method. It is found to be equal to O(n!). </i><p><b>8. What will be the time complexity of the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;string.h&gt; </span>
<span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">void</span> swap<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>x<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> temp<span class="sy0">;</span> 
	temp <span class="sy0">=</span> <span class="sy0">*</span>x<span class="sy0">;</span> 
	<span class="sy0">*</span>x <span class="sy0">=</span> <span class="sy0">*</span>y<span class="sy0">;</span> 
	<span class="sy0">*</span>y <span class="sy0">=</span> temp<span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>a<span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
<span class="kw4">int</span> i<span class="sy0">;</span> 
<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">==</span> r<span class="br0">)</span> 
	cout<span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” <span class="sy0">,</span>”<span class="sy0">;</span> 
<span class="kw1">else</span>
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> l<span class="sy0">;</span> i <span class="sy0">&lt;=</span> r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
		func<span class="br0">(</span>a<span class="sy0">,</span> l<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"AB"</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n<sup>2</sup>)<br>
b) O(n * n!)<br>
c) O(n!)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: The given code prints the permutations of the an array. So there will be 2 permutations for an array of 2 elements. Note that the comma is printed even for the last permutation.</i><p><b>9. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include&lt;string&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">void</span> func1<span class="br0">(</span>string input<span class="sy0">,</span>string output<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>input.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        cout<span class="sy0">&lt;&lt;</span>output<span class="sy0">&lt;&lt;</span><span class="st0">","</span><span class="sy0">;</span>
        <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>output.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
    func1<span class="br0">(</span>input.<span class="me1">substr</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span>output.<span class="me1">substr</span><span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>i<span class="br0">)</span> <span class="sy0">+</span> input<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> output.<span class="me1">substr</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">char</span> str<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"AB"</span><span class="sy0">;</span>
&nbsp;
	func1<span class="br0">(</span>str<span class="sy0">,</span> <span class="st0">""</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The recurrence relation for the heap’s algorithm is given by the expression T(n)=n * T(n-1). But as each permutations takes n time to be printed so the overall complexity will be O(n*n!).</i><p><b>a) AA,BA,<br>
b) AB,BA,<br>
c) BA,AB,<br>
d) AB,AB,<br>
</b></p><i>Answer: c<br>
Explanation: The given code prints the permutations of the an array. So there will be 2 permutations for an array of 2 elements. In this code the difference is that BA is printed before AB. Note that the comma is printed even for the last permutation.</i><p><b>10. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;string.h&gt; </span>
<span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">void</span> swap<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>x<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> temp<span class="sy0">;</span> 
	temp <span class="sy0">=</span> <span class="sy0">*</span>x<span class="sy0">;</span> 
	<span class="sy0">*</span>x <span class="sy0">=</span> <span class="sy0">*</span>y<span class="sy0">;</span> 
	<span class="sy0">*</span>y <span class="sy0">=</span> temp<span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>a<span class="sy0">,</span> <span class="kw4">int</span> l<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 
<span class="kw4">int</span> i<span class="sy0">;</span> 
<span class="kw1">if</span> <span class="br0">(</span>l <span class="sy0">==</span> r<span class="br0">)</span> 
	cout<span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” <span class="sy0">,</span>”<span class="sy0">;</span> 
<span class="kw1">else</span>
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> l<span class="sy0">;</span> i <span class="sy0">&lt;=</span> r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
		func<span class="br0">(</span>a<span class="sy0">,</span> l<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
		swap<span class="br0">(</span><span class="br0">(</span>a<span class="sy0">+</span>l<span class="br0">)</span><span class="sy0">,</span> <span class="br0">(</span>a<span class="sy0">+</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> str<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"AA"</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	func<span class="br0">(</span>str<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) AA,<br>
b) AA,AA<br>
c) A,A<br>
d) AA,AA,<br>
</b></p><i>Answer: d<br>
Explanation: The given code prints the permutations of the given array but it is not able to handle duplicates due to which it prints 2P2 permutations even in this case. So the output becomes AA,AA,.</i><p><b>11. What will be the output of the code that generates permutations and also has the ability to handle duplicates, for the input str[]=”AA”?<br>
a) AA<br>
b) AA,AA<br>
c) A,A<br>
d) A<br>
</b></p><i>Answer: a<br>
Explanation: If a code is able to handle duplicates then the two A’s are not considered to be different elements due to which only one permutation will be formed. So the output will be AA only.</i><p><b>1. What is meant by the term lexicographical order?<br>
a) dictionary ordering of elements<br>
b) reverse dictionary ordering of elements<br>
c) to sort according to value of first element<br>
d) to sort according to value of last element<br>
</b></p><i>Answer: a<br>
Explanation: Lexicographical order is also known as dictionary order. It is a generalized method of the way words are alphabetically ordered in a dictionary.</i><p><b>2. How many combinations of 2 elements will be formed from the array arr={1,2,3}?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: No.of combinations of r elements for an array of size n will be given by the formula nCr. So for the given problem, we have 3C2=3.</i><p><b>3. What will be the lexicographical order of combinations of 2 elements each formed from the array arr={1,2,3}?<br>
a) {{2,1},{3,2},{3,1}}<br>
b) {{1,2},{2,3},{1,3}}<br>
c) {{1,2},{1,3},{2,3}}<br>
d) {{2,1},{3,1},{3,2}}<br>
</b></p><i>Answer: c<br>
Explanation: The number of combinations for the problem will be 3 according to the formula 3C2. When ordered in lexicographical manner these will be {{1,2},{1,3},{2,3}}.</i><p><b>4. What will be the auxiliary space requirement (excluding call stack) of the program to print combinations of r elements each from array of size n?<br>
a) O(n*r)<br>
b) O(n/r)<br>
c) O(n)<br>
d) O(r)<br>
</b></p><i>Answer: d<br>
Explanation: Code to print combinations will require an auxiliary space of O(r) other than call stack memory. This memory is required by an array that is used for storing combinations formed.</i><p><b>6. What will be the time complexity of the code to print combinations?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Code to print combinations will require an auxiliary space of O(r) other than call stack memory. So it is not an in-place algorithm.</i><p><b>7. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> r<span class="sy0">,</span><span class="kw4">int</span> index<span class="sy0">,</span><span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2, 1 2, 2 2<br>
b) 1 2, 1 2, 2 2 ,<br>
c) 1 2, 2 1, 2 2 ,<br>
d) 1 2, 2 1, 2 2<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation of the code to print combinations will be T(n)=2T(n-1)+k. It is found to be equal to O(2<sup>n</sup>).</i><p><b>8. Which of the following code prints the combinations of a given array?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end <span class="sy0">&amp;&amp;</span> end<span class="sy0">-</span>i<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&gt;=</span> r<span class="sy0">-</span>index<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end <span class="sy0">&amp;&amp;</span> end<span class="sy0">-</span>i<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&gt;=</span> r<span class="sy0">-</span>index<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end <span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The given code prints the combinations of the given array in lexicographical order.The given code considers the duplicate 2s as different entities.Note that the comma is printed even for the last combination.</i><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> 
					<span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">&lt;=</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>9. Which of the following code prints the combinations of a given array?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> r<span class="sy0">,</span><span class="kw4">int</span> index<span class="sy0">,</span><span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> r<span class="sy0">,</span><span class="kw4">int</span> index<span class="sy0">,</span><span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> r<span class="sy0">,</span><span class="kw4">int</span> index<span class="sy0">,</span><span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: In the code we start from first index (index = 0) in array aux and one by one fix elements at this index and recur for remaining indexes. Finally, when index becomes equal to r we print the combination.</i><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> r<span class="sy0">,</span><span class="kw4">int</span> index<span class="sy0">,</span><span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> i<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	combination<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>10. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span> 
        combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> j<span class="sy0">&lt;</span>r<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> aux<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end <span class="sy0">&amp;&amp;</span> end<span class="sy0">-</span>i<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&gt;=</span> r<span class="sy0">-</span>index<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span>   aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2, 1 3, 2 3<br>
b) 1 3,1 2,2 3,<br>
c) 1 2, 1 3, 2 3,<br>
d) 1 2,1 3,2 3,<br>
</b></p><i>Answer: a<br>
Explanation: In this method we consider each method one by one and recur for two cases.In first case we include that element in our array and in second case we don’t .When the number of elements in the array aux[] becomes equal to r then we print that combination.</i><p><b>11. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
<span class="co2">#include &lt;stdlib.h&gt;</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span><span class="sy0">;</span>
<span class="kw4">int</span> compare <span class="br0">(</span><span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span> a<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">void</span> <span class="sy0">*</span> b<span class="br0">)</span>
<span class="br0">{</span>  <span class="kw1">return</span> <span class="br0">(</span> <span class="sy0">*</span><span class="br0">(</span><span class="kw4">int</span><span class="sy0">*</span><span class="br0">)</span>a <span class="sy0">-</span> <span class="sy0">*</span><span class="br0">(</span><span class="kw4">int</span><span class="sy0">*</span><span class="br0">)</span>b <span class="br0">)</span><span class="sy0">;</span>  <span class="br0">}</span>
<span class="kw4">void</span> print<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> aux<span class="br0">[</span>r<span class="br0">]</span><span class="sy0">;</span>
    <span class="kw3">qsort</span> <span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy0">,</span> compare<span class="br0">)</span><span class="sy0">;</span>    
    combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">void</span> combination<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> aux<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> start<span class="sy0">,</span> <span class="kw4">int</span> end<span class="sy0">,</span> <span class="kw4">int</span> index<span class="sy0">,</span> <span class="kw4">int</span> r<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> r<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>r<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
            <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span> <span class="sy0">,</span>aux<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>    
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>start<span class="sy0">;</span> i<span class="sy0">&lt;=</span>end <span class="sy0">&amp;&amp;</span> end<span class="sy0">-</span>i<span class="sy0">+</span><span class="nu0">1</span> <span class="sy0">&gt;=</span> r<span class="sy0">-</span>index<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
    <span class="br0">{</span>
        aux<span class="br0">[</span>index<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
        combination<span class="br0">(</span>arr<span class="sy0">,</span> aux<span class="sy0">,</span> i<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> end<span class="sy0">,</span> index<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">while</span> <span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> arr<span class="br0">[</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
             i<span class="sy0">++;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> r <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> r<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2, 1 2,2 2,<br>
b) 1 2, 2 1, 2 2,<br>
c) 1 2, 2 2,<br>
d) 1 2, 2 2, 2 1,<br>
</b></p><i>Answer: c<br>
Explanation: The given code prints the combinations of the given array in lexicographical order.Note that the comma is printed even for the last combination.</i><p><b>1. What is meant by integer partition?<br>
a) representing an integer as sum of positive and negative real numbers<br>
b) representing an integer as sum of positive and negative integers<br>
c) representing an integer as sum of positive integers<br>
d) representing an integer as sum of positive real numbers<br>
</b></p><i>Answer: c<br>
Explanation: Integer partition is the way of representing an integer as sum of positive integers. Partitions differing only in their order are considered to be same.</i><p><b>2. How many partitions will be formed for the integer 3?<br>
a) 2<br>
b) 3<br>
c) 4<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: We need to find the combinations of positive integers which give 3 as their sum. These will be {3}, {2,1}, {1,1,1}. Thus the correct answer is 3.</i><p><b>3. What is meant by number theory?<br>
a) study of integers<br>
b) study of complex numbers<br>
c) numerology<br>
d) theory of origination of mathematics<br>
</b></p><i>Answer: a<br>
Explanation: Number theory is a branch of mathematics that deals with the study of integers. Partitioning of a number comes under the study of number theory.</i><p><b>4. Which of the following is true according to Ramanujan’s congruence?<br>
a) No. of partitions are divisible by 5 for a number 3 more than a multiple of 5<br>
b) No. of partitions are divisible by 5 for a number 4 more than a multiple of 5<br>
c) No. of partitions are divisible by 5 for a number 2 more than a multiple of 5<br>
d) No. of partitions are divisible by 5 for a number 1 more than a multiple of 5<br>
</b></p><i>Answer: b<br>
Explanation: Ramanujan’s congruence are some relations found for the no. of partitions of an integer. According to it, the number of partitions of an integer is divisible by 5 if that integer is 4 more than a multiple of 5.</i><p><b>5. The no. of partitions of which of the following integer will be divisible by 5?<br>
a) 3<br>
b) 5<br>
c) 9<br>
d) 6<br>
</b></p><i>Answer: c<br>
Explanation: According to Ramanujan’s congruence number of partitions of an integer is divisible by 5 if that integer is 4 more than a multiple of 5. So out of the given options 9 is the only integer which satisfies this condition.</i><p><b>6. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span>  
<span class="kw4">void</span> printArray<span class="br0">(</span><span class="kw4">int</span> p<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	cout <span class="sy0">&lt;&lt;</span> p<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
	cout <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> func1<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> p<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>  
	<span class="kw4">int</span> k <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>  
	p<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> n<span class="sy0">;</span> 	
	<span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
	<span class="br0">{</span> 		
		printArray<span class="br0">(</span>p<span class="sy0">,</span> k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 		
		<span class="kw4">int</span> rem_val <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
		<span class="kw1">while</span> <span class="br0">(</span>k <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> p<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			rem_val <span class="sy0">+=</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			k<span class="sy0">--;</span> 
		<span class="br0">}</span> 
		<span class="kw1">if</span> <span class="br0">(</span>k <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="kw1">return</span><span class="sy0">;</span> 	
		p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">--;</span> 
		rem_val<span class="sy0">++;</span> 		
		<span class="kw1">while</span> <span class="br0">(</span>rem_val <span class="sy0">&gt;</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			p<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			rem_val <span class="sy0">=</span> rem_val <span class="sy0">-</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			k<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		p<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> rem_val<span class="sy0">;</span> 
		k<span class="sy0">++;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
<span class="kw4">int</span> n<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">;</span>
	func1<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>8. What is the approach implemented in the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span>  
<span class="kw4">void</span> printArray<span class="br0">(</span><span class="kw4">int</span> p<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	cout <span class="sy0">&lt;&lt;</span> p<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
	cout <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> func1<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> p<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>  
	<span class="kw4">int</span> k <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>  
	p<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">=</span> n<span class="sy0">;</span> 	
	<span class="kw1">while</span> <span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span> 
	<span class="br0">{</span> 		
		printArray<span class="br0">(</span>p<span class="sy0">,</span> k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 		
		<span class="kw4">int</span> rem_val <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
		<span class="kw1">while</span> <span class="br0">(</span>k <span class="sy0">&gt;=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> p<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			rem_val <span class="sy0">+=</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			k<span class="sy0">--;</span> 
		<span class="br0">}</span> 
		<span class="kw1">if</span> <span class="br0">(</span>k <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="kw1">return</span><span class="sy0">;</span> 	
		p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">--;</span> 
		rem_val<span class="sy0">++;</span> 		
		<span class="kw1">while</span> <span class="br0">(</span>rem_val <span class="sy0">&gt;</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			p<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			rem_val <span class="sy0">=</span> rem_val <span class="sy0">-</span> p<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span> 
			k<span class="sy0">++;</span> 
		<span class="br0">}</span> 
		p<span class="br0">[</span>k<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> rem_val<span class="sy0">;</span> 
		k<span class="sy0">++;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
      <span class="kw4">int</span> n<span class="sy0">;</span>
      cin<span class="sy0">&gt;&gt;</span>n<span class="sy0">;</span>
      func1<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) greedy approach<br>
b) dynamic programming<br>
c) recursion(divide and conquer)<br>
d) backtracking<br>
</b></p><i>Answer: d<br>
Explanation: The given code prints the partition of a number in decreasing order. This code uses the approach of dynamic programming.</i><p><b>9. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">int</span> list<span class="br0">[</span><span class="nu0">200</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">void</span> func<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> m <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> i<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> m<span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span> list<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> n<span class="sy0">;</span> i <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="sy0">--</span>i<span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw1">if</span><span class="br0">(</span>m <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">||</span> i <span class="sy0">&lt;=</span> list<span class="br0">[</span>m <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
         <span class="br0">{</span>
             list<span class="br0">[</span>m<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
             func<span class="br0">(</span>n <span class="sy0">-</span> i<span class="sy0">,</span> m <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
    <span class="br0">}</span>
&nbsp;
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> n<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">;</span>
	func<span class="br0">(</span>n<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>10. Which of the following correctly represents the code to print partitions of a number?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">int</span> print<span class="br0">[</span><span class="nu0">200</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">void</span> partitn<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> k<span class="sy0">,</span><span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
&nbsp;
	<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>idx<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
			cout<span class="sy0">&lt;&lt;</span>print<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">&lt;&lt;</span><span class="st0">" "</span><span class="sy0">;</span>
		cout<span class="sy0">&lt;&lt;</span>endl<span class="sy0">;</span>
	        <span class="kw1">return</span> <span class="sy0">;</span>
        <span class="br0">}</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>k<span class="sy0">;</span>i<span class="sy0">&gt;</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">--</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>i<span class="sy0">&gt;</span>n<span class="br0">)</span><span class="kw1">continue</span><span class="sy0">;</span> 
		print<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">=</span>i<span class="sy0">;</span>					 
		partitn<span class="br0">(</span>n<span class="sy0">-</span>i<span class="sy0">,</span>i<span class="sy0">,</span>idx<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	cin<span class="sy0">&gt;&gt;</span>n<span class="sy0">;</span>
	partitn<span class="br0">(</span>n<span class="sy0">,</span>n<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Partitions differing in order are considered to be same. Thus 2 1 and 1 2 are considered to be same when we generate partitions of integer 3.</i><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">int</span> print<span class="br0">[</span><span class="nu0">200</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">void</span> partitn<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> k<span class="sy0">,</span><span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>idx<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
			cout<span class="sy0">&lt;&lt;</span>print<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">&lt;&lt;</span><span class="st0">" "</span><span class="sy0">;</span>
		cout<span class="sy0">&lt;&lt;</span>endl<span class="sy0">;</span>
	        <span class="kw1">return</span> <span class="sy0">;</span>
        <span class="br0">}</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>k<span class="sy0">;</span>i<span class="sy0">&gt;</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">--</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">if</span><span class="br0">(</span>i<span class="sy0">&gt;</span>n<span class="br0">)</span><span class="kw1">continue</span><span class="sy0">;</span> 
		print<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">=</span>i<span class="sy0">;</span>					 
		partitn<span class="br0">(</span>n<span class="sy0">-</span>i<span class="sy0">,</span>i<span class="sy0">,</span>idx<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	cin<span class="sy0">&gt;&gt;</span>n<span class="sy0">;</span>
	partitn<span class="br0">(</span>n<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">int</span> print<span class="br0">[</span><span class="nu0">200</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">void</span> partitn<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> k<span class="sy0">,</span><span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>idx<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
			cout<span class="sy0">&lt;&lt;</span>print<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">&lt;&lt;</span><span class="st0">" "</span><span class="sy0">;</span>
		cout<span class="sy0">&lt;&lt;</span>endl<span class="sy0">;</span>
	        <span class="kw1">return</span> <span class="sy0">;</span>
        <span class="br0">}</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>k<span class="sy0">;</span>i<span class="sy0">&gt;</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">--</span><span class="br0">)</span>
        <span class="br0">{</span>
		print<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">=</span>i<span class="sy0">;</span>					 
		partitn<span class="br0">(</span>n<span class="sy0">-</span>i<span class="sy0">,</span>i<span class="sy0">,</span>idx<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	cin<span class="sy0">&gt;&gt;</span>n<span class="sy0">;</span>
	partitn<span class="br0">(</span>n<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">int</span> print<span class="br0">[</span><span class="nu0">200</span><span class="br0">]</span><span class="sy0">;</span>
<span class="kw4">void</span> partitn<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> k<span class="sy0">,</span><span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>	
	<span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
        <span class="br0">{</span>
		<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>idx<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
			cout<span class="sy0">&lt;&lt;</span>print<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">&lt;&lt;</span><span class="st0">" "</span><span class="sy0">;</span>
		cout<span class="sy0">&lt;&lt;</span>endl<span class="sy0">;</span>
	        <span class="kw1">return</span> <span class="sy0">;</span>
        <span class="br0">}</span>
	<span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span>k<span class="sy0">;</span>i<span class="sy0">&gt;</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">--</span><span class="br0">)</span>      
        <span class="br0">{</span> 
		print<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">=</span>i<span class="sy0">;</span>					 
		partitn<span class="br0">(</span>n<span class="sy0">-</span>i<span class="sy0">,</span>i<span class="sy0">,</span>idx<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">int</span> n<span class="sy0">;</span>
	cin<span class="sy0">&gt;&gt;</span>n<span class="sy0">;</span>
	partitn<span class="br0">(</span>n<span class="sy0">,</span>n<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>1. What is meant by the power set of a set?<br>
a) subset of all sets<br>
b) set of all subsets<br>
c) set of particular subsets<br>
d) empty set<br>
</b></p><i>Answer: b<br>
Explanation: Power set of a set is defined as the set of all subsets. Ex- S={1,2} then P={{},{1},{2}{1,2}}.</i><p><b>2. Number of elements in the power set of set S={1,2,3} will be?<br>
a) 2<br>
b) 4<br>
c) 6<br>
d) 8<br>
</b></p><i>Answer: d<br>
Explanation: Power set of a set is defined as the set of all subsets. Number of elements in the power set of a set having n elements is given as 2<sup>n</sup>. Thus, here number of elements will be 2<sup>3</sup>=8.</i><p><b>3. Number of elements in the power set of set S={1,2,2} will be?<br>
a) 2<br>
b) 4<br>
c) 6<br>
d) 8<br>
</b></p><i>Answer: c<br>
Explanation: For finding the number of elements in the power set of the given set we need to remove duplicates. So we will be left with 6 unique elements which will be P={{},{1},{2},{1,2},{2,2},{1,2,2}}.</i><p><b>4. Choose the correct statement for the following code segment?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">bool check <span class="br0">(</span><span class="kw4">int</span> N<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span> N <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> i<span class="br0">)</span> <span class="br0">)</span>
        <span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span>
    <span class="kw1">else</span>
        <span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) function returns true if N is odd<br>
b) function returns true if N is even<br>
c) function returns true if ith bit of N is set<br>
d) function returns false if ith bit of N is set<br>
</b></p><i>Answer: c<br>
Explanation: As the value of 1 &lt;&lt; i is 2<sup>i</sup> so the given function checks whether the i<sup>th</sup> bit of N is set or not. If it is set then the function returns true.</i><p><b>5. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;math.h&gt; </span>
<span class="kw4">void</span> PowerSet<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> set_size<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">unsigned</span> <span class="kw4">int</span> pow_size <span class="sy0">=</span> <span class="kw3">pow</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span> set_size<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> count<span class="sy0">,</span> j<span class="sy0">;</span> 	
	<span class="kw1">for</span><span class="br0">(</span>count <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> count <span class="sy0">&lt;</span> pow_size<span class="sy0">;</span> count<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	     <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> set_size<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
	     <span class="br0">{</span> 
&nbsp;
		<span class="kw1">if</span><span class="br0">(</span>count <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>j<span class="br0">)</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%c"</span><span class="sy0">,</span> set<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	     <span class="br0">}</span> 
	     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">","</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> strset<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="st0">'a'</span><span class="sy0">,</span><span class="st0">'b'</span><span class="sy0">,</span><span class="st0">'c'</span><span class="br0">}</span><span class="sy0">;</span> 
	PowerSet<span class="br0">(</span>strset<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) a,b,ab,c,ac,bc,abc,<br>
b) a,b,ab,c,ac,bc,abc<br>
c) ,a,b,ab,c,ac,bc,abc,<br>
d) ,abc,bc,ac,c,ab,b,a,<br>
</b></p><i>Answer: c<br>
Explanation: The given code prints the elements of power set of the given set strset[]. It uses binary counter of appropriate length in order to print corresponding subsets of the given set.</i><p><b>6. What will be the time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;math.h&gt; </span>
<span class="kw4">void</span> PowerSet<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> set_size<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">unsigned</span> <span class="kw4">int</span> pow_size <span class="sy0">=</span> <span class="kw3">pow</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span> set_size<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> count<span class="sy0">,</span> j<span class="sy0">;</span> 	
	<span class="kw1">for</span><span class="br0">(</span>count <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> count <span class="sy0">&lt;</span> pow_size<span class="sy0">;</span> count<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	     <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> set_size<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
	     <span class="br0">{</span> 
&nbsp;
		<span class="kw1">if</span><span class="br0">(</span>count <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>j<span class="br0">)</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%c"</span><span class="sy0">,</span> set<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	     <span class="br0">}</span> 
	     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">","</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> strset<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="st0">'a'</span><span class="sy0">,</span><span class="st0">'b'</span><span class="sy0">,</span><span class="st0">'c'</span><span class="br0">}</span><span class="sy0">;</span> 
	PowerSet<span class="br0">(</span>strset<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n 2<sup>n</sup>)<br>
b) O(n<sup>2</sup>)<br>
c) O(n log n)<br>
d) O(2<sup>n</sup>) (n is the size of set)<br>
</b></p><i>Answer: a<br>
Explanation: In the given code we have a nested for loop. In this loop the outer loop runs 2<sup>n</sup> times and the inner loop runs n times. So the overall time complexity becomes n2<sup>n</sup>.</i><p><b>7. What will be the auxiliary space requirement of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;math.h&gt; </span>
<span class="kw4">void</span> PowerSet<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>set<span class="sy0">,</span> <span class="kw4">int</span> set_size<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">unsigned</span> <span class="kw4">int</span> pow_size <span class="sy0">=</span> <span class="kw3">pow</span><span class="br0">(</span><span class="nu0">2</span><span class="sy0">,</span> set_size<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> count<span class="sy0">,</span> j<span class="sy0">;</span> 	
	<span class="kw1">for</span><span class="br0">(</span>count <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> count <span class="sy0">&lt;</span> pow_size<span class="sy0">;</span> count<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	<span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> set_size<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 		
		<span class="kw1">if</span><span class="br0">(</span>count <span class="sy0">&amp;</span> <span class="br0">(</span><span class="nu0">1</span><span class="sy0">&lt;&lt;</span>j<span class="br0">)</span><span class="br0">)</span> 
			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%c"</span><span class="sy0">,</span> set<span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">","</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">char</span> strset<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="st0">'a'</span><span class="sy0">,</span><span class="st0">'b'</span><span class="sy0">,</span><span class="st0">'c'</span><span class="br0">}</span><span class="sy0">;</span> 
	PowerSet<span class="br0">(</span>strset<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The given code prints the elements of power set of the given set strset[]. As this code does not require any extra space for generating the output so its auxiliary space requirement will be O(1).</i><p><b>a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(2<sup>n</sup>) (n is the size of set)<br>
</b></p><i>Answer: c<br>
Explanation: In the correct version we are taking two cases for each element. In the first case the element is included in the subset and in the second case it is not included. So in this manner, we find all the subsets of the given set.</i><p><b>8. Which of the following code prints the power set of a given set?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
        <span class="br0">{</span> 
		cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">,</span> curr <span class="sy0">+</span> str<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"ab"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
        <span class="br0">{</span> 
		cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> curr <span class="sy0">+</span> str<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"ab"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
        <span class="br0">{</span> 
		cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 	
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> curr <span class="sy0">+</span> str<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"ab"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> <span class="br0">{</span> 
		cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">,</span> curr<span class="sy0">+</span>str<span class="br0">)</span><span class="sy0">;</span> 
	Set<span class="br0">(</span>str<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"ab"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: In case when duplicates are present in the set then the number of elements in the power set decreases. It is because we remove subsets with identical elements.</i><p><b>10. What of the following code prints the power set of a given set?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> ind <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>ind <span class="sy0">==</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> <span class="st0">","</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> ind<span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		curr <span class="sy0">+=</span> str<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	    Set<span class="br0">(</span>str<span class="sy0">,</span> i<span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
		curr.<span class="me1">erase</span><span class="br0">(</span>curr.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"abc"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> ind <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>ind <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> <span class="st0">","</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> ind<span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		curr <span class="sy0">+=</span> str<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	    Set<span class="br0">(</span>str<span class="sy0">,</span> i<span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
		curr.<span class="me1">erase</span><span class="br0">(</span>curr.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"abc"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> ind <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>ind <span class="sy0">==</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 
	cout <span class="sy0">&lt;&lt;</span> curr <span class="sy0">&lt;&lt;</span> <span class="st0">","</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> ind<span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		curr <span class="sy0">+=</span> str<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	    Set<span class="br0">(</span>str<span class="sy0">,</span> i<span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
		curr.<span class="me1">erase</span><span class="br0">(</span>curr.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">-</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"abc"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Set<span class="br0">(</span>string str<span class="sy0">,</span> <span class="kw4">int</span> ind <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> 
			string curr <span class="sy0">=</span> <span class="st0">""</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> str.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">if</span> <span class="br0">(</span>ind <span class="sy0">==</span> n<span class="br0">)</span> 
		<span class="kw1">return</span><span class="sy0">;</span> 	
	cout <span class="sy0">&lt;&lt;</span> str <span class="sy0">&lt;&lt;</span> <span class="st0">","</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> ind<span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
        <span class="br0">{</span> 
		curr <span class="sy0">+=</span> str<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
	    Set<span class="br0">(</span>str<span class="sy0">,</span> i<span class="sy0">,</span> curr<span class="br0">)</span><span class="sy0">;</span> 
		curr.<span class="me1">erase</span><span class="br0">(</span>curr.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string str <span class="sy0">=</span> <span class="st0">"abc"</span><span class="sy0">;</span> 
    Set<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: In the correct version of the code we are fixing a prefix and generate all corresponding subsets. Then after all subsets with a prefix are generated, we replace last character with one of the remaining character.</i><p><b>1. Which one of the following problem types does inclusion-exclusion principle belong to?<br>
a) Numerical problems<br>
b) Graph problems<br>
c) String processing problems<br>
d) Combinatorial problems<br>
</b></p><i>Answer: d<br>
Explanation: Inclusion-Exclusion principle is a kind of combinatorial problem. It is a counting technique to obtain the number of elements present in sets( two, three , etc.,).</i><p><b>2. Which of the following is a correct representation of inclusion exclusion principle (|A,B| represents intersection of sets A,B)?<br>
a) |A U B|=|A|+|B|-|A,B|<br>
b) |A,B|=|A|+|B|-|A U B|<br>
c) |A U B|=|A|+|B|+|A,B|<br>
d) |A,B|=|A|+|B|+|A U B|<br>
</b></p><i>Answer: a<br>
Explanation: The formula for computing the union of two sets according to inclusion-exclusion principle is |A U B|=|A|+|B|-|A,B| where |A,B| represents the intersection of the sets A and B.</i><p><b>3. ____________ is one of the most useful principles of enumeration in combinationatorics and discrete probability.<br>
a) Inclusion-exclusion principle<br>
b) Quick search algorithm<br>
c) Euclid’s algorithm<br>
d) Set theory<br>
</b></p><i>Answer: a<br>
Explanation: Inclusion-exclusion principle serves as one of the most useful principles of enumeration in combinationatorics and discrete probability because it provides simple formula for generalizing results.</i><p><b>4. Which of the following is not an application of inclusion-exclusion principle?<br>
a) Counting intersections<br>
b) Graph coloring<br>
c) Matching of bipartite graphs<br>
d) Maximum flow problem<br>
</b></p><i>Answer: d<br>
Explanation: Counting intersections, Graph coloring and Matching of bipartite graphs are all examples of inclusion-exclusion principle whereas maximum flow problem is solved using Ford-Fulkerson algorithm.</i><p><b>5. Who invented the concept of inclusion-exclusion principle?<br>
a) Abraham de Moivre<br>
b) Daniel Silva<br>
c) J.J. Sylvester<br>
d) Sieve<br>
</b></p><i>Answer: a<br>
Explanation: The concept of inclusion- exclusion principle was initially invented by Abraham de Moivre in 1718 but it was published first by Daniel Silva in his paper in 1854.</i><p><b>8. Which of the following statement is incorrect with respect to generalizing the solution using the inclusion-exclusion principle?<br>
a) including cardinalities of sets<br>
b) excluding cardinalities of pairwise intersections<br>
c) excluding cardinalities of triple-wise intersections<br>
d) excluding cardinalities of quadraple-wise intersections<br>
</b></p><i>Answer: b<br>
Explanation: According to inclusion-exclusion principle, a n-tuple wise intersection is included if n is odd and excluded if n is even.</i><p><b>10. Using the inclusion-exclusion principle, find the number of integers from a set of 1-100 that are not divisible by 2, 3 and 5.<br>
a) 22<br>
b) 25<br>
c) 26<br>
d) 33<br>
</b></p><i>Answer: a<br>
Explanation: The formula for computing the union of three sets using inclusion-exclusion principle is|A U B U C|=|A|+|B|+|C|-|A,B|-|A,C|-|B,C|+|A, B,C|  where |A,B|, |B,C|, |A,C|, |A,B,C| represents the intersection of the sets A and B, B and C, A and C, A, B and C respectively.</i><p><b>11. ____________ is an arithmetic function that calculates the total number of positive integers less than or equal to some number n, that are relatively prime to n.<br>
a) Euler’s phi function<br>
b) Euler’s omega function<br>
c) Cauchy’s totient function<br>
d) Legrange’s function<br>
</b></p><i>Answer: c<br>
Explanation: According to inclusion-exclusion principle, an intersection is included if the intersecting elements are odd and excluded, if the intersecting elements are even. Hence triple-wise intersections should be included.</i><p><b>12. Let A={1,2,3} B={2,3,4} C={1,3,5} D={2,3}. Find the cardinality of sum of all the sets.<br>
a) 6<br>
b) 5<br>
c) 4<br>
d) 7<br>
</b></p><i>Answer: a<br>
Explanation: The application of counting intersections can be fulfiled if and only if it is combined with De Morgan laws to count the cardinality of intersection of sets.</i><p><b>1. The shortest distance between a line and a point is achieved when?<br>
a) a line is drawn at 90 degrees to the given line from the given point<br>
b) a line is drawn at 180 degrees to the given line from the given point<br>
c) a line is drawn at 60 degrees to the given line from the given point<br>
d) a line is drawn at 270 degrees to the given line from the given point<br>
</b></p><i>Answer: a<br>
Explanation: The shortest distance between a line and a point is achieved when a line is drawn at 90 degrees to the given line from the given point. </i><p><b>2. What is the shortest distance between the line given by ax + by + c = 0 and the point (x1,y1)?<br>
a) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2a" width="82" height="51" class=" size-full wp-image-241912" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2082%2051%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2a" width="82" height="51" class="lazyload  size-full wp-image-241912"></a><br>
b) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2b.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2b.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2b" width="83" height="50" class=" size-full wp-image-241913" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2083%2050%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2b.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2b" width="83" height="50" class="lazyload  size-full wp-image-241913"></a><br>
c) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2c.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2c.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2c" width="72" height="50" class=" size-full wp-image-241914" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2072%2050%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2c.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2c" width="72" height="50" class="lazyload  size-full wp-image-241914"></a><br>
d) ax1+by1+c<br>
</b></p><i>Answer: a<br>
Explanation: The shortest distance between a line and a point is given by the formula (ax1+by1+c)/(√a<sup>2</sup>+b<sup>2</sup>). This formula can be derived using the formula of area of a triangle.</i><p><b>3. What is the shortest distance between the line given by -2x + 3y + 4 = 0 and the point (5,6)?<br>
a) 4.5 units<br>
b) 5.4 units<br>
c) 4.3 units<br>
d) 3.3 units<br>
</b></p><i>Answer: d<br>
Explanation: The shortest distance between a line and a point is given by the formula (ax1+by1+c)/(√a<sup>2</sup>+b<sup>2</sup>). Using this formula we get the answer 3.3 units.</i><p><b>4. What is the general formula for finding the shortest distance between two parallel lines given by ax+by+c1=0 and ax+by+c2=0?<br>
a) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2a" width="82" height="51" class=" size-full wp-image-241912" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2082%2051%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q2a.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q2a" width="82" height="51" class="lazyload  size-full wp-image-241912"></a><br>
b) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4b.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4b.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q4b" width="70" height="49" class=" size-full wp-image-241915" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2070%2049%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4b.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q4b" width="70" height="49" class="lazyload  size-full wp-image-241915"></a><br>
c) <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4c.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4c.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q4c" width="71" height="57" class=" size-full wp-image-241916" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2071%2057%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/line-point-distance-multiple-choice-questions-answers-mcqs-q4c.png" alt="line-point-distance-multiple-choice-questions-answers-mcqs-q4c" width="71" height="57" class="lazyload  size-full wp-image-241916"></a><br>
d) c1+c2<br>
</b></p><i>Answer: b<br>
Explanation: The general formula for finding the shortest distance between two parallel lines given by ax+by+c1 and ax+by+c2 is (c1-c2)/(√a<sup>2</sup>+b<sup>2</sup>). We can find this by considering the distance of any one point on one of the line to the other line.</i><p><b>5. What is the distance between the lines 3x-4y+7=0 and 3x-4y+5=0?<br>
a) 1 unit<br>
b) 0.5 unit<br>
c) 0.8 unit<br>
d) 0.4 unit<br>
</b></p><i>Answer: d<br>
Explanation: As the given lines are parallel so the distance between them can be calculated by using the formula (c1-c2)/(√a<sup>2</sup>+b<sup>2</sup>). So we get the distance as 0.4 unit.</i><p><b>6. What will be the slope of the line given by ax + by + c = 0?<br>
a) -a/b<br>
b) -b/a<br>
c) -c/a<br>
d) a/c<br>
</b></p><i>Answer: a<br>
Explanation: The slope of a line given by the equation ax + by + c=0 has the slope of -a/b. So two lines having the same ratio of the coefficient of x and y will be parallel to each other.</i><p><b>7. What will be the slope of the line given by 10x + 5y + 8=0?<br>
a) -5<br>
b) -2<br>
c) -1.25<br>
d) 5<br>
</b></p><i>Answer: b<br>
Explanation: The slope of a line given by the equation ax + by + c=0 has the slope of -a/b. So the slope of the given line will be -2.</i><p><b>8. What will be the co-ordinates of foot of perpendicular line drawn from the point (-1,3) to the line 3x-4y-16=0?<br>
a) (1/5,2/5)<br>
b) (2/25,5/25)<br>
c) (68/25,-49/25)<br>
d) (-49/25,68/25)<br>
</b></p><i>Answer: c<br>
Explanation: The foot of perpendicular can be found by equating the distance between the two points and the distance between point and line. This is found to be (68/25,-49/25).</i><p><b>9. Which of the following is used to find the absolute value of the argument in C++?<br>
a) abs()<br>
b) fabs()<br>
c) mod()<br>
d) ab()<br>
</b></p><i>Answer: b<br>
Explanation: In C++ the absolute value of an argument can be found by using the function fabs(). It is available under the header file math.h.</i><p><b>10. What will be the slope of the line perpendicular to the line 6x-3y-16=0?<br>
a) 1/2<br>
b) -1/2<br>
c) 2<br>
d) -2<br>
</b></p><i>Answer: b<br>
Explanation: For two lines to be perpendicular the product of their slopes should be equal to -1. So as the slope of given line is 2 so the slope of line perpendicular to it will be -1/2.</i><p><b>11. Find the output of the following code.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;math.h&gt; </span>
<span class="co2">#include&lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
<span class="kw4">void</span> distance<span class="br0">(</span><span class="kw4">float</span> x<span class="sy0">,</span> <span class="kw4">float</span> y<span class="sy0">,</span> <span class="kw4">float</span> a<span class="sy0">,</span> <span class="kw4">float</span> b<span class="sy0">,</span> <span class="kw4">float</span> c<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">float</span> d <span class="sy0">=</span> <span class="kw3">fabs</span><span class="br0">(</span><span class="br0">(</span>a <span class="sy0">*</span> x <span class="sy0">+</span> b <span class="sy0">*</span> y <span class="sy0">+</span> c<span class="br0">)</span><span class="br0">)</span> <span class="sy0">/</span> <span class="br0">(</span><span class="kw3">sqrt</span><span class="br0">(</span>a <span class="sy0">*</span> a <span class="sy0">+</span> b <span class="sy0">*</span> b<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	cout<span class="sy0">&lt;&lt;</span>d<span class="sy0">;</span>
	<span class="kw1">return</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">float</span> x <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">float</span> y <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">3</span><span class="sy0">;</span> 
	<span class="kw4">float</span> a <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span> 
	<span class="kw4">float</span> b <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">float</span> c <span class="sy0">=</span> <span class="sy0">-</span> <span class="nu0">4</span><span class="sy0">;</span> 
	distance<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">,</span> a<span class="sy0">,</span> b<span class="sy0">,</span> c<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2.8<br>
b) 1.8<br>
c) 1.4<br>
d) 2.4<br>
</b></p><i>Answer: c<br>
Explanation: The given code calculates the shortest distance between line and a point. So the output will be 1.4.</i><p><b>1. Which of the following areas do closest pair problem arise?<br>
a) computational geometry<br>
b) graph colouring problems<br>
c) numerical problems<br>
d) string matching<br>
</b></p><i>Answer: a<br>
Explanation: Closest pair problem arises in two most important areas- computational geometry and operational research.</i><p><b>2. Which approach is based on computing the distance between each pair of distinct points and finding a pair with the smallest distance?<br>
a) Brute force<br>
b) Exhaustive search<br>
c) Divide and conquer<br>
d) Branch and bound<br>
</b></p><i>Answer: a<br>
Explanation: Brute force is a straight forward approach that solves closest pair problem using that algorithm.</i><p><b>3. What is the runtime efficiency of using brute force technique for the closest pair problem?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(N<sup>3</sup>  log N)<br>
</b></p><i>Answer: c<br>
Explanation: The efficiency of closest pair algorithm by brute force technique is mathematically found to be O(N<sup>2</sup>).</i><p><b>4. The most important condition for which closest pair is calculated for the points (p<sub>i</sub>, p<sub>j</sub>) is?<br>
a) i&gt;j<br>
b) i!=j<br>
c) i=j<br>
d) i&lt;j<br>
</b></p><i>Answer: d<br>
Explanation: To avoid computing the distance between the same pair of points twice, we consider only the pair of points (p<sub>i</sub>, p<sub>j</sub>) for which i&lt;j.</i><p><b>5. What is the basic operation of closest pair algorithm using brute force technique?<br>
a) Euclidean distance<br>
b) Radius<br>
c) Area<br>
d) Manhattan distance<br>
</b></p><i>Answer: a<br>
Explanation: The basic operation of closest pair algorithm is Euclidean distance and its formula is given by d=√(x<sub>i</sub>-x<sub>j</sub>)<sup>2</sup>+(y<sub>i</sub>-y<sub>j</sub>)<sup>2</sup>.</i><p><b>6. Which of the following is similar to Euclidean distance?<br>
a) Manhattan distance<br>
b) Pythagoras metric<br>
c) Chebyshev distance<br>
d) Heuristic distance<br>
</b></p><i>Answer: b<br>
Explanation: In older times, Euclidean distance metric is also called a Pythagoras metric which is the length of the line segment connecting two points.</i><p><b>9. What is the optimal time required for solving the closest pair problem using divide and conquer approach?<br>
a) O(N)<br>
b) O(log N)<br>
c) O(N log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Brute force is a straight forward approach to solve critical problems. Here, we use brute force technique to find the closest distance between p1 and p2.</i><p><b>10. In divide and conquer, the time is taken for merging the subproblems is?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: a<br>
Explanation: Manhattan distance is an alternative way to calculate distance. It is the distance between two points measured along axes at right angles.</i><p><b>1. Cross product is a mathematical operation performed between ________________<br>
a) 2 scalar numbers<br>
b) a scalar and a vector<br>
c) 2 vectors<br>
d) any 2 numbers<br>
</b></p><i>Answer: c<br>
Explanation: Cross product is a mathematical operation that is performed on 2 vectors in a 3D plane. It has many applications in computer programming and physics.</i><p><b>2. Cross product is also known as?<br>
a) scalar product<br>
b) vector product<br>
c) dot product<br>
d) multiplication<br>
</b></p><i>Answer: b<br>
Explanation: Cross product is also known as a vector product. It is a mathematical operation that is performed on 2 vectors in 3D plane.</i><p><b>3. What is the magnitude of resultant of cross product of two parallel vectors a and b?<br>
a) |a|.|b|<br>
b) |a|.|b| cos(180)<br>
c) |a|.|b| sin(180)<br>
d) 1<br>
</b></p><i>Answer: c<br>
Explanation: The resultant of cross product of 2 parallel vectors is always 0 as the angle between them is 0 or 180 degrees. So the answer is |a|.|b| sin(180).</i><p><b>4. What is the general formula for finding the magnitude of the cross product of two vectors a and b with angle θ between them?<br>
a) |a|.|b|<br>
b) |a|.|b| cos(θ)<br>
c) |a|.|b| sin(θ)<br>
d) |a|.|b| tan(θ)<br>
</b></p><i>Answer: c<br>
Explanation: The general formula for finding the magnitude of cross product of two vectors is |a|.|b| sin(θ). Its direction is perpendicular to the plane containing a and b.</i><p><b>6. Which of the following equals the a x b ( a and b are two vectors)?<br>
a) – (a x b)<br>
b) a.b<br>
c) b x a<br>
d) – (b x a)<br>
</b></p><i>Answer: a<br>
Explanation: The concept of cross product find its application in the field of computer graphics. It can be used to find the winding of polygon about a point.</i><p><b>7. Cross product of two vectors can be used to find?<br>
a) area of rectangle<br>
b) area of square<br>
c) area of parallelogram<br>
d) perimeter of rectangle<br>
</b></p><i>Answer: d<br>
Explanation: The vector product a x b is equal to – (b x a). The minus sign shows that these vectors have opposite directions.</i><p><b>8. The resultant vector from the cross product of two vectors is _____________<br>
a) perpendicular to any one of the two vectors involved in cross product<br>
b) perpendicular to the plane containing both vectors<br>
c) parallel to to any one of the two vectors involved in cross product<br>
d) parallel to the plane containing both vectors<br>
</b></p><i>Answer: c<br>
Explanation: Cross product of two vectors can be used to find the area of parallelogram. For this, we need to consider the vectors as the adjacent sides of the parallelogram.</i><p><b>9. What will be the cross product of the vectors 2i + 3j + k and 3i + 2j + k?<br>
a) i + 2j + k<br>
b) 2i + 3j + k<br>
c) i + j – 5k<br>
d) 2i – j – 5k<br>
</b></p><i>Answer: b<br>
Explanation: The resultant vector from the cross product of two vectors is perpendicular to the plane containing both vectors. In other words, it should be perpendicular to both the vectors involved in the cross product.</i><p><b>10. What will be the cross product of the vectors 2i + 3j + k and 6i + 9j + 3k?<br>
a) i + 2j + k<br>
b) i – j – 5k<br>
c) 0<br>
d) 2i – j – 5k<br>
</b></p><i>Answer: c<br>
Explanation: We can find the cross product of the given vectors by solving the determinant.<br>
  <a href="https://www.sanfoundry.com/wp-content/uploads/2019/06/cross-product-multiple-choice-questions-answers-mcqs-q9.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2019/06/cross-product-multiple-choice-questions-answers-mcqs-q9.png" alt="cross-product-multiple-choice-questions-answers-mcqs-q9" width="58" height="84" class="alignnone size-full wp-image-241920" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2058%2084%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2019/06/cross-product-multiple-choice-questions-answers-mcqs-q9.png" alt="cross-product-multiple-choice-questions-answers-mcqs-q9" width="58" height="84" class="lazyload alignnone size-full wp-image-241920"></a></i><p><b>11. Find the output of the following code.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> crossP<span class="br0">(</span><span class="kw4">int</span> A<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> B<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> cross<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span> 
<span class="br0">{</span> 
	cross<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> A<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">-</span> A<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	cross<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> A<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">-</span> A<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
	cross<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> A<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">-</span> A<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> B<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> A<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">4</span> <span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> B<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">2</span> <span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> cross<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">;</span> 
	crossP<span class="br0">(</span>A<span class="sy0">,</span> B<span class="sy0">,</span> cross<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">3</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> cross<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 2 5<br>
b) -1 -5 -3<br>
c) -6 -8 -1<br>
d) -8 -6 -1<br>
</b></p><i>Answer: c<br>
Explanation: The given vectors are parallel to each other. The cross product of parallel vectors is 0 because sin(0) is 0.</i><p><b>12. Which of the following operation will give a vector that is perpendicular to both vectors a and b?<br>
a) a x b<br>
b) a.b<br>
c) b x a<br>
d) both a x b and b x a<br>
</b></p><i>Answer: d<br>
Explanation: The given code calculates the cross product of the vectors stored in arrays A and B respectively. So the output will be -8 -6 -1.</i><p><b>1. ___________ is a method of constructing a smallest polygon out of n given points.<br>
a) closest pair problem<br>
b) quick hull problem<br>
c) path compression<br>
d) union-by-rank<br>
</b></p><i>Answer: b<br>
Explanation: Quick hull is a method of constructing a smallest convex polygon out of n given points in a plane.</i><p><b>2. What is the other name for quick hull problem?<br>
a) convex hull<br>
b) concave hull<br>
c) closest pair<br>
d) path compression<br>
</b></p><i>Answer: a<br>
Explanation: The other name for quick hull problem is convex hull problem whereas the closest pair problem is the problem of finding the closest distance between two points.</i><p><b>3. How many approaches can be applied to solve quick hull problem?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: Most commonly, two approaches are adopted to solve quick hull problem- brute force approach and divide and conquer approach.</i><p><b>4. What is the average case complexity of a quick hull algorithm?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: b<br>
Explanation: The average case complexity of quickhull algorithm using divide and conquer approach is mathematically found to be O(N log N).</i><p><b>5. What is the worst case complexity of quick hull?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: c<br>
Explanation: The worst case complexity of quickhull algorithm using divide and conquer approach is mathematically found to be O(N<sup>2</sup>).</i><p><b>7. Which of the following statement is not related to quickhull algorithm?<br>
a) finding points with minimum and maximum coordinates<br>
b) dividing the subset of points by a line<br>
c) eliminating points within a formed triangle<br>
d) finding the shortest distance between two points<br>
</b></p><i>Answer: b<br>
Explanation: The above diagram is a depiction of convex hull, also known as quick hull, since it encloses n points into a convex polygon.</i><p><b>9. To which type of problems does quick hull belong to?<br>
a) numerical problems<br>
b) computational geometry<br>
c) graph problems<br>
d) string problems<br>
</b></p><i>Answer: d<br>
Explanation: Finding the shortest distance between two points belongs to closest pair algorithm while the rest is quickhull.</i><p><b>10. Which of the following algorithms is similar to a quickhull algorithm?<br>
a) merge sort<br>
b) shell sort<br>
c) selection sort<br>
d) quick sort<br>
</b></p><i>Answer: a<br>
Explanation: It is proved that the quick hull algorithm runs faster if the input uses non-extreme points and also, if it uses less memory.</i><p><b>11. Who formulated quick hull algorithm?<br>
a) Eddy<br>
b) Andrew<br>
c) Chan<br>
d) Graham<br>
</b></p><i>Answer: b<br>
Explanation: Quick hull problem and closest pair algorithms are some of the examples of computational problems.</i><p><b>12. The time is taken to find the ‘n’ points that lie in a convex quadrilateral is?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: d<br>
Explanation: Quickhull algorithm is similar to a quick sort algorithm with respect to the run time average case and worst case efficiencies.</i><p><b>1. Chan’s algorithm is used for computing _________<br>
a) Closest distance between two points<br>
b) Convex hull<br>
c) Area of a polygon<br>
d) Shortest path between two points<br>
</b></p><i>Answer: b<br>
Explanation: Chan’s algorithm is an output-sensitive algorithm used to compute the convex hull set of n points in a 2D or 3D space. Closest pair algorithm is used to compute the closest distance between two points.</i><p><b>2. What is the running time of Chan’s algorithm?<br>
a) O(log n)<br>
b) O(n log n)<br>
c) O(n log h)<br>
d) O(log h)<br>
</b></p><i>Answer: c<br>
Explanation: The running time of Chan’s algorithm is calculated to be O(n log h) where h is the number of vertices of the convex hull.</i><p><b>3. Who formulated Chan’s algorithm?<br>
a) Timothy<br>
b) Kirkpatrick<br>
c) Frank Nielsen<br>
d) Seidel<br>
</b></p><i>Answer: a<br>
Explanation: Chan’s algorithm was formulated by Timothy Chan. Kirkpatrick and Seidel formulated the Kirkpatrick-Seidel algorithm. Frank Nielsen developed a paradigm relating to Chan’s algorithm.</i><p><b>5. Which of the following is called the “ultimate planar convex hull algorithm”?<br>
a) Chan’s algorithm<br>
b) Kirkpatrick-Seidel algorithm<br>
c) Gift wrapping algorithm<br>
d) Jarvis algorithm<br>
</b></p><i>Answer: a<br>
Explanation: The O(n log h) running time of Chan’s algorithm is obtained by combining the running time of Graham’s scan [O(n log n)] and Jarvis match [O(nh)].</i><p><b>6. Which of the following algorithms is the simplest?<br>
a) Chan’s algorithm<br>
b) Kirkpatrick-Seidel algorithm<br>
c) Gift wrapping algorithm<br>
d) Jarvis algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Kirkpatrick-Seidel algorithm is called as the ultimate planar convex hull algorithm. Its running time is the same as that of Chan’s algorithm (i.e.) O(n log h).</i><p><b>7. What is the running time of Hershberger algorithm?<br>
a) O(log n)<br>
b) O(n log n)<br>
c) O(n log h)<br>
d) O(log h)<br>
</b></p><i>Answer: a<br>
Explanation: Chan’s algorithm is very practical for moderate sized problems whereas Kirkpatrick-Seidel algorithm is not. Although, they both have the same running time. Gift wrapping algorithm is a non-output sensitive algorithm and has a longer running time.</i><p><b>8. Which of the following statements is not a part of Chan’s algorithm?<br>
a) eliminate points not in the hull<br>
b) recompute convex hull from scratch<br>
c) merge previously calculated convex hull<br>
d) reuse convex hull from the previous iteration<br>
</b></p><i>Answer: b<br>
Explanation: Hershberger’s algorithm is an output sensitive algorithm whose running time was originally O(n log n). He used Chan’s algorithm to speed up to O(n log h) where h is the number of edges.</i><p><b>9. Which of the following factors account more to the cost of Chan’s algorithm?<br>
a) computing a single convex hull<br>
b) locating points that constitute a hull<br>
c) computing convex hull in groups<br>
d) merging convex hulls<br>
</b></p><i>Answer: b<br>
Explanation: Chan’s algorithm implies that the convex hulls of larger points can be arrived at by merging previously calculated convex hulls. It makes the algorithm simpler instead of recomputing every time from scratch.</i><p><b>1. Depth First Search is equivalent to which of the traversal in the Binary Trees?<br>
a) Pre-order Traversal<br>
b) Post-order Traversal<br>
c) Level-order Traversal<br>
d) In-order Traversal<br>
</b></p><i>Answer: a<br>
Explanation: In Depth First Search, we explore all the nodes aggressively to one path and then backtrack to the node. Hence, it is equivalent to the pre-order traversal of a Binary Tree.</i><p><b>2. Time Complexity of DFS is? (V – number of vertices, E – number of edges)<br>
a) O(V + E)<br>
b) O(V)<br>
c) O(E)<br>
d) O(V*E)<br>
</b></p><i>Answer: a<br>
Explanation: The Depth First Search explores every node once and every edge once (in worst case), so it’s time complexity is O(V + E).</i><p><b>3. The Data structure used in standard implementation of Breadth First Search is?<br>
a) Stack<br>
b) Queue<br>
c) Linked List<br>
d) Tree<br>
</b></p><i>Answer: a<br>
Explanation: The Depth First Search is implemented using recursion. So, stack can be used as data structure to implement depth first search.</i><p><b>4. The Depth First Search traversal of a graph will result into?<br>
a) Linked List<br>
b) Tree<br>
c) Graph with back edges<br>
d) Array<br>
</b></p><i>Answer: b<br>
Explanation: The Depth First Search will make a graph which don’t have back edges (a tree) which is known as Depth First Tree.</i><p><b>5. A person wants to visit some places. He starts from a vertex and then wants to visit every vertex till it finishes from one vertex, backtracks and then explore other vertex from same vertex. What algorithm he should use?<br>
a) Depth First Search<br>
b) Breadth First Search<br>
c) Trim’s algorithm<br>
d) Kruskal’s Algorithm<br>
</b></p><i>Answer: a<br>
Explanation: This is the definition of the Depth First Search. Exploring a node, then aggressively finding nodes till it is not able to find any node.</i><p><b>6. Which of the following is not an application of Depth First Search?<br>
a) For generating topological sort of a graph<br>
b) For generating Strongly Connected Components of a directed graph<br>
c) Detecting cycles in the graph<br>
d) Peer to Peer Networks<br>
</b></p><i>Answer: d<br>
Explanation: Depth First Search is used in the Generation of topological sorting, Strongly Connected Components of a directed graph and to detect cycles in the graph. Breadth First Search is used in peer to peer networks to find all neighbourhood nodes.</i><p><b>7. When the Depth First Search of a graph is unique?<br>
a) When the graph is a Binary Tree<br>
b) When the graph is a Linked List<br>
c) When the graph is a n-ary Tree<br>
d) When the graph is a ternary Tree<br>
</b></p><i>Answer: b<br>
Explanation: When Every node will have one successor then the Depth First Search is unique. In all other cases, when it will have more than one successor, it can choose any of them in arbitrary order.</i><p><b>8. Regarding implementation of Depth First Search using stacks, what is the maximum distance between two nodes present in the stack? (considering each edge length 1)<br>
a) Can be anything<br>
b) 0<br>
c) At most 1<br>
d) Insufficient Information<br>
</b></p><i>Answer: a<br>
Explanation: In the stack, at a time, there can be nodes which can differ in many levels. So, it can be the maximum distance between two nodes in the graph.</i><p><b>9. In Depth First Search, how many times a node is visited?<br>
a) Once<br>
b) Twice<br>
c) Equivalent to number of indegree of the node<br>
d) Thrice<br>
</b></p><i>Answer: c<br>
Explanation: In Depth First Search, we have to see whether the node is visited or not by it’s ancestor. If it is visited, we won’t let it enter it in the stack.</i><p><b>1. Which of the following data structure is used to implement DFS?<br>
a) linked list<br>
b) tree<br>
c) stack<br>
d) queue<br>
</b></p><i>Answer: c<br>
Explanation: Stack is used in the standard implementation of depth first search. It is used to store the elements which are to be explored. </i><p><b>2. Which of the following traversal in a binary tree is similar to depth first traversal?<br>
a) level order<br>
b) post order<br>
c) pre order<br>
d) in order<br>
</b></p><i>Answer: c<br>
Explanation: In DFS we keep on exploring as far as possible along each branch before backtracking. It terminates when all nodes are visited. So it is similar to pre order traversal in binary tree.</i><p><b>5. Which of the following represent the correct pseudo code for non recursive DFS algorithm?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">procedure DFS<span class="sy0">-</span>non_recursive<span class="br0">(</span>G<span class="sy0">,</span>v<span class="br0">)</span><span class="sy0">:</span>
  <span class="co1">//let St be a stack </span>
  St.<span class="me1">push</span><span class="br0">(</span>v<span class="br0">)</span>
  <span class="kw1">while</span> St is not empty
    v <span class="sy0">=</span> St.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> v is not discovered<span class="sy0">:</span>
      label v as discovered
      <span class="kw1">for</span> all adjacent vertices of v <span class="kw1">do</span>
        St.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span> <span class="co1">//a being the adjacent vertex</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">procedure DFS<span class="sy0">-</span>non_recursive<span class="br0">(</span>G<span class="sy0">,</span>v<span class="br0">)</span><span class="sy0">:</span>
  <span class="co1">//let St be a stack </span>
  St.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span>
  <span class="kw1">while</span> St is not empty
    v <span class="sy0">=</span> St.<span class="me1">push</span><span class="br0">(</span>v<span class="br0">)</span>
    <span class="kw1">if</span> v is not discovered<span class="sy0">:</span>
      label v as discovered
      <span class="kw1">for</span> all adjacent vertices of v <span class="kw1">do</span>
        St.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span> <span class="co1">//a being the adjacent vertex</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">procedure DFS<span class="sy0">-</span>non_recursive<span class="br0">(</span>G<span class="sy0">,</span>v<span class="br0">)</span><span class="sy0">:</span>
  <span class="co1">//let St be a stack </span>
  St.<span class="me1">push</span><span class="br0">(</span>v<span class="br0">)</span>
  <span class="kw1">while</span> St is not empty
    v <span class="sy0">=</span> St.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> v is not discovered<span class="sy0">:</span>
      label v as discovered
      <span class="kw1">for</span> all adjacent vertices of v <span class="kw1">do</span>
        St.<span class="me1">push</span><span class="br0">(</span>v<span class="br0">)</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">procedure DFS<span class="sy0">-</span>non_recursive<span class="br0">(</span>G<span class="sy0">,</span>v<span class="br0">)</span><span class="sy0">:</span>
  <span class="co1">//let St be a stack </span>
  St.<span class="me1">pop</span><span class="br0">(</span>v<span class="br0">)</span>
  <span class="kw1">while</span> St is not empty
    v <span class="sy0">=</span> St.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">if</span> v is not discovered<span class="sy0">:</span>
      label v as discovered
      <span class="kw1">for</span> all adjacent vertices of v <span class="kw1">do</span>
        St.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span> <span class="co1">//a being the adjacent vertex</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: Depth first search is similar to pre order traversal in a tree. So here we will get the same result as for the pre order traversal (root,left right).</i><p><b>6. What will be the time complexity of the iterative depth first traversal code(V=no. of vertices E=no.of edges)?<br>
a) O(V+E)<br>
b) O(V)<br>
c) O(E)<br>
d) O(V*E)<br>
</b></p><i>Answer: a<br>
Explanation: As 1 is the source element so it will be considered first. Then we start exploring the vertices which are connected to 1. So there will be two possible results-1 2 3 4 5 and 1 4 5 2 3.</i><p><b>7. Which of the following functions correctly represent iterative DFS?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> DFS<span class="br0">(</span><span class="kw4">int</span> s<span class="br0">)</span> 
<span class="br0">{</span>     
    vector<span class="sy0">&lt;</span>bool<span class="sy0">&gt;</span> discovered<span class="br0">(</span>V<span class="sy0">,</span> <span class="kw2">true</span><span class="br0">)</span><span class="sy0">;</span> 
    stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> st<span class="sy0">;</span>     
    st.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>st.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        s <span class="sy0">=</span> st.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
        st.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>         
        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span>s<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
            cout <span class="sy0">&lt;&lt;</span> s <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
            discovered<span class="br0">[</span>s<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
        <span class="br0">}</span> 
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> i <span class="sy0">=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i <span class="sy0">!=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
            <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span><span class="sy0">*</span>i<span class="br0">]</span><span class="br0">)</span> 
                st.<span class="me1">push</span><span class="br0">(</span><span class="sy0">*</span>i<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> DFS<span class="br0">(</span><span class="kw4">int</span> s<span class="br0">)</span> 
<span class="br0">{</span>     
    vector<span class="sy0">&lt;</span>bool<span class="sy0">&gt;</span> discovered<span class="br0">(</span>V<span class="sy0">,</span> <span class="kw2">false</span><span class="br0">)</span><span class="sy0">;</span>     
    stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> st<span class="sy0">;</span>     
    st.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>st.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        s <span class="sy0">=</span> st.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
        st.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>        
        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span>s<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
            cout <span class="sy0">&lt;&lt;</span> s <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
            discovered<span class="br0">[</span>s<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
        <span class="br0">}</span> 
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> i <span class="sy0">=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i <span class="sy0">!=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
            <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span><span class="sy0">*</span>i<span class="br0">]</span><span class="br0">)</span> 
                st.<span class="me1">push</span><span class="br0">(</span><span class="sy0">*</span>i<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> DFS<span class="br0">(</span><span class="kw4">int</span> s<span class="br0">)</span> 
<span class="br0">{</span>     
    vector<span class="sy0">&lt;</span>bool<span class="sy0">&gt;</span> discovered<span class="br0">(</span>V<span class="sy0">,</span> <span class="kw2">false</span><span class="br0">)</span><span class="sy0">;</span>     
    stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> st<span class="sy0">;</span>     
    st.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>st.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        st.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
        s <span class="sy0">=</span> st.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>         
        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span>s<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
            cout <span class="sy0">&lt;&lt;</span> s <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
            discovered<span class="br0">[</span>s<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
        <span class="br0">}</span> 
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> i <span class="sy0">=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i <span class="sy0">!=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
            <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span><span class="sy0">*</span>i<span class="br0">]</span><span class="br0">)</span> 
                st.<span class="me1">push</span><span class="br0">(</span><span class="sy0">*</span>i<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> DFS<span class="br0">(</span><span class="kw4">int</span> s<span class="br0">)</span> 
<span class="br0">{</span>     
    vector<span class="sy0">&lt;</span>bool<span class="sy0">&gt;</span> discovered<span class="br0">(</span>V<span class="sy0">,</span> <span class="kw2">false</span><span class="br0">)</span><span class="sy0">;</span>     
    stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> st<span class="sy0">;</span>     
    st.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>st.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        s <span class="sy0">=</span> st.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> 
        st.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>         
        <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>discovered<span class="br0">[</span>s<span class="br0">]</span><span class="br0">)</span> 
        <span class="br0">{</span> 
            cout <span class="sy0">&lt;&lt;</span> s <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
            discovered<span class="br0">[</span>s<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
        <span class="br0">}</span> 
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span> i <span class="sy0">=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i <span class="sy0">!=</span> adjacent<span class="br0">[</span>s<span class="br0">]</span>.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="sy0">++</span>i<span class="br0">)</span> 
            <span class="kw1">if</span> <span class="br0">(</span>discovered<span class="br0">[</span><span class="sy0">*</span>i<span class="br0">]</span><span class="br0">)</span> 
                st.<span class="me1">push</span><span class="br0">(</span><span class="sy0">*</span>i<span class="br0">)</span><span class="sy0">;</span> 
    <span class="br0">}</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: In the iterative approach we first push the source node into the stack. If the node has not been visited then it is printed and marked as visited. Then the unvisited adjacent nodes are added to the stack. Then the same procedure is repeated for each node of the stack.</i><p><b>8. What is the space complexity of standard DFS(V: no. of vertices E: no. of edges)?<br>
a) O(V+E)<br>
b) O(V)<br>
c) O(E)<br>
d) O(V*E)<br>
</b></p><i>Answer: a<br>
Explanation: As the time required to traverse a full graph is V+E so its worst case time complexity becomes O(V+E). The time complexity of iterative and recursive DFS are same. </i><p><b>9. Which of the following data structure is used to implement BFS?<br>
a) linked list<br>
b) tree<br>
c) stack<br>
d) queue<br>
</b></p><i>Answer: b<br>
Explanation: In the correct version we first push the source node into the stack. If the node has not been visited then it is printed and marked as visited. Then the unvisited adjacent nodes are added to the stack. Then the same procedure is repeated for each node of the stack.</i><p><b>10. Choose the incorrect statement about DFS and BFS from the following?<br>
a) BFS is equivalent to level order traversal in trees<br>
b) DFS is equivalent to post order traversal in trees<br>
c) DFS and BFS code has the same time complexity<br>
d) BFS is implemented using queue<br>
</b></p><i>Answer: b<br>
Explanation: In the worst case the space complexity of DFS will be O(V) in the case when all the vertices are stored in stack. This space complexity is excluding the space required to store the graph.</i><p><b>1. Breadth First Search is equivalent to which of the traversal in the Binary Trees?<br>
a) Pre-order Traversal<br>
b) Post-order Traversal<br>
c) Level-order Traversal<br>
d) In-order Traversal<br>
</b></p><i>Answer: c<br>
Explanation: The Breadth First Search Algorithm searches the nodes on the basis of level. It takes a node (level 0), explores it’s neighbors (level 1) and so on.</i><p><b>2. Time Complexity of Breadth First Search is? (V – number of vertices, E – number of edges)<br>
a) O(V + E)<br>
b) O(V)<br>
c) O(E)<br>
d) O(V*E)<br>
</b></p><i>Answer: a<br>
Explanation: The Breadth First Search explores every node once and every edge once (in worst case), so it’s time complexity is O(V + E).</i><p><b>3. The Data structure used in standard implementation of Breadth First Search is?<br>
a) Stack<br>
b) Queue<br>
c) Linked List<br>
d) Tree<br>
</b></p><i>Answer: b<br>
Explanation: The Breadth First Search explores every node once and put that node in queue and then it takes out nodes from the queue and explores it’s neighbors.</i><p><b>4. The Breadth First Search traversal of a graph will result into?<br>
a) Linked List<br>
b) Tree<br>
c) Graph with back edges<br>
d) Arrays<br>
</b></p><i>Answer: b<br>
Explanation: The Breadth First Search will make a graph which don’t have back edges (a tree) which is known as Breadth First Tree.</i><p><b>5. A person wants to visit some places. He starts from a vertex and then wants to visit every place connected to this vertex and so on. What algorithm he should use?<br>
a) Depth First Search<br>
b) Breadth First Search<br>
c) Trim’s algorithm<br>
d) Kruskal’s algorithm<br>
</b></p><i>Answer: b<br>
Explanation: This is the definition of the Breadth First Search. Exploring a node, then it’s neighbors and so on.</i><p><b>6. Which of the following is not an application of Breadth First Search?<br>
a) Finding shortest path between two nodes<br>
b) Finding bipartiteness of a graph<br>
c) GPS navigation system<br>
d) Path Finding<br>
</b></p><i>Answer: d<br>
Explanation: Breadth First Search can be applied to Bipartite a graph, to find the shortest path between two nodes, in GPS Navigation. In Path finding, Depth First Search is used.</i><p><b>7. When the Breadth First Search of a graph is unique?<br>
a) When the graph is a Binary Tree<br>
b) When the graph is a Linked List<br>
c) When the graph is a n-ary Tree<br>
d) When the graph is a Ternary Tree<br>
</b></p><i>Answer: b<br>
Explanation: When Every node will have one successor then the Breadth First Search is unique. In all other cases, when it will have more than one successor, it can choose any of them in arbitrary order.</i><p><b>8. Regarding implementation of Breadth First Search using queues, what is the maximum distance between two nodes present in the queue? (considering each edge length 1)<br>
a) Can be anything<br>
b) 0<br>
c) At most 1<br>
d) Insufficient Information<br>
</b></p><i>Answer: c<br>
Explanation: In the queue, at a time, only those nodes will be there whose difference among levels is 1. Same as level order traversal of the tree.</i><p><b>9. In BFS, how many times a node is visited?<br>
a) Once<br>
b) Twice<br>
c) Equivalent to number of indegree of the node<br>
d) Thrice<br>
</b></p><i>Answer: c<br>
Explanation: In Breadth First Search, we have to see whether the node is visited or not by it’s ancestor. If it is visited, we won’t let it enter it in the queue.</i><p><b>2. Who described this Best First Search algorithm using heuristic evaluation rule?<br>
a) Judea Pearl<br>
b) Max Bezzel<br>
c) Franz Nauck<br>
d) Alan Turing<br>
</b></p><i>Answer: a<br>
Explanation: Best First Search is a searching algorithm used in graphs. It explores it by choosing a node by heuristic evaluation rule. It is used in solving searching for related problems.</i><p><b>3. Which type of best first search algorithm was used to predict the closeness of the end of path and its solution?<br>
a) Greedy BFS<br>
b) Divide and Conquer<br>
c) Heuristic BFS<br>
d) Combinatorial<br>
</b></p><i>Answer: a<br>
Explanation: The best first search algorithm using heuristic evaluation rule or function was proposed by an Israeli – American computer scientist and philosopher Judea Pearl.</i><p><b>4. What is the other name of the greedy best first search?<br>
a) Heuristic Search<br>
b) Pure Heuristic Search<br>
c) Combinatorial Search<br>
d) Divide and Conquer Search<br>
</b></p><i>Answer: a<br>
Explanation: The greedy best first search algorithm was used to predict the closeness of the end of the path and its solution by some of the computer scientists.</i><p><b>5. Which algorithm is used in graph traversal and path finding?<br>
a) A*<br>
b) C*<br>
c) D*<br>
d) E*<br>
</b></p><i>Answer: b<br>
Explanation: The greedy best first search algorithm was used to predict the closeness of the end of the path and its solution by some of the computer scientists. It is also known as Pure Heuristic Search.</i><p><b>6. Which algorithm is used to find the least cost path from source node to destination node?<br>
a) A* BFS<br>
b) C* BFS<br>
c) D* BFS<br>
d) B* BFS<br>
</b></p><i>Answer: a<br>
Explanation: In computer science A* algorithm is used in graph traversal and path finding. It is a process of node finding in between a path. It is an example of the best first search.</i><p><b>7. Which of the following is an example of Best First Search algorithm?<br>
a) A*<br>
b) B*<br>
c) C*<br>
d) Both A* and B*<br>
</b></p><i>Answer: d<br>
Explanation: In computer science, B* algorithm is used to find the least cost path between the source node and the destination node. It is an example of the best first search.</i><p><b>8.  Which of the following is the greedy best first search?<br>
a) Pure Heuristic Search<br>
b) A*<br>
c) B*<br>
d) Both A* and B*<br>
</b></p><i>Answer: d<br>
Explanation: In computer science, A* algorithm is used in graph traversal and path finding. It is a process of node finding in between a path. B* algorithm is used to find the least cost path between the source node and the destination node.</i><p><b>9. Which of the following scientists didn’t publish A* algorithm?<br>
a) Peter Hart<br>
b) Nils Nilsson<br>
c) Bertram Raphael<br>
d) Hans Berliner<br>
</b></p><i>Answer: a<br>
Explanation: Pure Heuristic Search is also called greedy best first search while A* and B* search algorithms are not greedy best first search.</i><p><b>10. Who published the B* search algorithm?<br>
a) Peter Hart<br>
b) Nils Nilsson<br>
c) Bertram Raphael<br>
d) Hans Berliner<br>
</b></p><i>Answer: d<br>
Explanation: Peter Hart Nils Nilsson Bertram Raphael are the three scientists of SRI International who first published the A* search algorithm which uses heuristics for better performance. Hans Berliner published B* algorithm. </i><p><b>1. Branch and bound is a __________<br>
a) problem solving technique<br>
b) data structure<br>
c) sorting algorithm<br>
d) type of tree<br>
</b></p><i>Answer: a<br>
Explanation: Branch and bound is a problem solving technique generally used for solving combinatorial optimization problems. Branch and bound helps in solving them faster.</i><p><b>2. Which of the following is not a branch and bound strategy to generate branches?<br>
a) LIFO branch and bound<br>
b) FIFO branch and bound<br>
c) Lowest cost branch and bound<br>
d) Highest cost branch and bound<br>
</b></p><i>Answer: d<br>
Explanation: LIFO, FIFO and Lowest cost branch and bound are different strategies to generate branches. Lowest cost branch and bound helps us find the lowest cost path.</i><p><b>3. Which data structure is used for implementing a LIFO branch and bound strategy?<br>
a) stack<br>
b) queue<br>
c) array<br>
d) linked list<br>
</b></p><i>Answer: a<br>
Explanation: Stack is the data structure is used for implementing LIFO branch and bound strategy. This leads to depth first search as every branch is explored until a leaf node is discovered.</i><p><b>4. Which data structure is used for implementing a FIFO branch and bound strategy?<br>
a) stack<br>
b) queue<br>
c) array<br>
d) linked list<br>
</b></p><i>Answer: b<br>
Explanation: Queue is the data structure is used for implementing FIFO branch and bound strategy. This leads to breadth first search as every branch at depth is explored first before moving to the nodes at greater depth.</i><p><b>5. Which data structure is most suitable for implementing best first branch and bound strategy?<br>
a) stack<br>
b) queue<br>
c) priority queue<br>
d) linked list<br>
</b></p><i>Answer: c<br>
Explanation: Priority Queue is the data structure is used for implementing best first branch and bound strategy. Dijkstra’s algorithm is an example of best first search algorithm.</i><p><b>6. Which of the following branch and bound strategy leads to breadth first search?<br>
a) LIFO branch and bound<br>
b) FIFO branch and bound<br>
c) Lowest cost branch and bound<br>
d) Highest cost branch and bound<br>
</b></p><i>Answer: b<br>
Explanation: LIFO, FIFO and Lowest cost branch and bound are different strategies to generate branches.  FIFO branch and bound leads to breadth first search.</i><p><b>7. Which of the following branch and bound strategy leads to depth first search?<br>
a) LIFO branch and bound<br>
b) FIFO branch and bound<br>
c) Lowest cost branch and bound<br>
d) Highest cost branch and bound<br>
</b></p><i>Answer: a<br>
Explanation: LIFO, FIFO and Lowest cost branch and bound are different strategies to generate branches. LIFO branch and bound leads to depth first search.</i><p><b>10. Choose the correct statement from the following.<br>
a) branch and bound is more efficient than backtracking<br>
b) branch and bound is not suitable where a greedy algorithm is not applicable<br>
c) branch and bound divides a problem into at least 2 new restricted sub problems<br>
d) backtracking divides a problem into at least 2 new restricted sub problems<br>
</b></p><i>Answer: b<br>
Explanation: FIFO branch and bound leads to breadth first search. Whereas backtracking leads to depth first search.</i><p><b>11. Which of the following can traverse the state space tree only in DFS manner?<br>
a) branch and bound<br>
b) dynamic programming<br>
c) greedy algorithm<br>
d) backtracking<br>
</b></p><i>Answer: a<br>
Explanation: Both backtrackings as well as branch and bound are problem solving algorithms. Both LIFO branch and bound strategy and backtracking leads to depth first search.</i><p><b>1. Which of the following is false in the case of a spanning tree of a graph G?<br>
a) It is tree that spans G<br>
b) It is a subgraph of the G<br>
c) It includes every vertex of the G<br>
d) It can be either cyclic or acyclic<br>
</b></p><i>Answer: d<br>
Explanation: A graph can have many spanning trees. Each spanning tree of a graph G is a subgraph of the graph G, and spanning trees include every vertex of the gram. Spanning trees are always acyclic.</i><p><b>3. Consider a complete graph G with 4 vertices. The graph G has ____ spanning trees.<br>
a) 15<br>
b) 8<br>
c) 16<br>
d) 13<br>
</b></p><i>Answer: b<br>
Explanation: Minimum spanning tree is a spanning tree with the lowest cost among all the spacing trees. Sum of all of the edges in the spanning tree is the cost of the spanning tree. There can be many minimum spanning trees for a given graph.</i><p><b>4. The travelling salesman problem can be solved using _________<br>
a) A spanning tree<br>
b) A minimum spanning tree<br>
c) Bellman – Ford algorithm<br>
d) DFS traversal<br>
</b></p><i>Answer: c<br>
Explanation: A graph can have many spanning trees. And a complete graph with n vertices has n<sup>(n-2)</sup> spanning trees. So, the complete graph with 4 vertices has 4<sup>(4-2)</sup>  = 16 spanning trees.</i><p><b>6. Consider a undirected graph G with vertices { A, B, C, D, E}. In graph G, every edge has distinct weight. Edge CD is edge with minimum weight and edge AB is edge with maximum weight. Then, which of the following is false?<br>
a) Every minimum spanning tree of G must contain CD<br>
b) If AB is in a minimum spanning tree, then its removal must disconnect G<br>
c) No minimum spanning tree contains AB<br>
d) G has a unique minimum spanning tree<br>
</b></p><i>Answer: b<br>
Explanation: In the travelling salesman problem we have to find the shortest possible route that visits every city exactly once and returns to the starting point for the given a set of cities. So, travelling salesman problem can be solved by contracting the minimum spanning tree.</i><p><b>9. Which of the following is not the algorithm to find the minimum spanning tree of the given graph?<br>
a) Boruvka’s algorithm<br>
b) Prim’s algorithm<br>
c) Kruskal’s algorithm<br>
d) Bellman–Ford algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Here all non-diagonal elements in the adjacency matrix are 1. So, every vertex is connected every other vertex of the graph. And, so graph M has 3 distinct minimum spanning trees.<br>
<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a.png" alt="minimum-spanning-tree-questions-answers-q5a" width="413" height="118" class="alignnone size-full wp-image-218878" srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a.png 413w, https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a-300x86.png 300w" sizes="(max-width: 413px) 100vw, 413px" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20413%20118%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a.png" alt="minimum-spanning-tree-questions-answers-q5a" width="413" height="118" class="lazyload alignnone size-full wp-image-218878" data-srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a.png 413w, https://www.sanfoundry.com/wp-content/uploads/2018/07/minimum-spanning-tree-questions-answers-q5a-300x86.png 300w" data-sizes="(max-width: 413px) 100vw, 413px"></a></i><p><b>10. Which of the following is false?<br>
a) The spanning trees do not have any cycles<br>
b) MST have n – 1 edges if the graph has n edges<br>
c) Edge e belonging to a cut of the graph if has the weight smaller than any other edge in the same cut, then the edge e is present in all the MSTs of the graph<br>
d) Removing one edge from the spanning tree will not make the graph disconnected<br>
</b></p><i>Answer: c<br>
Explanation: Every MST will contain CD as it is smallest edge. So, Every minimum spanning tree of G must contain CD is true. And G has a unique minimum spanning tree is also true because the graph has edges with distinct weights. So, no minimum spanning tree contains AB is false.</i><p><b>1. Kruskal’s algorithm is used to ______<br>
a) find minimum spanning tree<br>
b) find  single source shortest path<br>
c) find all pair shortest path algorithm<br>
d) traverse the graph<br>
</b></p><i>Answer: a<br>
Explanation: The  Kruskal’s algorithm is used to find the minimum spanning tree of the connected graph. It construct the MST by finding the edge having the least possible weight that connects two trees in the forest.</i><p><b>2. Kruskal’s algorithm is a ______<br>
a) divide and conquer algorithm<br>
b) dynamic programming algorithm<br>
c) greedy algorithm<br>
d) approximation algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Kruskal’s algorithm uses a greedy algorithm approach to find the MST of the connected weighted graph. In the greedy method, we attempt to find an optimal solution in stages.</i><p><b>4. What is the time complexity of Kruskal’s algorithm?<br>
a) O(log V)<br>
b) O(E log V)<br>
c) O(E<sup>2</sup>)<br>
d) O(V log E)<br>
</b></p><i>Answer: d<br>
Explanation: Kruskal’s algorithm constructs the minimum spanning tree by constructing by adding the edges to spanning tree one-one by one. The MST for the given graph is,<br>
<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/kruskals-algorithm-questions-answers-q3a.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/kruskals-algorithm-questions-answers-q3a.png" alt="kruskals-algorithm-questions-answers-q3a" width="185" height="159" class="alignnone size-full wp-image-218884" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20185%20159%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/kruskals-algorithm-questions-answers-q3a.png" alt="kruskals-algorithm-questions-answers-q3a" width="185" height="159" class="lazyload alignnone size-full wp-image-218884"></a><br>
So, the weight of the MST is 19.</i><p><b>7. Which of the following is true?<br>
a) Prim’s algorithm can also be used for disconnected graphs<br>
b) Kruskal’s algorithm can also run on the disconnected graphs<br>
c) Prim’s algorithm is simpler than Kruskal’s algorithm<br>
d) In Kruskal’s sort edges are added to MST in decreasing order of their weights<br>
</b></p><i>Answer: b<br>
Explanation: Kruskal’s algorithm involves sorting of the edges, which takes O(E logE) time, where E is a number of edges in graph and V is the number of vertices. After sorting, all edges are iterated and union-find algorithm is applied. union-find algorithm requires O(logV) time. So, overall Kruskal’s algorithm requires O(E log V) time.</i><p><b>8. Which of the following is false about the Kruskal’s algorithm?<br>
a) It is a greedy algorithm<br>
b) It constructs MST by selecting edges in increasing order of their weights<br>
c) It can accept cycles in the MST<br>
d) It uses union-find data structure<br>
</b></p><i>Answer: c<br>
Explanation: In Krsuskal’s algorithm the edges are selected and added to the spanning tree in increasing order of their weights. Therefore, the first edge selected will be the minimal one. So, correct option is BE.</i><p><b>1. Which of the following is true?<br>
a) Prim’s algorithm initialises with a vertex<br>
b) Prim’s algorithm initialises with a edge<br>
c) Prim’s algorithm initialises with a vertex which has smallest edge<br>
d) Prim’s algorithm initialises with a forest<br>
</b></p><i>Answer: a<br>
Explanation: Steps in Prim’s algorithm: (I) Select any vertex of given graph and add it to MST (II) Add the edge of minimum weight from a vertex not in MST to the vertex in MST; (III) It MST is complete the stop, otherwise go to step (II).</i><p><b>3. Worst case is the worst case time complexity of Prim’s algorithm if adjacency matrix is used?<br>
a) O(log V)<br>
b) O(V<sup>2</sup>)<br>
c) O(E<sup>2</sup>)<br>
d) O(V log E)<br>
</b></p><i>Answer: c<br>
Explanation: In Prim’s algorithm, we select a vertex and add it to the MST. Then we add the minimum edge from the vertex in MST to vertex not in MST. From, figure shown below weight of MST = 27.<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a.png" alt="prims-algorithm-questions-answers-q2a" width="421" height="158" class="alignnone size-full wp-image-218894" srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a.png 421w, https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a-300x113.png 300w" sizes="(max-width: 421px) 100vw, 421px" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20421%20158%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a.png" alt="prims-algorithm-questions-answers-q2a" width="421" height="158" class="lazyload alignnone size-full wp-image-218894" data-srcset="https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a.png 421w, https://www.sanfoundry.com/wp-content/uploads/2018/07/prims-algorithm-questions-answers-q2a-300x113.png 300w" data-sizes="(max-width: 421px) 100vw, 421px"></a></i><p><b>4. Prim’s algorithm is a ______<br>
a) Divide and conquer algorithm<br>
b) Greedy algorithm<br>
c) Dynamic Programming<br>
d) Approximation algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Use of adjacency matrix provides the simple implementation of the Prim’s algorithm. In Prim’s algorithm, we need to search for the edge with a minimum for that vertex. So, worst case time complexity will be O(V<sup>2</sup>), where V is the number of vertices.</i><p><b>8. Prim’s algorithm is also known as __________<br>
a) Dijkstra–Scholten algorithm<br>
b) Borůvka’s algorithm<br>
c) Floyd–Warshall algorithm<br>
d) DJP Algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Prim’s algorithm uses a greedy algorithm approach to find the MST of the connected weighted graph. In greedy method, we attempt to find an optimal solution in stages.</i><p><b>9. Prim’s algorithm can be efficiently implemented using _____ for graphs with greater density.<br>
a) d-ary heap<br>
b) linear search<br>
c) fibonacci heap<br>
d) binary search<br>
</b></p><i>Answer: a<br>
Explanation: In Prim’s algorithm, the MST is constructed starting from a single vertex and adding in new edges to the MST that link the partial tree to a new vertex outside of the MST. And Dijkstra’s algorithm also rely on the similar approach of finding the next closest vertex. So, Prim’s algorithm resembles Dijkstra’s algorithm.</i><p><b>10. Which of the following is false about Prim’s algorithm?<br>
a) It is a greedy algorithm<br>
b) It constructs MST by selecting edges in increasing order of their weights<br>
c) It never accepts cycles in the MST<br>
d) It can be implemented using the Fibonacci heap<br>
</b></p><i>Answer: a<br>
Explanation: Prim’s algorithm and Kruskal’s algorithm perform equally in case of the sparse graphs. But Kruskal’s algorithm is simpler and easy to work with. So, it is best suited for sparse graphs. </i><p><b>1. Dijkstra’s Algorithm is used to solve _____________ problems.<br>
a) All pair shortest path<br>
b) Single source shortest path<br>
c) Network flow<br>
d) Sorting<br>
</b></p><i>Answer: b<br>
Explanation:  Dijkstra’s Algorithm is used for solving single source shortest path problems. In this algorithm, a single node is fixed as a source node and shortest paths from this node to all other nodes in graph is found.</i><p><b>2. Which of the following is the most commonly used data structure for implementing Dijkstra’s Algorithm?<br>
a) Max priority queue<br>
b) Stack<br>
c) Circular queue<br>
d) Min priority queue<br>
</b></p><i>Answer: d<br>
Explanation: Minimum priority queue is the most commonly used data structure for implementing Dijkstra’s Algorithm because the required operations to be performed in Dijkstra’s Algorithm match with specialty of a minimum priority queue.</i><p><b>3. What is the time complexity of Dijikstra’s algorithm?<br>
a) O(N)<br>
b) O(N<sup>3</sup>)<br>
c) O(N<sup>2</sup>)<br>
d) O(logN)<br>
</b></p><i>Answer: c<br>
Explanation: Time complexity of Dijkstra’s algorithm is O(N<sup>2</sup>) because of the use of doubly nested for loops. It depends on how the table is manipulated.</i><p><b>4. Dijkstra’s Algorithm cannot be applied on ______________<br>
a) Directed and weighted graphs<br>
b) Graphs having negative weight function<br>
c) Unweighted graphs<br>
d) Undirected and unweighted graphs<br>
</b></p><i>Answer: b<br>
Explanation: Dijkstra’s Algorithm cannot be applied on graphs having negative weight function because calculation of cost to reach a destination node from the source node becomes complex.</i><p><b>5. What is the pseudo code to compute the shortest path in Dijkstra’s algorithm?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Known</span><span class="br0">)</span>
 	<span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span> C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span> <span class="sy0">&lt;</span> T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span><span class="br0">)</span>  <span class="br0">{</span>
                 Decrease<span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span> to T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span>C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">path</span><span class="sy0">=</span>v<span class="sy0">;</span> <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Known</span><span class="br0">)</span>
 	<span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span> C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span> <span class="sy0">&lt;</span> T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span><span class="br0">)</span>  <span class="br0">{</span>
                 Increase <span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span> to T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span>C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
                T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">path</span><span class="sy0">=</span>v<span class="sy0">;</span> <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Known</span><span class="br0">)</span>
 	<span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span> C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span> <span class="sy0">&gt;</span> T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span><span class="br0">)</span>  <span class="br0">{</span>
                 Decrease<span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span> to T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span>C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span><span class="sy0">;</span>
                  T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">path</span><span class="sy0">=</span>v<span class="sy0">;</span> <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Known</span><span class="br0">)</span>
 	<span class="kw1">if</span><span class="br0">(</span>T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span> <span class="sy0">+</span> C<span class="br0">(</span>v<span class="sy0">,</span>w<span class="br0">)</span> <span class="sy0">&lt;</span> T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span><span class="br0">)</span>  <span class="br0">{</span>
                 Increase<span class="br0">(</span>T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">Dist</span> to T<span class="br0">[</span>v<span class="br0">]</span>.<span class="me1">Dist</span><span class="br0">)</span><span class="sy0">;</span>
                T<span class="br0">[</span>w<span class="br0">]</span>.<span class="me1">path</span><span class="sy0">=</span>v<span class="sy0">;</span> <span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation:  If the known value of the adjacent vertex(w) is not set then check whether the  sum of  distance from source vertex(v) and cost to travel from source to adjacent vertex is less than the existing distance of the adjacent node. If so, perform decrease key operation.</i><p><b>6. How many priority queue operations are involved in Dijkstra’s Algorithm?<br>
a) 1<br>
b) 3<br>
c) 2<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: The number of priority queue operations involved is 3. They are insert, extract-min and decrease key.</i><p><b>7. How many times the insert and extract min operations are invoked per vertex?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 0<br>
</b></p><i>Answer: a<br>
Explanation: Insert and extract min operations are invoked only once per vertex because each vertex is added only once to the set and each edge in the adjacency list is examined only once during the course of algorithm.</i><p><b>8. The maximum number of times the decrease key operation performed in Dijkstra’s algorithm will be equal to ___________<br>
a) Total number of vertices<br>
b) Total number of edges<br>
c) Number of vertices – 1<br>
d) Number of edges – 1<br>
</b></p><i>Answer: b<br>
Explanation: If the total number of edges in all adjacency list is E, then there will be a total of E number of iterations, hence there will be a total of at most E decrease key operations.</i><p><b>9. What is running time of Dijkstra’s algorithm using Binary min- heap method?<br>
a) O(V)<br>
b) O(VlogV)<br>
c) O(E)<br>
d) O(ElogV)<br>
</b></p><i>Answer: d<br>
Explanation: Time required to build a binary min heap is O(V). Each decrease key operation takes O(logV) and there are still at most E such operations. Hence total running time is O(ElogV).</i><p><b>12. Given pseudo code of Dijkstra’s Algorithm.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co1">//Initialise single source(G,s)</span>
S<span class="sy0">=</span><span class="nu0">0</span>
Q<span class="sy0">=</span>V<span class="br0">[</span>G<span class="br0">]</span>
While Q <span class="sy0">!=</span> <span class="nu0">0</span>
    Do u<span class="sy0">=</span>extract<span class="sy0">-</span>min<span class="br0">(</span>Q<span class="br0">)</span>
        S<span class="sy0">=</span>S <span class="kw4">union</span> <span class="br0">{</span>u<span class="br0">}</span>
	    For each vertex v in adj<span class="br0">[</span>u<span class="br0">]</span>
	        Do relax<span class="br0">(</span>u<span class="sy0">,</span>v<span class="sy0">,</span>w<span class="br0">)</span></pre></div></div></div></div></div></div><p><b>What happens when “While Q != 0” is changed to “while Q&gt;1”?<br>
a) While loop gets executed for v times<br>
b) While loop gets executed for v-1 times<br>
c) While loop gets executed only once<br>
d) While loop does not get executed<br>
</b></p><i>Answer: b<br>
Explanation: The number of iterations involved in Bellmann Ford Algorithm is more than that of Dijkstra’s Algorithm.</i><p><b>15. Dijkstra’s Algorithm is the prime example for ___________<br>
a) Greedy algorithm<br>
b) Branch and bound<br>
c) Back tracking<br>
d) Dynamic programming<br>
</b></p><i>Answer: a<br>
Explanation: The equality d[u]=delta(s,u) holds good when vertex u is added to set S and this equality is maintained thereafter by the upper bound property.</i><p><b>1. The Bellmann Ford algorithm returns _______ value.<br>
a) Boolean<br>
b) Integer<br>
c) String<br>
d) Double<br>
</b></p><i>Answer: a<br>
Explanation: The Bellmann Ford algorithm returns Boolean value whether there is a negative weight cycle that is reachable from the source.</i><p><b>2. Bellmann ford algorithm provides solution for ____________ problems.<br>
a) All pair shortest path<br>
b) Sorting<br>
c) Network flow<br>
d) Single source shortest path<br>
</b></p><i>Answer: d<br>
Explanation: Bellmann ford algorithm is used for finding solutions for single source shortest path problems. If the graph has no negative cycles that are reachable from the source then the algorithm produces the shortest paths and their weights.</i><p><b>4. How many solution/solutions are available for a graph having negative weight cycle?<br>
a) One solution<br>
b) Two solutions<br>
c) No solution<br>
d) Infinite solutions<br>
</b></p><i>Answer: a<br>
Explanation: Bellmann Ford algorithm returns true if the graph does not have any negative weight cycles and returns false when the graph has negative weight cycles.</i><p><b>5. What is the running time of Bellmann Ford Algorithm?<br>
a) O(V)<br>
b) O(V<sup>2</sup>)<br>
c) O(ElogV)<br>
d) O(VE)<br>
</b></p><i>Answer: c<br>
Explanation: If the graph has any negative weight cycle then the algorithm indicates that no solution exists for that graph.</i><p><b>6. How many times the for loop in the Bellmann Ford Algorithm gets executed?<br>
a) V times<br>
b) V-1<br>
c) E<br>
d) E-1<br>
</b></p><i>Answer: d<br>
Explanation: Bellmann Ford algorithm runs in time O(VE), since the initialization takes O(V) for each of V-1 passes and the for loop in the algorithm takes O(E) time. Hence the total time taken by the algorithm is O(VE).</i><p><b>8.  Identify the correct Bellmann Ford Algorithm.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to V<span class="br0">[</span>g<span class="br0">]</span><span class="sy0">-</span><span class="nu0">1</span>
	<span class="kw1">do</span> <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
		<span class="kw1">do</span> Relax<span class="br0">(</span>u<span class="sy0">,</span>v<span class="sy0">,</span>w<span class="br0">)</span>
   <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
	<span class="kw1">do</span> <span class="kw1">if</span> d<span class="br0">[</span>v<span class="br0">]</span><span class="sy0">&gt;</span>d<span class="br0">[</span>u<span class="br0">]</span><span class="sy0">+</span>w<span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span>
		then <span class="kw1">return</span> False
   <span class="kw1">return</span> True</pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to V<span class="br0">[</span>g<span class="br0">]</span><span class="sy0">-</span><span class="nu0">1</span>
       <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
	<span class="kw1">do</span> <span class="kw1">if</span> d<span class="br0">[</span>v<span class="br0">]</span><span class="sy0">&gt;</span>d<span class="br0">[</span>u<span class="br0">]</span><span class="sy0">+</span>w<span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span>
		then <span class="kw1">return</span> False
    <span class="kw1">return</span> True</pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to V<span class="br0">[</span>g<span class="br0">]</span><span class="sy0">-</span><span class="nu0">1</span>
	<span class="kw1">do</span> <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
		<span class="kw1">do</span> Relax<span class="br0">(</span>u<span class="sy0">,</span>v<span class="sy0">,</span>w<span class="br0">)</span>
   <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
	<span class="kw1">do</span> <span class="kw1">if</span> d<span class="br0">[</span>v<span class="br0">]</span><span class="sy0">&lt;</span>d<span class="br0">[</span>u<span class="br0">]</span><span class="sy0">+</span>w<span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span>
		then <span class="kw1">return</span> <span class="kw2">true</span>
   <span class="kw1">return</span> True</pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to V<span class="br0">[</span>g<span class="br0">]</span><span class="sy0">-</span><span class="nu0">1</span>
	<span class="kw1">do</span> <span class="kw1">for</span> each edge <span class="br0">(</span>u<span class="sy0">,</span>v<span class="br0">)</span> in E<span class="br0">[</span>g<span class="br0">]</span>
		<span class="kw1">do</span> Relax<span class="br0">(</span>u<span class="sy0">,</span>v<span class="sy0">,</span>w<span class="br0">)</span>
   <span class="kw1">return</span> True</pre></div></div></div></div></div></div><i>Answer:  b<br>
Explanation: The for loop in the Bellmann Ford Algorithm gets executed for V-1 times. After making V-1 passes, the algorithm checks for a negative weight cycle and returns appropriate boolean value.</i><p><b>9. What is the basic principle behind Bellmann Ford Algorithm?<br>
a) Interpolation<br>
b) Extrapolation<br>
c) Regression<br>
d) Relaxation<br>
</b></p><i>Answer: a<br>
Explanation: The running time of Bellmann Ford Algorithm is O(VE) whereas Dijikstra’s Algorithm has running time of only O(V<sup>2</sup>).</i><p><b>10. Bellmann Ford Algorithm can be applied for _____________<br>
a) Undirected and weighted graphs<br>
b) Undirected and unweighted graphs<br>
c) Directed and weighted graphs<br>
d) All directed graphs<br>
</b></p><i>Answer: a<br>
Explanation: After initialization, the algorithm makes v-1 passes over the edges of the graph. Each pass is one iteration of the for loop and consists of relaxing each edge of the graph once. Then it checks for the negative weight cycle and returns an appropriate Boolean value.</i><p><b>11. Bellmann Ford algorithm was first proposed by ________<br>
a) Richard Bellmann<br>
b) Alfonso Shimbe<br>
c) Lester Ford Jr<br>
d) Edward F. Moore<br>
</b></p><i>Answer: d<br>
Explanation: Relaxation methods which are also called as iterative methods in which an approximation to the correct distance is replaced progressively by more accurate values till an optimum solution is found.</i><p><b>14. Bellmann Ford Algorithm is an example for ____________<br>
a) Dynamic Programming<br>
b) Greedy Algorithms<br>
c) Linear Programming<br>
d) Branch and Bound<br>
</b></p><i>Answer: c<br>
Explanation: Bellmann Ford Algorithm can be applied for all directed and weighted graphs. The weight function in the graph may either be positive or negative.</i><p><b>15. A graph is said to have a negative weight cycle when?<br>
a) The graph has 1 negative weighted edge<br>
b) The graph has a cycle<br>
c) The total weight of the graph is negative<br>
d) The graph has 1 or more negative weighted edges<br>
</b></p><i>Answer:  b<br>
Explanation:  Alfonso Shimbe proposed Bellmann Ford algorithm in the year 1955. Later it was published by Richard Bellmann in 1957 and Lester Ford Jr in the year 1956. Hence it is called Bellmann Ford Algorithm.</i><p><b>1. Floyd Warshall’s Algorithm is used for solving ____________<br>
a) All pair shortest path problems<br>
b) Single Source shortest path problems<br>
c) Network flow problems<br>
d) Sorting problems<br>
</b></p><i>Answer: a<br>
Explanation: Floyd Warshall’s Algorithm is used for solving all pair shortest path problems. It means the algorithm is used for finding the shortest paths between all pairs of vertices in a graph. </i><p><b>2. Floyd Warshall’s Algorithm can be applied on __________<br>
a) Undirected and unweighted graphs<br>
b) Undirected graphs<br>
c) Directed graphs<br>
d)  Acyclic graphs<br>
</b></p><i>Answer: c<br>
Explanation: Floyd Warshall Algorithm can be applied in directed graphs. From a given directed graph, an adjacency matrix is framed and then all pair shortest path is computed by the Floyd Warshall Algorithm. </i><p><b>3. What is the running time of the Floyd Warshall Algorithm?<br>
a) Big-oh(V)<br>
b) Theta(V<sup>2</sup>)<br>
c) Big-Oh(VE)<br>
d) Theta(V<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The running time of the Floyd Warshall algorithm is determined by the triply nested for loops. Since each execution of the for loop takes O(1) time, the algorithm runs in time Theta(V<sup>3</sup>).</i><p><b>4. What approach is being followed in Floyd Warshall Algorithm?<br>
a) Greedy technique<br>
b) Dynamic Programming<br>
c) Linear Programming<br>
d) Backtracking<br>
</b></p><i>Answer: b<br>
Explanation: Floyd Warshall Algorithm follows dynamic programming approach because the all pair shortest paths are computed in bottom up manner.</i><p><b>5. Floyd Warshall Algorithm can be used for finding _____________<br>
a) Single source shortest path<br>
b) Topological sort<br>
c) Minimum spanning tree<br>
d) Transitive closure<br>
</b></p><i>Answer: d<br>
Explanation: One of the ways to compute the transitive closure of a graph in Theta(N<sup>3</sup>) time is to assign a weight of 1 to each edge of E and then run the Floyd Warshall Algorithm.</i><p><b>6. What procedure is being followed in Floyd Warshall Algorithm?<br>
a) Top down<br>
b) Bottom up<br>
c) Big bang<br>
d) Sandwich<br>
</b></p><i>Answer: b<br>
Explanation: Bottom up procedure is being used to compute the values of the matrix elements dij(k). The input is an n x n matrix. The procedure returns the matrix D(n) of the shortest path weights.</i><p><b>7. Floyd- Warshall algorithm was proposed by ____________<br>
a) Robert Floyd and Stephen Warshall<br>
b) Stephen Floyd and Robert Warshall<br>
c) Bernad Floyd and Robert Warshall<br>
d) Robert Floyd and Bernad Warshall<br>
</b></p><i>Answer: a<br>
Explanation: Floyd- Warshall Algorithm was proposed by Robert Floyd in the year 1962. The same algorithm was proposed by Stephen Warshall during the same year for finding the transitive closure of the graph.</i><p><b>8. Who proposed the modern formulation of Floyd-Warshall Algorithm as three nested loops?<br>
a) Robert Floyd<br>
b) Stephen Warshall<br>
c) Bernard Roy<br>
d) Peter Ingerman<br>
</b></p><i>Answer: d<br>
Explanation: The modern formulation of Floyd-Warshall Algorithm as three nested for-loops was proposed by Peter Ingerman in the year 1962.</i><p><b>9. Complete the program.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">n<span class="sy0">=</span>rows<span class="br0">[</span>W<span class="br0">]</span>
D<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">=</span>W
<span class="kw1">for</span> k<span class="sy0">=</span><span class="nu0">1</span> to n
     <span class="kw1">do</span> <span class="kw1">for</span> i<span class="sy0">=</span><span class="nu0">1</span> to n
          <span class="kw1">do</span> <span class="kw1">for</span> j<span class="sy0">=</span><span class="nu0">1</span> to n
                 <span class="kw1">do</span> ________________________________
<span class="kw1">return</span> D<span class="br0">(</span>n<span class="br0">)</span></pre></div></div></div></div></div></div><p><b>a) dij(k)=min(dij(k-1), dik(k-1) – dkj(k-1))<br>
b) dij(k)=max(dij(k-1), dik(k-1) – dkj(k-1))<br>
c) dij(k)=min(dij(k-1), dik(k-1) + dkj(k-1))<br>
d) dij(k)=max(dij(k-1), dik(k-1) + dkj(k-1))<br>
</b></p><i>Answer: c<br>
Explanation: In order to compute the shortest path from vertex i to vertex j, we need to find the minimum of 2 values which are dij(k-1) and sum of dik(k-1) and dkj(k-1).</i><p><b>10. What happens when the value of k is 0 in the Floyd Warshall Algorithm?<br>
a) 1 intermediate vertex<br>
b) 0 intermediate vertex<br>
c) N intermediate vertices<br>
d) N-1 intermediate vertices<br>
</b></p><i>Answer: b<br>
Explanation: When k=0, a path from vertex i to vertex j has no intermediate vertices at all. Such a path has at most one edge and hence dij(0) = wij.  </i><p><b>15. What is the formula to compute the transitive closure of a graph?<br>
a) tij(k) = tij(k-1) AND (tik(k-1) OR tkj(k-1))<br>
b) tij(k) = tij(k-1) OR (tik(k-1) AND tkj(k-1))<br>
c) tij(k) = tij(k-1) AND (tik(k-1) AND tkj(k-1))<br>
d) tij(k) = tij(k-1) OR (tik(k-1) OR tkj(k-1))<br>
</b></p><i>Answer: a<br>
Explanation: In computers, logical operations on single bit values execute faster than arithmetic operations on integer words of data.</i><p><b>1. What does Maximum flow problem involve?<br>
a) finding a flow between source and sink that is maximum<br>
b) finding a flow between source and sink that is minimum<br>
c) finding the shortest path between source and sink<br>
d) computing a minimum spanning tree<br>
</b></p><i>Answer: a<br>
Explanation: The maximum flow problem involves finding a feasible flow between a source and a sink in a network that is maximum and not minimum.</i><p><b>3. What is the source?<br>
a) Vertex with no incoming edges<br>
b) Vertex with no leaving edges<br>
c) Centre vertex<br>
d) Vertex with the least weight<br>
</b></p><i>Answer: b<br>
Explanation: A network can have only one source and one sink inorder to find the feasible flow in a weighted connected graph.</i><p><b>4. Which algorithm is used to solve a maximum flow problem?<br>
a) Prim’s algorithm<br>
b) Kruskal’s algorithm<br>
c) Dijkstra’s algorithm<br>
d) Ford-Fulkerson algorithm<br>
</b></p><i>Answer: a<br>
Explanation: Vertex with no incoming edges is called as a source. Vertex with no leaving edges is called as a sink.</i><p><b>5. Does Ford- Fulkerson algorithm use the idea of?<br>
a) Naïve greedy algorithm approach<br>
b) Residual graphs<br>
c) Minimum cut<br>
d) Minimum spanning tree<br>
</b></p><i>Answer: d<br>
Explanation: Ford-fulkerson algorithm is used to compute the maximum feasible flow between a source and a sink in a network.</i><p><b>6. The first step in the naïve greedy algorithm is?<br>
a) analysing the zero flow<br>
b) calculating the maximum flow using trial and error<br>
c) adding flows with higher values<br>
d) reversing flow if required<br>
</b></p><i>Answer: b<br>
Explanation: Ford-Fulkerson algorithm uses the idea of residual graphs which is an extension of naïve greedy approach allowing undo operations.</i><p><b>7. Under what condition can a vertex combine and distribute flow in any manner?<br>
a) It may violate edge capacities<br>
b) It should maintain flow conservation<br>
c) The vertex should be a source vertex<br>
d) The vertex should be a sink vertex<br>
</b></p><i>Answer: a<br>
Explanation: The first step in the naïve greedy algorithm is to start with the zero flow followed by adding edges with higher values.</i><p><b>9. A simple acyclic path between source and sink which pass through only positive weighted edges is called?<br>
a) augmenting path<br>
b) critical path<br>
c) residual path<br>
d) maximum path<br>
</b></p><i>Answer: b<br>
Explanation: A vertex can combine and distribute flow in any manner but it should not violate edge capacities and it should maintain flow conservation.</i><p><b>10. In what time can an augmented path be found?<br>
a) O(|E| log |V|)<br>
b) O(|E|)<br>
c) O(|E|<sup>2</sup>)<br>
d) O(|E|<sup>2</sup> log |V|)<br>
</b></p><i>Answer: c<br>
Explanation: Initially, zero flow is computed. Then, computing flow= 7+1+5+2=15. Hence, maximum flow=15.</i><p><b>12. What is the running time of an unweighted shortest path algorithm whose augmenting path is the path with the least number of edges?<br>
a) O(|E|)<br>
b) O(|E||V|)<br>
c) O(|E|<sup>2</sup>|V|)<br>
d) O(|E| log |V|)<br>
</b></p><i>Answer: a<br>
Explanation: Augmenting path between source and sink is a simple path without cycles. Path consisting of zero slack edges is called critical path.</i><p><b>13. Who is the formulator of Maximum flow problem?<br>
a) Lester R. Ford and Delbert R. Fulkerson<br>
b) T.E. Harris and F.S. Ross<br>
c) Y.A. Dinitz<br>
d) Kruskal<br>
</b></p><i>Answer: b<br>
Explanation: An augmenting path can be found in O(|E|) mathematically by an unweighted shortest path algorithm.</i><p><b>14. What is the running time of Dinic’s blocking flow algorithm?<br>
a) O(V<sup>2</sup>E)<br>
b) O(VE<sup>2</sup>)<br>
c) O(V<sup>3</sup>)<br>
d) O(E max |f|)<br>
</b></p><i>Answer: a<br>
Explanation: Dinic’s algorithm includes construction of level graphs and resLidual graphs and finding of augmenting paths along with blocking flow and is faster than the Ford-Fulkerson algorithm.</i><p><b>15. How many constraints does flow have?<br>
a) one<br>
b) three<br>
c) two<br>
d) four<br>
</b></p><i>Answer: c<br>
Explanation: Each augmenting step takes O(|E|) using an unweighted shortest path algorithm yielding a O(|E|2|V|) bound on the running time.</i><p><b>1. Stable marriage problem is an example of?<br>
a) Branch and bound algorithm<br>
b) Backtracking algorithm<br>
c) Greedy algorithm<br>
d) Divide and conquer algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Stable marriage problem is an example for recursive algorithm because it recursively uses backtracking algorithm to find an optimal solution.</i><p><b>2. Which of the following algorithms does Stable marriage problem uses?<br>
a) Gale-Shapley algorithm<br>
b) Dijkstra’s algorithm<br>
c) Ford-Fulkerson algorithm<br>
d) Prim’s algorithm<br>
</b></p><i>Answer: a<br>
Explanation: Stable marriage problem uses Gale-Shapley algorithm. Maximum flow problem uses Ford-Fulkerson algorithm. Prim’s algorithm involves minimum spanning tree.</i><p><b>3. An optimal solution satisfying men’s preferences is said to be?<br>
a) Man optimal<br>
b) Woman optimal<br>
c) Pair optimal<br>
d) Best optimal<br>
</b></p><i>Answer: a<br>
Explanation: An optimal solution satisfying men’s preferences are said to be man optimal. An optimal solution satisfying woman’s preferences are said to be woman optimal.</i><p><b>4. When a free man proposes to an available woman, which of the following happens?<br>
a) She will think and decide<br>
b) She will reject<br>
c) She will replace her current mate<br>
d) She will accept<br>
</b></p><i>Answer: d<br>
Explanation: When a man proposes to an available woman, she will accept his proposal irrespective of his position on his preference list.</i><p><b>6. How many 2*2 matrices are used in this problem?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: a<br>
Explanation: If there are n couples such that a man and a woman are not married, and if they prefer each other to their actual partners, the assignment is unstable.</i><p><b>7. What happens when a free man approaches a married woman?<br>
a) She simply rejects him<br>
b) She simply replaces her mate with him<br>
c) She goes through her preference list and accordingly, she replaces her current mate with him<br>
d) She accepts his proposal<br>
</b></p><i>Answer: b<br>
Explanation: Two 2*2 matrices are used. One for men representing corresponding woman and ranking and the other for women.</i><p><b>8. In case of stability, how many symmetric possibilities of trouble can occur?<br>
a) 1<br>
b) 2<br>
c) 4<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: If the preference of the man is greater, she replaces her current mate with him, leaving her current mate free.</i><p><b>11. Who formulated a straight forward backtracking scheme for stable marriage problem?<br>
a) McVitie and Wilson<br>
b) Gale<br>
c) Ford and Fulkerson<br>
d) Dinitz<br>
</b></p><i>Answer: b<br>
Explanation: Possibilities- There might be a woman pw, preferred to w by m, who herself prefers m to be her husband and the same applies to man as well.</i><p><b>13. What is the prime task of the stable marriage problem?<br>
a) To provide man optimal solution<br>
b) To provide woman optimal solution<br>
c) To determine stability of marriage<br>
d) To use backtracking approach<br>
</b></p><i>Answer: a<br>
Explanation: W2 is married to M1. But the preference of W2 has M2 before M1. Hence, W2 replaces M1 with M2.</i><p><b>14. Which of the following problems is related to stable marriage problem?<br>
a) Choice of school by students<br>
b) N-queen problem<br>
c) Arranging data in a database<br>
d) Knapsack problem<br>
</b></p><i>Answer: c<br>
Explanation: M3 will approach W3 first. Since W3 is married and since her preference list has her current mate before M3, she rejects his proposal.</i><p><b>15. What is the efficiency of Gale-Shapley algorithm used in stable marriage problem?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(log N)<br>
</b></p><i>Answer: a<br>
Explanation: McVitie and Wilson formulated a much faster straight forward backtracking scheme for stable marriage problem. Ford and Fulkerson formulated Maximum flow problem.</i><p><b>1. _____________ is a matching with the largest number of edges.<br>
a) Maximum bipartite matching<br>
b) Non-bipartite matching<br>
c) Stable marriage<br>
d) Simplex<br>
</b></p><i>Answer: a<br>
Explanation: Maximum bipartite matching matches two elements with a property that no two edges share a vertex.</i><p><b>3. How many colours are used in a bipartite graph?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: a<br>
Explanation: Maximum matching is also called as maximum cardinality matching (i.e.) matching with the largest number of edges.</i><p><b>4. What is the simplest method to prove that a graph is bipartite?<br>
a) It has a cycle of an odd length<br>
b) It does not have cycles<br>
c) It does not have a cycle of an odd length<br>
d) Both odd and even cycles are formed<br>
</b></p><i>Answer: b<br>
Explanation: A bipartite graph is said to be two-colourable so that every edge has its vertices coloured in different colours.</i><p><b>5. A matching that matches all the vertices of a graph is called?<br>
a) Perfect matching<br>
b) Cardinality matching<br>
c) Good matching<br>
d) Simplex matching<br>
</b></p><i>Answer: c<br>
Explanation: It is not difficult to prove that a graph is bipartite if and only if it does not have a cycle of an odd length.</i><p><b>6. What is the length of an augmenting path?<br>
a) Even<br>
b) Odd<br>
c) Depends on graph<br>
d) 1<br>
</b></p><i>Answer: a<br>
Explanation: A matching that matches all the vertices of a graph is called perfect matching.</i><p><b>7. In a bipartite graph G=(V,U,E), the matching of a free vertex in V to a free vertex in U is called?<br>
a) Bipartite matching<br>
b) Cardinality matching<br>
c) Augmenting<br>
d) Weight matching<br>
</b></p><i>Answer: b<br>
Explanation: The length of an augmenting path in a bipartite graph is always said to be always odd.</i><p><b>9. Which one of the following is an application for matching?<br>
a) Proposal of marriage<br>
b) Pairing boys and girls for a dance<br>
c) Arranging elements in a set<br>
d) Finding the shortest traversal path<br>
</b></p><i>Answer: c<br>
Explanation: A simple path from a free vertex in V to a free vertex in U whose edges alternate between edges not in M and edges in M is called a augmenting path.</i><p><b>10. Which is the correct technique for finding a maximum matching in a graph?<br>
a) DFS traversal<br>
b) BFS traversal<br>
c) Shortest path traversal<br>
d) Heap order traversal<br>
</b></p><i>Answer: a<br>
Explanation: According to the theorem discovered by the French mathematician Claude Berge, it means that the current matching is maximal if there is no augmenting path.</i><p><b>11. The problem of maximizing the sum of weights on edges connecting matched pairs of vertices is?<br>
a) Maximum- mass matching<br>
b) Maximum bipartite matching<br>
c) Maximum weight matching<br>
d) Maximum node matching<br>
</b></p><i>Answer: b<br>
Explanation: Pairing boys and girls for a dance is a traditional example for matching. Proposal of marriage is an application of stable marriage problem.</i><p><b>12. What is the total number of iterations used in a maximum- matching algorithm?<br>
a) [n/2] <br>
b) [n/3] <br>
c) [n/2]+n<br>
d) [n/2]+1<br>
</b></p><i>Answer: b<br>
Explanation: The correct technique for finding a maximum matching in a bipartite graph is by using a Breadth First Search(BFS).</i><p><b>13. What is the efficiency of algorithm designed by Hopcroft and Karp?<br>
a) O(n+m)<br>
b) O(n(n+m)<br>
c) O(√n(n+m))<br>
d) O(n+2)<br>
</b></p><i>Answer: c<br>
Explanation: The problem is called as maximum weight matching which is similar to a bipartite matching. It is also called as assignment problem.</i><p><b>14. Who was the first person to solve the maximum matching problem?<br>
a) Jack Edmonds<br>
b) Hopcroft<br>
c) Karp<br>
d) Claude Berge<br>
</b></p><i>Answer: d<br>
Explanation: The total number of iterations cannot exceed [n/2]+1 where n=|V|+|U| denoting the number of vertices in the graph.</i><p><b>1. Which algorithm is used to solve a minimum cut algorithm?<br>
a) Gale-Shapley algorithm<br>
b) Ford-Fulkerson algorithm<br>
c) Stoer-Wagner algorithm<br>
d) Prim’s algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Minimum cut algorithm is solved using Stoer-Wagner algorithm. Maximum flow problem is solved using Ford-Fulkerson algorithm. Stable marriage problem is solved using Gale-Shapley algorithm.</i><p><b>2. ___________ is a partition of the vertices of a graph in two disjoint subsets that are joined by atleast one edge.<br>
a) Minimum cut<br>
b) Maximum flow<br>
c) Maximum cut<br>
d) Graph cut<br>
</b></p><i>Answer: a<br>
Explanation: Minimum cut is a partition of the vertices in a graph 4. in two disjoint subsets joined by one edge. It is a cut that is minimal in some sense.</i><p><b>5. ______________ separates a particular pair of vertices in a graph.<br>
a) line<br>
b) arc<br>
c) cut<br>
d) flow<br>
</b></p><i>Answer: a<br>
Explanation: Minimum cut algorithm is considered to be an extension of the maximum flow problem. Minimum cut is finding a cut that is minimal.</i><p><b>6. What is the minimum number of cuts that a graph with ‘n’ vertices can have?<br>
a) n+1<br>
b) n(n-1)<br>
c) n(n+1)/2<br>
d) n(n-1)/2<br>
</b></p><i>Answer: a<br>
Explanation: The given figure is a depiction of min cut problem since the graph is partitioned to find the minimum cut.</i><p><b>7. What is the running time of Karger’s algorithm to find the minimum cut in a graph?<br>
a) O(E)<br>
b) O(|V|<sup>2</sup>)<br>
c) O(V)<br>
d) O(|E|)<br>
</b></p><i>Answer: c<br>
Explanation: A cut separates a particular pair of vertices in a weighted undirected graph and has minimum possible weight.</i><p><b>8. _____________ is a family of combinatorial optimization problems in which a graph is partitioned into two or more parts with constraints.<br>
a) numerical problems<br>
b) graph partition<br>
c) network problems<br>
d) combinatorial problems<br>
</b></p><i>Answer: c<br>
Explanation: The mathematical formula for a graph with ‘n’ vertices can at the most have n(n-1)/2 distinct vertices.</i><p><b>10. __________ is a data structure used to collect a system of cuts for solving min-cut problem.<br>
a) Gomory-Hu tree<br>
b) Gomory-Hu graph<br>
c) Dancing tree<br>
d) AA tree<br>
</b></p><i>Answer: b<br>
Explanation: The running time of Karger’s algorithm to find the minimum cut is mathematically found to be O(|V|<sup>2</sup>).</i><p><b>11. In how many ways can a Gomory-Hu tree be implemented?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: Graph partition is a problem in which the graph is partitioned into two or more parts with additional conditions.</i><p><b>12. The running time of implementing naïve solution to min-cut problem is?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: According to max-flow min-cut theorem, the weight of the cut is equal to the maximum flow that is sent from source to sink.</i><p><b>13. What is the running time of implementing a min-cut algorithm using bidirected edges in a graph?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>4</sup>)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: Gomory-Hu tree is a weighted tree that contains the minimum cuts for all pairs in a graph. It is constructed in |V|-1 max-flow computations.</i><p><b>14. Which one of the following is not an application of max-flow min-cut algorithm?<br>
a) network reliability<br>
b) closest pair<br>
c) network connectivity<br>
d) bipartite matching<br>
</b></p><i>Answer: b<br>
Explanation: Gomory-Hu tree can be implemented in two ways- sequential and parallel.</i><p><b>1. Which of the following is not a type of graph in computer science?<br>
a) undirected graph<br>
b) bar graph<br>
c) directed graph<br>
d) weighted graph<br>
</b></p><i>Answer: b<br>
Explanation: According to the graph theory a graph is the collection of dots and lines. A bar graph is not a type of graph in computer science.</i><p><b>2. What is vertex coloring of a graph?<br>
a) A condition where any two vertices having a common edge should not have same color<br>
b) A condition where any two vertices having a common edge should always have same color<br>
c) A condition where all vertices should have a different color<br>
d) A condition where all vertices should have same color<br>
</b></p><i>Answer: a<br>
Explanation: The condition for vertex coloring of a graph is that two vertices which share a common edge should not have the same color. If it uses k colors in the process then it is called k coloring of graph.</i><p><b>3. How many edges will a tree consisting of N nodes have?<br>
a) Log(N)<br>
b) N<br>
c) N – 1<br>
d) N + 1<br>
</b></p><i>Answer: c<br>
Explanation: In order to have a fully connected tree it must have N-1 edges. So the correct answer will be N-1.</i><p><b>4. Minimum number of unique colors required for vertex coloring of a graph is called?<br>
a) vertex matching<br>
b) chromatic index<br>
c) chromatic number<br>
d) color number<br>
</b></p><i>Answer: c<br>
Explanation: The minimum number of colors required for proper vertex coloring of graph is called chromatic number whereas the minimum number of colors required for proper edge coloring of graph is called chromatic index of a graph.</i><p><b>5. How many unique colors will be required for proper vertex coloring of an empty graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: b<br>
Explanation: An empty graph is a graph without any edges. So the number of unique colors required for proper coloring of the graph will be 1.</i><p><b>6. How many unique colors will be required for proper vertex coloring of a bipartite graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: c<br>
Explanation: A bipartite graph is a graph such that no two vertices of the same set are adjacent to each other. So the number of unique colors required for proper coloring of the graph will be 2.</i><p><b>7. Which of the following is an NP complete problem?<br>
a) Hamiltonian cycle<br>
b) Travelling salesman problem<br>
c) Calculating chromatic number of graph<br>
d) Finding maximum element in an array<br>
</b></p><i>Answer: c<br>
Explanation: Calculating the chromatic number of a graph is an NP complete problem as a chromatic number of an arbitrary graph cannot be determined by using any convenient method.</i><p><b>8. How many unique colors will be required for proper vertex coloring of a line graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: d<br>
Explanation: A line graph of a simple graph is obtained by connecting two vertices with an edge. So the number of unique colors required for proper coloring of the graph will be n.</i><p><b>9. How many unique colors will be required for proper vertex coloring of a complete graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) n<br>
d) n!<br>
</b></p><i>Answer: c<br>
Explanation: A complete graph is the one in which each vertex is directly connected with all other vertices with an edge. So the number of unique colors required for proper coloring of the graph will be n.</i><p><b>10. Minimum number of colors required for proper edge coloring of a graph is called?<br>
a) Chromatic color<br>
b) Chromatic index<br>
c) Edge matching<br>
d) Color number<br>
</b></p><i>Answer: b<br>
Explanation: The minimum number of colors required for proper edge coloring of graph is called chromatic index. It is also known as edge chromatic number.</i><p><b>1. What is the definition of graph according to graph theory?<br>
a) visual representation of data<br>
b) collection of dots and lines<br>
c) collection of edges<br>
d) collection of vertices<br>
</b></p><i>Answer: b<br>
Explanation: According to the graph theory a graph is the collection of dots and lines. Vertices are also called dots and lines are also called edges.</i><p><b>2. What is the condition for proper coloring of a graph?<br>
a) two vertices having a common edge should not have same color<br>
b) two vertices having a common edge should always have same color<br>
c) all vertices should have a different color<br>
d) all vertices should have same color<br>
</b></p><i>Answer: a<br>
Explanation: The condition for proper coloring of graph is that two vertices which share a common edge should not have the same color. If it uses k colors in the process then it is called k coloring of graph.</i><p><b>3. The number of colors used by a proper coloring graph is called?<br>
a) k coloring graph<br>
b) x coloring graph<br>
c) m coloring graph<br>
d) n coloring graph<br>
</b></p><i>Answer: a<br>
Explanation: A proper graph ensures that two vertices which share a common edge should not have the same color. If it uses k colors in the process then it is called k coloring of graph.</i><p><b>4. What is a chromatic number?<br>
a) The maximum number of colors required for proper edge coloring of graph<br>
b) The maximum number of colors required for proper vertex coloring of graph<br>
c) The minimum number of colors required for proper vertex coloring of graph<br>
d) The minimum number of colors required for proper edge coloring of graph<br>
</b></p><i>Answer: c<br>
Explanation: The minimum number of colors required for proper vertex coloring of graph is called chromatic number whereas the minimum number of colors required for proper edge coloring of graph is called chromatic index of a graph.</i><p><b>5. What will be the chromatic number for an empty graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: b<br>
Explanation: An empty graph is a graph without any edges. So the chromatic number for such a graph will be 1.</i><p><b>6. What will be the chromatic number for an bipartite graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: c<br>
Explanation: A bipartite graph is graph such that no two vertices of the same set are adjacent to each other. So the chromatic number for such a graph will be 2.</i><p><b>7. Calculating the chromatic number of a graph is a<br>
a) P problem<br>
b) NP hard problem<br>
c) NP complete problem<br>
d) cannot be identified as any of the given problem types<br>
</b></p><i>Answer: c<br>
Explanation: Chromatic number of an arbitrary graph cannot be determined by using any convenient method. So calculating the chromatic number of a graph is an NP complete problem. </i><p><b>8. What will be the chromatic number for a line graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: d<br>
Explanation: A line graph of a simple graph is obtained by connecting two vertices with an edge. A line graph has a chromatic number of n.</i><p><b>9. What will be the chromatic number for a complete graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) n<br>
d) n!<br>
</b></p><i>Answer: c<br>
Explanation: A complete graph is the one in which each vertex is directly connected with all other vertices with an edge. So in such a case each vertex should have a unique color. Thus the chromatic number will be n.</i><p><b>10. What will be the chromatic number for a tree having more than 1 vertex?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) Varies with the structure and number of vertices of the tree<br>
</b></p><i>Answer: c<br>
Explanation: The minimum number of colors required for proper vertex coloring of graph is called chromatic number. So every tree having more than 1 vertex is 2 chromatic.  </i><p><b>11. A graph with chromatic number less than or equal to k is called?<br>
a) K chromatic<br>
b) K colorable<br>
c) K chromatic colorable<br>
d) K colorable chromatic<br>
</b></p><i>Answer: b<br>
Explanation: Any graph that has a chromatic number less than or equal to k is called k colorable. Whereas a graph with chromatic number k is called k chromatic.</i><p><b>1. In graph theory collection of dots and lines is called<br>
a) vertex<br>
b) edge<br>
c) graph<br>
d) map<br>
</b></p><i>Answer: c<br>
Explanation: According to the graph theory a graph is the collection of dots and lines. Vertices are also called dots and lines are also called edges.</i><p><b>2. What is the condition for proper edge coloring of a graph?<br>
a) Two vertices having a common edge should not have same color<br>
b) Two vertices having a common edge should always have same color<br>
c) No two incident edges should have the same color<br>
d) No two incident edges should have different color<br>
</b></p><i>Answer: c<br>
Explanation: The condition for proper edge coloring of graph is that no two incident edges should have the same color. If it uses k colors in the process then it is called k edge coloring of graph.</i><p><b>3. The number of colors used by a proper edge coloring graph is called?<br>
a) k edge coloring graph<br>
b) x edge coloring graph<br>
c) m edge coloring graph<br>
d) n edge coloring graph<br>
</b></p><i>Answer: a<br>
Explanation: A proper edge coloring graph ensures that no two incident edges has the same color. If it uses k colors in the process then it is called k coloring of graph.</i><p><b>4. What is a chromatic index?<br>
a) The maximum number of colors required for proper edge coloring of graph<br>
b) The maximum number of colors required for proper vertex coloring of graph<br>
c) The minimum number of colors required for proper vertex coloring of graph<br>
d) The minimum number of colors required for proper edge coloring of graph<br>
</b></p><i>Answer: d<br>
Explanation: The minimum number of colors required for proper edge coloring of graph is called chromatic index whereas the minimum number of colors required for proper vertex coloring of graph is called chromatic number of a graph.</i><p><b>5. What will be the chromatic index for an empty graph having n vertices?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) n<br>
</b></p><i>Answer: a<br>
Explanation: An empty graph is a graph without any edges. So the chromatic index for such a graph will be 0.</i><p><b>6. If chromatic number of a line graph is 4 then the chromatic index of the graph will be?<br>
a) 0<br>
b) 1<br>
c) 4<br>
d) information insufficient<br>
</b></p><i>Answer: c<br>
Explanation: The chromatic index of a graph is always equal to the chromatic number of its line graph. So the chromatic index of the graph will be 4.</i><p><b>7. Calculating the chromatic index of a graph is a ______________<br>
a) P problem<br>
b) NP hard problem<br>
c) NP complete problem<br>
d) Cannot be identified as any of the given problem types<br>
</b></p><i>Answer: c<br>
Explanation: Chromatic index of an arbitrary graph cannot be determined by using any convenient method. So calculating the chromatic index of a graph is an NP complete problem. </i><p><b>13. What will be the chromatic index for a complete graph having n vertices (consider n to be an odd number)?<br>
a) n<br>
b) n + 1<br>
c) n – 1<br>
d) 2n + 1<br>
</b></p><i>Answer: a<br>
Explanation: The chromatic index of a graph is always equal to the chromatic number of its line graph. So we can calculate the chromatic index of a graph by calculating the chromatic number of its line graph.</i><p><b>14. What will be the chromatic index for a complete graph having n vertices (consider n to be an even number)?<br>
a) n<br>
b) n + 1<br>
c) n – 1<br>
d) 2n + 1<br>
</b></p><i>Answer: a<br>
Explanation: A bipartite graph has an edge chromatic number equal to Δ. So bipartite graphs belongs to class 1 graphs.  </i><p><b>1. Given G is a bipartite graph and the bipartitions of this graphs are U and V respectively. What is the relation between them?<br>
a) Number of vertices in U = Number of vertices in V<br>
b) Sum of degrees of vertices in U = Sum of degrees of vertices in V<br>
c) Number of vertices in U &gt; Number of vertices in V<br>
d) Nothing can be said<br>
</b></p><i>Answer: b<br>
Explanation: We can prove this by induction. By adding one edge, the degree of vertices in U is equal to 1 as well as in V. Let us assume that this is true for n-1 edges and add one more edge. Since the given edge adds exactly once to both U and V we can tell that this statement is true for all n vertices.</i><p><b>2. A k-regular bipartite graph is the one in which degree of each vertices is k for all the vertices in the graph. Given that the bipartitions of this graph are U and V respectively. What is the relation between them?<br>
a) Number of vertices in U=Number of vertices in V<br>
b) Number of vertices in U not equal to number of vertices in V<br>
c) Number of vertices in U always greater than the number of vertices in V<br>
d) Nothing can be said<br>
</b></p><i>Answer: a<br>
Explanation: We know that in a bipartite graph sum of degrees of vertices in U=sum of degrees of vertices in V. Given that the graph is a k-regular bipartite graph, we have k*(number of vertices in U)=k*(number of vertices in V). </i><p><b>3. There are four students in a class namely A, B, C and D. A tells that a triangle is a bipartite graph. B tells pentagon is a bipartite graph. C tells square is a bipartite graph. D tells heptagon is a bipartite graph. Who among the following is correct?<br>
a) A<br>
b) B<br>
c) C<br>
d) D<br>
</b></p><i>Answer: c<br>
Explanation: We can prove it in this following way. Let ‘1’ be a vertex in bipartite set X and let ‘2’ be a vertex in the bipartite set Y. Therefore the bipartite set X contains all odd numbers and the bipartite set Y contains all even numbers. Now let us consider a graph of odd cycle (a triangle). There exists an edge from ‘1’ to ‘2’, ‘2’ to ‘3’ and ‘3’ to ‘1’. The latter case (‘3’ to ‘1’) makes an edge to exist in a bipartite set X itself. Therefore telling us that graphs with odd cycles are not bipartite.</i><p><b>4. A complete bipartite graph is a one in which each vertex in set X has an edge with set Y. Let n be the total number of vertices. For maximum number of edges, the total number of vertices hat should be present on set X is?<br>
a) n<br>
b) n/2<br>
c) n/4<br>
d) data insufficient<br>
</b></p><i>Answer: b<br>
Explanation: We can prove this by calculus. Let x be the total number of vertices on set X. Therefore set Y will have n-x. We have to maximize x*(n-x). This is true when x=n/2.</i><p><b>5. When is a graph said to be bipartite?<br>
a) If it can be divided into two independent sets A and B such that each edge connects a vertex from to A to B<br>
b) If the graph is connected and it has odd number of vertices<br>
c) If the graph is disconnected<br>
d) If the graph has at least n/2 vertices whose degree is greater than n/2<br>
</b></p><i>Answer: a<br>
Explanation: A graph is said to be bipartite if it can be divided into two independent sets A and B such that each edge connects a vertex from A to B.</i><p><b>6. Are trees bipartite?<br>
a) Yes<br>
b) No<br>
c) Yes if it has even number of vertices<br>
d) No if it has odd number of vertices<br>
</b></p><i>Answer: a<br>
Explanation: Condition needed is that there should not be an odd cycle. But in a tree there are no cycles at all. Hence it is bipartite.</i><p><b>7. A graph has 20 vertices. The maximum number of edges it can have is? (Given it is bipartite)<br>
a) 100<br>
b) 140<br>
c) 80<br>
d) 20<br>
</b></p><i>Answer: a<br>
Explanation: Let the given bipartition X have x vertices, then Y will have 20-x vertices. We need to maximize x*(20-x). This will be maxed when x=10.</i><p><b>9. Can there exist a graph which is both eulerian and is bipartite?<br>
a) Yes<br>
b) No<br>
c) Yes if it has even number of edges<br>
d) Nothing can be said<br>
</b></p><i>Answer: a<br>
Explanation: It is required that the graph is connected also. If it is not then it cannot be called a bipartite graph.</i><p><b>10. A graph is found to be 2 colorable. What can be said about that graph?<br>
a) The given graph is eulerian<br>
b) The given graph is bipartite<br>
c) The given graph is hamiltonian<br>
d) The given graph is planar<br>
</b></p><i>Answer: a<br>
Explanation: If a graph is such that there exists a path which visits every edge atleast once, then it is said to be Eulerian. Taking an example of a square, the given question evaluates to yes.</i><p><b>1. Which type of graph has no odd cycle in it?<br>
a) Bipartite<br>
b) Histogram<br>
c) Cartesian<br>
d) Pie<br>
</b></p><i>Answer: a<br>
Explanation: The graph is known as Bipartite if the graph does not contain any odd length cycle in it. Odd length cycle means a cycle with the odd number of vertices in it.</i><p><b>2. What type of graph has chromatic number less than or equal to 2?<br>
a) Histogram<br>
b) Bipartite<br>
c) Cartesian<br>
d) Tree<br>
</b></p><i>Answer: b<br>
Explanation: A graph is known as bipartite graph if and only if it has the total chromatic number less than or equal to 2. The smallest number of graphs needed to color the graph is chromatic number.</i><p><b>3. Which of the following is the correct type of spectrum of the bipartite graph?<br>
a) Symmetric<br>
b) Anti – Symmetric<br>
c) Circular<br>
d) Exponential<br>
</b></p><i>Answer: a<br>
Explanation: The spectrum of the bipartite graph is symmetric in nature. The spectrum is the property of graph that are related to polynomial, Eigen values, Eigen vectors of the matrix related to graph.</i><p><b>4. Which of the following is not a property of the bipartite graph?<br>
a) No Odd Cycle<br>
b) Symmetric spectrum<br>
c) Chromatic Number Is Less Than or Equal to 2<br>
d) Asymmetric spectrum<br>
</b></p><i>Answer: d<br>
Explanation: A graph is known to be bipartite if it has odd length cycle number. It also has symmetric spectrum and the bipartite graph contains the total chromatic number less than or equal to 2. </i><p><b>5. Which one of the following is the chromatic number of bipartite graph?<br>
a) 1<br>
b) 4<br>
c) 3<br>
d) 5<br>
</b></p><i>Answer: a<br>
Explanation: A graph is known as bipartite graph if and only if it has the total chromatic number less than or equal to 2. The smallest number of graphs needed to color the graph is the chromatic number.</i><p><b>6. Which graph has a size of minimum vertex cover equal to maximum matching?<br>
a) Cartesian<br>
b) Tree<br>
c) Heap<br>
d) Bipartite<br>
</b></p><i>Answer: d<br>
Explanation: The Konig’s theorem given the equivalence relation between the minimum vertex cover and the maximum matching in graph theory. Bipartite graph has a size of minimum vertex cover equal to maximum matching.</i><p><b>7. Which theorem gives the relation between the minimum vertex cover and maximum matching?<br>
a) Konig’s Theorem<br>
b) Kirchhoff’s Theorem<br>
c) Kuratowski’s Theorem<br>
d) Kelmans Theorem<br>
</b></p><i>Answer: a<br>
Explanation: The Konig’s theorem given the equivalence relation between the minimum vertex cover and the maximum matching in graph theory. Bipartite graph has a size of minimum vertex cover equal to maximum matching.</i><p><b>8. Which of the following is not a property of perfect graph?<br>
a) Compliment of Line Graph of Bipartite Graph<br>
b) Compliment of Bipartite Graph<br>
c) Line Graph of Bipartite Graph<br>
d) Line Graph<br>
</b></p><i>Answer: d<br>
Explanation: TThe Compliment of Line Graph of Bipartite Graph, Compliment of Bipartite Graph, Line Graph of Bipartite Graph and every Bipartite Graph is known as a perfect graph in graph theory. Normal line graph is not a perfect graph whereas line perfect graph is a graph whose line graph is a perfect graph.</i><p><b>9. Which of the following graphs don’t have chromatin number less than or equal to 2?<br>
a) Compliment of Line Graph of Bipartite Graph<br>
b) Compliment of Bipartite Graph<br>
c) Line Graph of Bipartite Graph<br>
d) Wheel graph<br>
</b></p><i>Answer: d<br>
Explanation: The perfect bipartite graph has chromatic number 2. Also, the Compliment of Line Graph of Bipartite Graph, Compliment of Bipartite Graph, Line Graph of Bipartite Graph and every Bipartite Graph is known as perfect graph in graph theory. Wheel graph Wn has chromatin number 3 if n is odd and 4 if n is even.</i><p><b>10. Which of the following has maximum clique size 2?<br>
a) Perfect graph<br>
b) Tree<br>
c) Histogram<br>
d) Cartesian<br>
</b></p><i>Answer: a<br>
Explanation: The perfect bipartite graph has clique size 2. Also, the clique size of Compliment of Line Graph of Bipartite Graph, Compliment of Bipartite Graph, Line Graph of Bipartite Graph and every Bipartite Graph is 2.</i><p><b>11. What is the chromatic number of compliment of line graph of bipartite graph?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The perfect bipartite graph has chromatic number 2. So the Compliment of Line Graph of Bipartite Graph, Compliment of Bipartite Graph, Line Graph of Bipartite Graph and every Bipartite Graph has chromatic number 2.</i><p><b>12. What is the clique size of the line graph of bipartite graph?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The perfect bipartite graph has clique size 2. So the clique size of Compliment of Line Graph of Bipartite Graph, Compliment of Bipartite Graph, Line Graph of Bipartite Graph and every Bipartite Graph is 2.</i><p><b>15. Which structure can be modelled by using Bipartite graph?<br>
a) Hypergraph<br>
b) Perfect Graph<br>
c) Hetero Graph<br>
d) Directed Graph<br>
</b></p><i>Answer: b<br>
Explanation: A graph is known as bipartite graph if and only if it has the total chromatic number less than or equal to 2. The smallest number of graphs needed to color the graph is the chromatic number. But the chromatic number cannot be negative.</i><p><b>1. Which type of graph has all the vertex of the first set connected to all the vertex of the second set?<br>
a) Bipartite<br>
b) Complete Bipartite<br>
c) Cartesian<br>
d) Pie<br>
</b></p><i>Answer: b<br>
Explanation: The graph is known as Bipartite if the graph does not contain any odd length cycle in it. The complete bipartite graph has all the vertex of first set connected to all the vertex of second set.</i><p><b>2. Which graph is also known as biclique?<br>
a) Histogram<br>
b) Complete Bipartite<br>
c) Cartesian<br>
d) Tree<br>
</b></p><i>Answer: b<br>
Explanation: A graph is known as complete bipartite graph if and only if it has all the vertex of first set connected to all the vertex of second set. Complete Bipartite graph is also known as Biclique.</i><p><b>3. Which term defines all the complete bipartite graph that are trees?<br>
a) Symmetric<br>
b) Anti – Symmetric<br>
c) Circular<br>
d) Stars<br>
</b></p><i>Answer: d<br>
Explanation: Star is a complete bipartite graph with one internal node and k leaves. Therefore, all complete bipartite graph which is trees are known as stars in graph theory.</i><p><b>4. How many edges does a n vertex triangle free graph contains?<br>
a) n<sup>2</sup><br>
b) n<sup>2</sup> + 2<br>
c) n<sup>2</sup> / 4<br>
d) n<sup>3</sup><br>
</b></p><i>Answer: c<br>
Explanation: A n vertex triangle free graph contains a total of n<sup>2</sup> / 4 number of edges. This is stated by Mantel’s Theorem which is a special case in Turan’s theorem for r=2. </i><p><b>5. Which graph is used to define the claw free graph?<br>
a) Bipartite Graph<br>
b) Claw Graph<br>
c) Star Graph<br>
d) Cartesian Graph<br>
</b></p><i>Answer: b<br>
Explanation: Star is a complete bipartite graph with one internal node and k leaves. Star with three edges is called a claw. Hence this graph is used to define claw free graph.</i><p><b>6. What is testing of a complete bipartite subgraph in a bipartite graph problem called?<br>
a) P Problem<br>
b) P-Complete Problem<br>
c) NP Problem<br>
d) NP-Complete Problem<br>
</b></p><i>Answer: d<br>
Explanation: NP stands for nondeterministic polynomial time. In a bipartite graph, the testing of a complete bipartite subgraph in a bipartite graph is an NP-Complete Problem.</i><p><b>7. Which graph cannot contain K3, 3 as a minor of graph?<br>
a) Planar Graph<br>
b) Outer Planar Graph<br>
c) Non Planar Graph<br>
d) Inner Planar Graph<br>
</b></p><i>Answer: a<br>
Explanation: Minor graph is formed by deleting certain number of edges from a graph or by deleting certain number off vertices from a graph. Hence Planar graph cannot contain K3, 3 as a minor graph.</i><p><b>8. Which of the following is not an Eigen value of the adjacency matrix of the complete bipartite graph?<br>
a) (nm)<sup>1/2</sup><br>
b) (-nm)<sup>1/2</sup><br>
c) 0<br>
d) nm<br>
</b></p><i>Answer: d<br>
Explanation: The adjacency matrix is a square matrix that is used to represent a finite graph. Therefore, the Eigen values for the complete bipartite graph is found to be (nm)<sup>1/2</sup>, (-nm)<sup>1/2</sup>, 0.</i><p><b>9. Which complete graph is not present in minor of Outer Planar Graph?<br>
a) K3, 3<br>
b) K3, 1<br>
c) K3, 2<br>
d) K1, 1<br>
</b></p><i>Answer: c<br>
Explanation: Minor graph is formed by deleting certain number of edges from a graph or by deleting certain number off vertices from a graph. Hence Outer Planar graph cannot contain K3, 2 as a minor graph.</i><p><b>11. What is the multiplicity for the adjacency matrix of complete bipartite graph for 0 Eigen value?<br>
a) 1<br>
b) n + m – 2<br>
c) 0<br>
d) 2<br>
</b></p><i>Answer: a<br>
Explanation: In graph theory, Moore graph is defined as a regular graph that has a degree d and diameter k. therefore, every complete bipartite graph is a Moore Graph.</i><p><b>12. Which of the following is not an Eigen value of the Laplacian matrix of the complete bipartite graph?<br>
a) n + m<br>
b) n<br>
c) 0<br>
d) n*m<br>
</b></p><i>Answer: b<br>
Explanation: The adjacency matrix is a square matrix that is used to represent a finite graph. The multiplicity of the adjacency matrix off complete bipartite graph with Eigen Value 0 is n + m – 2.</i><p><b>13. What is the multiplicity for the laplacian matrix of the complete bipartite graph for n Eigen value?<br>
a) 1<br>
b) m-1<br>
c) n-1<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: The laplacian matrix is used to represent a finite graph in the mathematical field of Graph Theory. Therefore, the Eigen values for the complete bipartite graph is found to be n + m, n, m, 0.</i><p><b>15. How many spanning trees does a complete bipartite graph contain?<br>
a) n<sup>m</sup><br>
b) m<sup>n-1</sup> * n<sup>n-1</sup><br>
c) 1<br>
d) 0<br>
</b></p><i>Answer: b<br>
Explanation: The laplacian matrix is used to represent a finite graph in the mathematical field of Graph Theory. The multiplicity of the laplacian matrix of complete bipartite graph with Eigen Value n is m-1.</i><p><b>1. Recursion is a method in which the solution of a problem depends on ____________<br>
a) Larger instances of different problems<br>
b) Larger instances of the same problem<br>
c) Smaller instances of the same problem<br>
d) Smaller instances of different problems<br>
</b></p><i>Answer: c<br>
Explanation: In recursion, the solution of a problem depends on the solution of smaller instances of the same problem.</i><p><b>2. Which of the following problems can’t be solved using recursion?<br>
a) Factorial of a number<br>
b) Nth fibonacci number<br>
c) Length of a string<br>
d) Problems without base case<br>
</b></p><i>Answer: d<br>
Explanation: Problems without base case leads to infinite recursion call. In general, we will assume a base case to avoid infinite recursion call. Problems like finding Factorial of a number, Nth Fibonacci number and Length of a string can be solved using recursion. </i><p><b>3. Recursion is similar to which of the following?<br>
a) Switch Case<br>
b) Loop<br>
c) If-else<br>
d) if elif else<br>
</b></p><i>Answer: b<br>
Explanation: Recursion is similar to a loop.</i><p><b>4. In recursion, the condition for which the function will stop calling itself is ____________<br>
a) Best case<br>
b) Worst case<br>
c) Base case<br>
d) There is no such condition<br>
</b></p><i>Answer: c<br>
Explanation: For recursion to end at some point, there always has to be a condition for which the function will not call itself. This condition is known as base case.</i><p><b>5. What will happen when the below code snippet is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
   my_recursive_function<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
   my_recursive_function<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) The code will be executed successfully and no output will be generated<br>
b) The code will be executed successfully and random output will be generated<br>
c) The code will show a compile time error<br>
d) The code will run for some time and stop when the stack overflows<br>
</b></p><i>Answer: d<br>
Explanation: Every function call is stored in the stack memory. In this case, there is no terminating condition(base case). So, my_recursive_function() will be called continuously till the stack overflows and there is no more space to store the function calls. At this point of time, the program will stop abruptly.</i><p><b>6. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
    <span class="kw1">return</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
    my_recursive_function<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    my_recursive_function<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 10<br>
b) 1<br>
c) 10 9 8 …   1 0<br>
d) 10 9 8 …   1<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the numbers from 10 to 1.</i><p><b>7. What is the  base case for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
     <span class="kw1">return</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     my_recursive_function<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) return<br>
b) printf(“%d “, n)<br>
c) if(n == 0)<br>
d) my_recursive_function(n-1)<br>
</b></p><i>Answer: c<br>
Explanation: For the base case, the recursive function is not called. So, “if(n == 0)” is the base case.</i><p><b>8. How many times is the recursive function called, when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
     <span class="kw1">return</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     my_recursive_function<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The recursive function is called 11 times.</i><p><b>a) 9<br>
b) 10<br>
c) 11<br>
d) 12<br>
</b></p><i>Answer: c<br>
Explanation: The above code prints the numbers from 1 to 10.</i><p><b>9. What does the following recursive code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
     <span class="kw1">return</span><span class="sy0">;</span>
     my_recursive_function<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span><span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Prints the numbers from 10 to 1<br>
b) Prints the numbers from 10 to 0<br>
c) Prints the numbers from 1 to 10<br>
d) Prints the numbers from 0 to 10<br>
</b></p><i>Answer: b<br>
Explanation: Recursion uses more memory compared to iteration because every time the recursive function is called, the function call is stored in stack.</i><p><b>10. Which of the following statements is true?<br>
a) Recursion is always better than iteration<br>
b) Recursion uses more memory compared to iteration<br>
c) Recursion uses less memory compared to iteration<br>
d) Iteration is always better and simpler than recursion<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the number of digits in the number 123456789, which is 9.</i><p><b>11. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> cnt<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
     <span class="kw1">return</span><span class="sy0">;</span>
     cnt<span class="sy0">++;</span>
     my_recursive_function<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="nu0">123456789</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cnt<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 123456789<br>
b) 10<br>
c) 0<br>
d) 9<br>
</b></p><i>Answer: b<br>
Explanation: The function checks if a number is a power of 2. Since 100 is not a power of 2, it prints false.</i><p><b>12. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"False"</span><span class="br0">)</span><span class="sy0">;</span>
	   <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"True"</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">%</span><span class="nu19">2</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
    my_recursive_function<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
    <span class="br0">{</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"False"</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
&nbsp;
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> i<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span>
        <span class="kw1">return</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'a'</span> <span class="sy0">||</span> s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'e'</span> <span class="sy0">||</span> s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'i'</span> <span class="sy0">||</span> s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'o'</span> <span class="sy0">||</span> s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'u'</span><span class="br0">)</span>
     cnt<span class="sy0">++;</span>
     my_recursive_function<span class="br0">(</span>s<span class="sy0">,</span>i<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     my_recursive_function<span class="br0">(</span><span class="st0">"thisisrecursion"</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cnt<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The function counts the number of vowels in a string. In this case the number is vowels is 6.</i><p><b>a) 6<br>
b) 9<br>
c) 5<br>
d) 10<br>
</b></p><i>Answer: b<br>
Explanation: The program searches for a value in the given array and prints the index at which the value is found. In this case, the program searches for value = 2. Since, the index of 2 is 4(0 based indexing), the program prints 4.</i><p><b>14. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> my_recursive_function<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> val<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"-1"</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="kw1">return</span> <span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> val<span class="br0">)</span>
    <span class="br0">{</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
         <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    my_recursive_function<span class="br0">(</span>arr<span class="sy0">,</span>val<span class="sy0">,</span>idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> array<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">8</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> value <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
     my_recursive_function<span class="br0">(</span>array<span class="sy0">,</span> value<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 3<br>
b) 4<br>
c) 5<br>
d) 6<br>
</b></p><i>undefined</i><p><b>1. In general, which of the following methods isn’t used to find the factorial of a number?<br>
a) Recursion<br>
b) Iteration<br>
c) Dynamic programming<br>
d) Non iterative / recursive<br>
</b></p><i>Answer: d<br>
Explanation: In general we use recursion, iteration and dynamic programming to find the factorial of a number. We can also implement without using iterative / recursive method by using tgammal() method. Most of us never use it generally.</i><p><b>2. Which of the following recursive formula can be used to find the factorial of a number?<br>
a) fact(n) = n * fact(n)<br>
b) fact(n) = n * fact(n+1)<br>
c) fact(n) = n * fact(n-1)<br>
d) fact(n) = n * fact(1)<br>
</b></p><i>Answer: c<br>
Explanation: fact(n) = n * fact(n – 1) can be used to find the factorial of a number.</i><p><b>3. Consider the following iterative implementation to find the factorial of a number. Which of the lines should be inserted to complete the below code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span> i<span class="sy0">;</span>
    <span class="kw4">int</span> fact <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      _________<span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>fact<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) fact = fact + i<br>
b) fact = fact * i<br>
c) i = i * fact<br>
d) i = i + fact<br>
</b></p><i>Answer: b<br>
Explanation: The line “fact = fact * i” should be inserted to complete the above code.</i><p><b>4. Consider the following recursive implementation to find the factorial of a number. Which of the lines should be inserted to complete the below code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>_________<span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) n = 0<br>
b) n != 0<br>
c) n == 0<br>
d) n == 1<br>
</b></p><i>Answer: c<br>
Explanation: The line “n == 0” should be inserted to complete the above code.<br>
Note: “n == 1” cannot be used because it does not take care of the case when n = 0, i.e when we want to find the factorial of 0.</i><p><b>5. The time complexity of the following recursive implementation to find the factorial of a number is ________</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>_________<span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation to find the factorial of a number is O(n).</i><p><b>6. What is the space complexity of the following recursive implementation to find the factorial of a number?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>_________<span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The space complexity of the above recursive implementation to find the factorial of a number is O(1).</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The line “if(n == 0)” is the base case.</i><p><b>7. Consider the following recursive implementation to find the factorial of a number. Which of the lines is the base case?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) return 1<br>
b) return n * fact(n-1)<br>
c) if(n == 0)<br>
d) if(n == 1)<br>
</b></p><i>Answer: b<br>
Explanation: The program prints 0!, which is 1.</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: The program prints 1!, which is 1.</i><p><b>9. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The fact() function will be called 6 times with the following arguments:<br>
fact(5), fact(4), fact(3), fact(2), fact(1), fact(0).</i><p><b>10. How many times will the function fact() be called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The function prints 5!, which is 120.</i><p><b>a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>undefined</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">*</span> fact<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> fact<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 24<br>
b) 120<br>
c) 720<br>
d) 1<br>
</b></p><i>undefined</i><p><b>1. Suppose the first fibonnaci number is 0 and the second is 1. What is the sixth fibonnaci number?<br>
a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: a<br>
Explanation: The sixth fibonnaci number is 5.</i><p><b>2. Which of the following is not a fibonnaci number?<br>
a) 8<br>
b) 21<br>
c) 55<br>
d) 14<br>
</b></p><i>Answer: d<br>
Explanation: 14 is not a fibonnaci number.</i><p><b>3. Which of the following option is wrong?<br>
a) Fibonacci number can be calculated by using Dynamic programming<br>
b) Fibonacci number can be calculated by using Recursion method<br>
c) Fibonacci number can be calculated by using Iteration method<br>
d) No method is defined to calculate Fibonacci number<br>
</b></p><i>Answer: d<br>
Explanation: Fibonacci number can be calculated by using Dynamic Programming, Recursion method, Iteration Method.</i><p><b>4. Consider the following iterative implementation to find the nth fibonacci number?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span>  n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span>i<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"0"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"1"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> a <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> b <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">,</span> c<span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="br0">{</span>
            c <span class="sy0">=</span> a <span class="sy0">+</span> b<span class="sy0">;</span>
            ________<span class="sy0">;</span>
			________<span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
   <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>5. Which of the following recurrence relations can  be used to find the nth fibonacci number?<br>
a) F(n) = F(n) + F(n – 1)<br>
b) F(n) = F(n) + F(n + 1)<br>
c) F(n) = F(n – 1)<br>
d) F(n) = F(n – 1) + F(n – 2)<br>
</b></p><i>Answer: b<br>
Explanation: The lines “a = b” and “b = c” should be added to complete the above code.</i><p><b>6. Consider the following recursive implementation to find the nth fibonacci number:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> ________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) fibo(n – 1)<br>
b) fibo(n – 1) + fibo(n – 2)<br>
c) fibo(n) + fibo(n – 1)<br>
d) fibo(n – 2) + fibo(n – 1)<br>
</b></p><i>Answer: d<br>
Explanation: The relation F(n) = F(n – 1) + F(n – 2) can be used to find the nth fibonacci number.</i><p><b>7. Consider the following recursive implementation to find the nth fibonnaci number:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following is the base case?<br>
a) if(n == 1)<br>
b) else if(n == 2)<br>
c) return fibo(n – 1) + fibo(n – 2)<br>
d) both if(n == 1) and else if(n == 2)<br>
</b></p><i>Answer: b<br>
Explanation: The line fibo(n – 1) + fibo(n – 2) should be inserted to complete the above code.</i><p><b>8. What is the time complexity of the following recursive implementation to find the nth fibonacci number?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: Both if(n == 1) and else if(n == 2) are the base cases.</i><p><b>a) O(1)<br>
b) O(2*n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above recursive implementation to find the nth fibonacci number is O(2<sup>n</sup>).</i><p><b>9. What is the space complexity of the following recursive implementation to find the nth fibonacci number?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(2*n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The space complexity of the above recursive implementation to find the nth fibonacci number is O(1).</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: d<br>
Explanation: Since negative numbers are not handled by the program, the function fibo() will be called infinite times and the program will produce a runtime error when the stack overflows.</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 5<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the 5th fibonacci number, which is 3.</i><p><b>12. How many times will the function fibo() be called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The function fibo() will be called 9 times, when the above code is executed.</i><p><b>a) 5<br>
b) 6<br>
c) 8<br>
d) 9<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the 10th fibonacci number, which is 34.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span> 
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> fibo<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 21<br>
b) 34<br>
c) 55<br>
d) 13<br>
</b></p><i>undefined</i><p><b>1. Which of the following option is wrong about natural numbers?<br>
a) Sum of first n natural numbers can be calculated by using Iteration method<br>
b) Sum of first n natural numbers can be calculated by using Recursion method<br>
c) Sum of first n natural numbers can be calculated by using Binomial coefficient method<br>
d) No method is prescribed to calculate sum of first n natural number<br>
</b></p><i>Answer: d<br>
Explanation: All of the above mentioned methods can be used to find the sum of first n natural numbers.</i><p><b>2. Which of the following gives the sum of the first n natural numbers?<br>
a) nC2<br>
b) (n-1)C2<br>
c) (n+1)C2<br>
d) (n+2)C2<br>
</b></p><i>Answer: c<br>
Explanation: The sum of first n natural numbers is given by n*(n+1)/2, which is equal to (n+1)C2.</i><p><b>3. Consider the following iterative solution to find the sum of first n natural numbers:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        ________<span class="sy0">;</span>
      <span class="kw1">return</span> sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> get_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines completes the above code?<br>
a) sm = i<br>
b) sm += i<br>
c) i = sm<br>
d) i += sm<br>
</b></p><i>Answer: b<br>
Explanation: The line “sm += i” completes the above code.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm<span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        sm <span class="sy0">+=</span> i<span class="sy0">;</span>
      <span class="kw1">return</span> sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> get_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 55<br>
b) 45<br>
c) 35<br>
d) Depends on compiler<br>
</b></p><i>Answer: d<br>
Explanation: Since the variable “sm” is not initialized to 0, it will produce a garbage value. Some compiler will automatically initialises variables to 0 if not initialised. In that case the value is 55. Hence the value depends on the compiler.</i><p><b>5. What is the time complexity of the following iterative method used to find the sum of the first n natural numbers?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm<span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        sm <span class="sy0">+=</span> i<span class="sy0">;</span>
      <span class="kw1">return</span> sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> get_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above iterative method used to find the sum of first n natural numbers is O(n).</i><p><b>6. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> ________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The recurrence relation for the above code is: n + recursive_sum(n – 1).</i><p><b>Which of the following lines is the recurrence relation for the above code?<br>
a) (n – 1) +recursive_sum(n)<br>
b) n + recursive_sum(n)<br>
c) n + recursive_sum(n – 1)<br>
d) (n – 1) + recursive_sum(n – 1)<br>
</b></p><i>Answer: a<br>
Explanation: “if(n == 0)” is the base case for the above recursive code.</i><p><b>7. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following is the base case for the above recursive code?<br>
a) if(n == 0)<br>
b) return 0<br>
c) return n + recursive_sum(n – 1)<br>
d) if(n == 1)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation used to find the sum of first n natural numbers is O(n).</i><p><b>8. What is the time complexity of the following recursive implementation used to find the sum of the first n natural numbers?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: Recursion and iteration take O(n) time to find the sum of first n natural numbers while binomial coefficient takes O(1) time.</i><p><b>9. Which of the following methods used to find the sum of first n natural numbers has the least time complexity?<br>
a) Recursion<br>
b) Iteration<br>
c) Binomial coefficient<br>
d) All have equal time complexity<br>
</b></p><i>Answer: b<br>
Explanation: The above code prints the sum of first 5 natural numbers, which is 15.</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 10<br>
b) 15<br>
c) 21<br>
d) 14<br>
</b></p><i>Answer: c<br>
Explanation: The function recursive_sum is called 6 times when the following code is executed.</i><p><b>11. How many times is the function recursive_sum() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The program prints the sum of first 0 natural numbers, which is 0.</i><p><b>a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>Answer: d<br>
Explanation: The above code doesn’t handle the case of negative numbers and so the function recursive_sum() will be called again and again till the stack overflows and the program produces a runtime error.</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) -1<br>
b) 0<br>
c) 1<br>
d) runtime error<br>
</b></p><i>undefined</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">+</span> recursive_sum<span class="br0">(</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) -10<br>
c) 1<br>
d) runtime error<br>
</b></p><i>undefined</i><p><b>1. Which of the following is not another name for GCD(Greatest Common Divisor)?<br>
a) LCM<br>
b) GCM<br>
c) GCF<br>
d) HCF<br>
</b></p><i>Answer: a<br>
Explanation: : LCM (Least Common Multiple) and GCD are not same. GCM (Greatest Common Measure), GCF (Greatest Common Factor), HCF (Highest Common Factor) are other names for GCD.</i><p><b>2. What is the GCD of 8 and 12?<br>
a) 8<br>
b) 12<br>
c) 2<br>
d) 4<br>
</b></p><i>Answer: d<br>
Explanation: GCD is largest positive integer that divides each of the integer. So the GCD of 8 and 12 is 4.</i><p><b>3. If GCD of two number is 8 and LCM is 144, then what is the second number if first number is 72?<br>
a) 24<br>
b) 2<br>
c) 3<br>
d) 16<br>
</b></p><i>Answer: d<br>
Explanation: As A * B = GCD (A, B) * LCM (A, B). So B = (144 * 8)/72 = 16.</i><p><b>4. Which of the following is also known as GCD?<br>
a) Highest Common Divisor<br>
b) Highest Common Multiple<br>
c) Highest Common Measure<br>
d) Lowest Common Multiple<br>
</b></p><i>Answer: a<br>
Explanation: GCM (Greatest Common Measure), GCF (Greatest Common Factor), HCF (Highest Common Factor) and HCF (Highest Common Divisor) are also known as GCD.</i><p><b>5. Which of the following is coprime number?<br>
a) 54 and 24<br>
b) 4 and 8<br>
c) 6 and 12<br>
d) 9 and 28<br>
</b></p><i>Answer: d<br>
Explanation: Coprime numbers have GCD 1. So 9 and 28 are coprime numbers. While 54 and 24 have GCD 6, 4 and 8 have GCD 4, 6 and 12 have GCD 6.</i><p><b>6. In terms of Venn Diagram, which of the following expression gives GCD (Given A ꓵ B ≠ Ø)?<br>
a) Multiplication of A U B terms<br>
b) Multiplication of A ꓵ B terms<br>
c) Multiplication of A*B terms<br>
d) Multiplication of A-B terms<br>
</b></p><i>Answer: b<br>
Explanation: In terms of Venn Diagram, the GCD is given by the intersection of two sets. So A ꓵ B gives the GCD. While A U B gives the LCM.</i><p><b>8. What is the GCD of a and b?<br>
a) a + b<br>
b) gcd (a-b, b) if a&gt;b<br>
c) gcd (a+b, a-b)<br>
d) a – b<br>
</b></p><i>Answer: c<br>
Explanation: In terms of Venn Diagram, the GCD is given by the intersection of two sets. So A ꓵ B gives the GCD. While A U B gives the LCM. So here A ꓵ B is 5.</i><p><b>9. What is the GCD of 48, 18, 0?<br>
a) 24<br>
b) 2<br>
c) 3<br>
d) 6<br>
</b></p><i>Answer: b<br>
Explanation: As per Euclid’s Algorithm, gcd (a, b) = gcd (a-b, b) if a &gt; b or gcd (a, b) = gcd (a, b-a) if b &gt; a.</i><p><b>11. If gcd (a, b) is defined by the expression, d=a*p + b*q where d, p, q are positive integers and a, b is both not zero, then what is the expression called?<br>
a) Bezout’s Identity<br>
b) Multiplicative Identity<br>
c) Sum of Product<br>
d) Product of Sum<br>
</b></p><i>Answer: d<br>
Explanation: GCD is largest positive integer that divides each of the integer. So the GCD of 48, 18, 0 is 6.</i><p><b>13. Which is the correct term of the given relation, gcd (a, b) * lcm (a, b) =?<br>
a) |a*b|<br>
b) a + b<br>
c) a – b<br>
d) a / b<br>
</b></p><i>Answer: a<br>
Explanation: Coprime numbers have GCD 1. So 9 and 28 are coprime numbers.</i><p><b>14. Who gave the expression for the probability and expected value of gcd?<br>
a) James E. Nymann<br>
b) Riemann<br>
c) Thomae<br>
d) Euler<br>
</b></p><i>Answer: a<br>
Explanation: If gcd (a, b) is defined by the expression, d=a*p + b*q where d, p, q are positive integers and a, b is both not zero, then the expression is called Bezout’s Identity and p, q can be calculated by extended form of Euclidean algorithm.</i><p><b>15. What is the computational complexity of Binary GCD algorithm where a and b are integers?<br>
a) O (log a + log b)<sup>2</sup>)<br>
b) O (log (a + b))<br>
c) O (log ab)<br>
d) O (log a-b)<br>
</b></p><i>Answer: a<br>
Explanation: The gcd function is an associative function as gcd (a, gcd (b, c)) = gcd (gcd (a, b), c).</i><p><b>1. LCM is also called as ________<br>
a) GCD<br>
b) SCM<br>
c) GCF<br>
d) HCF<br>
</b></p><i>Answer: b<br>
Explanation: GCD (Greatest Common Divisor), GCF (Greatest Common Factor), HCF (Highest Common Factor) is not an alias for LCM. LCM is also called as Smallest Common Multiple(SCM). </i><p><b>2. What is the LCM of 8 and 13?<br>
a) 8<br>
b) 12<br>
c) 20<br>
d) 104<br>
</b></p><i>Answer: d<br>
Explanation: 104 is the smallest positive integer that is divisible by both 8 and 12.</i><p><b>3. Which is the smallest number of 3 digits that is divisible by 2, 4, 8?<br>
a) 100<br>
b) 102<br>
c) 116<br>
d) 104<br>
</b></p><i>Answer: d<br>
Explanation: LCM of 2, 4, 8 is 8. So check for the number that is divisible by 8. So 104 is the smallest number that is divisible by 2, 4, 8.</i><p><b>4. Which of the following is also known as LCM?<br>
a) Lowest Common Divisor<br>
b) Least Common Multiple<br>
c) Lowest Common Measure<br>
d) Highest Common Multiple<br>
</b></p><i>Answer: a<br>
Explanation: Least Common Multiple is also known as LCM or Lowest Common Multiple.</i><p><b>5. What is the LCM of two coprime numbers?<br>
a) 1<br>
b) 0<br>
c) Addition of two coprime numbers<br>
d) Multiplication of two coprime numbers<br>
</b></p><i>Answer: d<br>
Explanation: Coprime numbers have GCD 1. While LCM of coprime numbers is the product of those two coprime numbers.</i><p><b>6. In terms of Venn Diagram, which of the following expression gives LCM (Given A ꓵ B ≠ Ø)?<br>
a) Multiplication of A U B terms<br>
b) Multiplication of A ꓵ B terms<br>
c) Multiplication of A*B terms<br>
d) Multiplication of A-B terms<br>
</b></p><i>Answer: a<br>
Explanation: In terms of Venn Diagram, the LCM is given by the Union of two sets. So A U B gives the LCM. While A ꓵ B gives the GCD.</i><p><b>8. What is the lcm (a, b)?<br>
a) a + b<br>
b) gcd (a-b, b) if a&gt;b<br>
c) lcm (b, a)<br>
d) a – b<br>
</b></p><i>Answer: c<br>
Explanation: In terms of Venn Diagram, the LCM is given by the Union of two sets. So A U B gives the LCM. So product of all the terms is 180.</i><p><b>9. What is the LCM of 48, 18, 6?<br>
a) 12<sup>2</sup><br>
b) 12*2<br>
c) 3<br>
d) 6<br>
</b></p><i>Answer: c<br>
Explanation: Since the LCM function is commutative, so lcm (a, b) = lcm (b, a).</i><p><b>11. What is the following expression, lcm (a, lcm (b, c) equal to?<br>
a) lcm (a, b, c)<br>
b) a*b*c<br>
c) a + b + c<br>
d) lcm (lcm (a, b), c)<br>
</b></p><i>Answer: a<br>
Explanation: The LCM of 48, 18, 6 is 144 and 12<sup>2</sup> is 144.</i><p><b>13. Which is the correct term of the given relation, lcm (a, b) * gcd (a, b) =?<br>
a) |a*b|<br>
b) a + b<br>
c) a – b<br>
d) a / b<br>
</b></p><i>Answer: a<br>
Explanation: Coprime numbers have GCD 1 and LCM is the product of the two given terms. So 9 and 28 are coprime numbers.</i><p><b>14. What is the following expression, lcm (a, gcd (a, b)) equal to?<br>
a) a<br>
b) b<br>
c) a*b<br>
d) a + b<br>
</b></p><i>Answer: d<br>
Explanation: Since LCM function follows associativity, hence lcm (a, lcm (b, c) is equal to lcm (lcm (a, b), c).</i><p><b>15. Which algorithm is the most efficient numerical algorithm to obtain lcm?<br>
a) Euler’s Algorithm<br>
b) Euclid’s Algorithm<br>
c) Chebyshev Function<br>
d) Partial Division Algorithm<br>
</b></p><i>Answer: a<br>
Explanation: The lcm function is an associative function as lcm (a, lcm (b, c) is equal to lcm (lcm (a, b), c).</i><p><b>1. Which of the following methods can be used to find the sum of digits of a number?<br>
a) Recursion<br>
b) Iteration<br>
c) Greedy algorithm<br>
d) Both recursion and iteration<br>
</b></p><i>Answer: d<br>
Explanation: Both recursion and iteration can be used to find the sum of digits of a number.</i><p><b>2. What can be the maximum sum of digits for a 4 digit number?<br>
a) 1<br>
b) 16<br>
c) 36<br>
d) 26<br>
</b></p><i>Answer: c<br>
Explanation: The sum of digits will be maximum when all the digits are 9. Thus, the sum will be maximum for the number 9999, which is 36.</i><p><b>3. What can be the minimum sum of digits for a 4 digit number?<br>
a) 0<br>
b) 1<br>
c) 16<br>
d) 36<br>
</b></p><i>Answer: b<br>
Explanation: The sum of digits will be minimum for the number 1000 and the sum is 1.</i><p><b>4. Consider the following iterative implementation to find the sum of digits of a number:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          _________<span class="sy0">;</span>
          n <span class="sy0">/=</span> <span class="nu0">10</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1234</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) sm += n<br>
b) sm += n%10<br>
c) sm += n-10<br>
d) sm += n/10<br>
</b></p><i>Answer: b<br>
Explanation: The line “sm += n % 10” adds the last digit(LSB) of the number to the current sum. Thus, the line “sm += n%10” should be added to complete the above code.</i><p><b>5. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          sm <span class="sy0">+=</span> n<span class="sy0">%</span><span class="nu19">10</span><span class="sy0">;</span>
          n <span class="sy0">/=</span> <span class="nu0">10</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1234</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 3<br>
c) 7<br>
d) 10<br>
</b></p><i>Answer: d<br>
Explanation: The above code prints the sum of digits of the number 1234, which is 10.</i><p><b>6. Consider the following recursive implementation to find the sum of digits of number:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> _________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1201</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) (n / 10) + recursive_sum_of_digits(n % 10)<br>
b) (n) + recursive_sum_of_digits(n % 10)<br>
c) (n % 10) + recursive_sum_of_digits(n / 10)<br>
d) (n % 10) + recursive_sum_of_digits(n % 10)<br>
</b></p><i>Answer: c<br>
Explanation: The line “(n % 10) + recursive_sum_of_digits(n / 10)” should be inserted to complete the above code.</i><p><b>7. What is the time complexity of the following recursive implementation to find the sum of digits of a number n?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> _________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1201</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The time complexity of the above recursive implementation to find the sum of digits of a number is O(len(n)).</i><p><b>a) O(n)<br>
b) O(1)<br>
c) O(len(n)), where len(n) is the number of digits in n<br>
d) O(1/2)<br>
</b></p><i>Answer: b<br>
Explanation: The above code prints the sum of digits of the number 1234321, which is 16.</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">+</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1234321</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 10<br>
b) 16<br>
c) 15<br>
d) 14<br>
</b></p><i>Answer: c<br>
Explanation: The function recursive_sum_of_digits() is called 8 times, when the following code is executed.</i><p><b>9. How many times is the function recursive_sum_of_digits() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">+</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1201</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 6<br>
b) 7<br>
c) 5<br>
d) 9<br>
</b></p><i>Answer: d<br>
Explanation: None of the above mentioned base cases can replace the base case if(n == 0) return 0.</i><p><b>10. You have to find the sum of digits of a number given that the number is always greater than 0. Which of the following base cases can replace the base case for the below code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">+</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">1201</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) if(n == 0) return 1<br>
b) if(n == 1) return 0<br>
c) if(n == 1) return 1<br>
d) no need to modify the base case<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the sum of digits of the number 10000, which is 1.</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">+</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10000</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The code prints the count of numbers between 1 and 20 such that the sum of their digits is 3. There are only two such numbers: 3 and 12.</i><p><b>a) 0<br>
b) 1<br>
c) runtime error<br>
d) -1<br>
</b></p><i>undefined</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cnt <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">int</span> my_function<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> sm<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> tmp_sm<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          tmp_sm <span class="sy0">=</span> recursive_sum_of_digits<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
          <span class="kw1">if</span><span class="br0">(</span>tmp_sm <span class="sy0">==</span> sm<span class="br0">)</span>
            cnt<span class="sy0">++;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> cnt<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_sum_of_digits<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> n <span class="sy0">%</span> <span class="nu0">10</span> <span class="sy0">+</span> recursive_sum_of_digits<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">20</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> my_function<span class="br0">(</span>n<span class="sy0">,</span>sum<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>undefined</i><p><b>1. Consider the following iterative implementation used to reverse a string:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">;</span>
     i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     j<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">while</span><span class="br0">(</span>______<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         i<span class="sy0">++;</span>
         j<span class="sy0">--;</span>
     <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) i &gt; j<br>
b) i &lt; len<br>
c) j &gt; 0<br>
d) i &lt; j<br>
</b></p><i>Answer: d<br>
Explanation: The line “i &lt; j” should be inserted to complete the above code.</i><p><b>2. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">;</span>
     i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     j<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">while</span><span class="br0">(</span>i <span class="sy0">&lt;</span> j<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         i<span class="sy0">++;</span>
         j<span class="sy0">--;</span>
     <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"reverse"</span><span class="sy0">;</span>
      reverse_string<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%s"</span><span class="sy0">,</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) ersevre<br>
b) esrever<br>
c) eserver<br>
d) eresevr<br>
</b></p><i>Answer: b<br>
Explanation: The program reverses the string “reverse” and prints “esrever”.</i><p><b>3. What is the time complexity of the above code used to reverse a string?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above code used to reverse a string is O(n).</i><p><b>4. What does the following code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">;</span>
     i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     j<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">while</span><span class="br0">(</span>i <span class="sy0">&lt;</span> j<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         i<span class="sy0">++;</span>
         j<span class="sy0">--;</span>
     <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcdefg"</span><span class="sy0">;</span>
      <span class="kw4">char</span> t<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>t<span class="sy0">,</span>s<span class="br0">)</span><span class="sy0">;</span>
      reverse_string<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span><span class="kw3">strcmp</span><span class="br0">(</span>t<span class="sy0">,</span>s<span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Yes"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">else</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"No"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Copies a string to another string<br>
b) Compares two strings<br>
c) Reverses a string<br>
d) Checks if a string is a palindrome<br>
</b></p><i>Answer: d<br>
Explanation: The main purpose of the above code is to check if a string is a palindrome.</i><p><b>5. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">;</span>
     i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     j<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">while</span><span class="br0">(</span>i <span class="sy0">&lt;</span> j<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         i<span class="sy0">++;</span>
         j<span class="sy0">--;</span>
     <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"rotator"</span><span class="sy0">;</span>
      <span class="kw4">char</span> t<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>t<span class="sy0">,</span>s<span class="br0">)</span><span class="sy0">;</span>
      reverse_string<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span><span class="kw3">strcmp</span><span class="br0">(</span>t<span class="sy0">,</span>s<span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Yes"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">else</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"No"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The program checks if a string is a palindrome. Since the string rotator is a palindrome, it prints “yes”.</i><p><b>a) Yes<br>
b) No<br>
c) Runtime error<br>
d) Compile time error<br>
</b></p><i>Answer: c<br>
Explanation: The line “recursive_reverse_string(s, left+1, right-1)” should be inserted to complete the above code.</i><p><b>6. Consider the following recursive implementation used to reverse a string:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> recursive_reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>left<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         _________<span class="sy0">;</span>
     <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) recursive_reverse_string(s, left+1, right+1)<br>
b) recursive_reverse_string(s, left-1, right-1)<br>
c) recursive_reverse_string(s, left+1, right-1)<br>
d) recursive_reverse_string(s, left-1, right+1)<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the reversed string of “recursion”, which  is “noisrucer”.</i><p><b>7. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> recursive_reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>left<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         recursive_reverse_string<span class="br0">(</span>s<span class="sy0">,</span> left<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"recursion"</span><span class="sy0">;</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     recursive_reverse_string<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%s"</span><span class="sy0">,</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) recursion<br>
b) nsoirucer<br>
c) noisrcuer<br>
d) noisrucer<br>
</b></p><i>Answer: a<br>
Explanation: The function recursive_reverse_string() is called 3 times when the above code is executed.</i><p><b>8. How many times is the function recursive_reverse_string() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">void</span> recursive_reverse_string<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> left<span class="sy0">,</span> <span class="kw4">int</span> right<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>left <span class="sy0">&lt;</span> right<span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw4">char</span> tmp <span class="sy0">=</span> s<span class="br0">[</span>left<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>left<span class="br0">]</span> <span class="sy0">=</span> s<span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
         s<span class="br0">[</span>right<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
         recursive_reverse_string<span class="br0">(</span>s<span class="sy0">,</span> left<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> right<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"madam"</span><span class="sy0">;</span>
     <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
     recursive_reverse_string<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%s"</span><span class="sy0">,</span>s<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 3<br>
b) 4<br>
c) 5<br>
d) 6<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation used to reverse a string is O(n).</i><p><b>9. What is the time complexity of the above recursive implementation used to reverse a string?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: String “ab” is a string of length 2 whose reversal is not the same as the given one. Palindromic Strings, String of length 1 and Empty Strings case – the reversal is the same as the one given.</i><p><b>10. In which of the following cases is the reversal of a string not equal to the original string?<br>
a) Palindromic strings<br>
b) Strings of length 1<br>
c) Empty String<br>
d) Strings of length 2<br>
</b></p><i>undefined</i><p><b>1. Which of the following is the binary representation of 100?<br>
a) 1010010<br>
b) 1110000<br>
c) 1100100<br>
d) 1010101<br>
</b></p><i>Answer: c<br>
Explanation: 100 = 64 + 32 + 4 = 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>2</sup> = 1100100.</i><p><b>2. Consider the following iterative code used to convert a decimal number to its equivalent binary:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">void</span> dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          len <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
          _______<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
     dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) n–<br>
b) n /= 2<br>
c) n /= 10<br>
d) n++<br>
</b></p><i>Answer: b<br>
Explanation: The line “n /= 2” should be inserted to complete the above code.</i><p><b>3. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">void</span> dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>i<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
        len <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
        n <span class="sy0">/=</span> <span class="nu0">2</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">63</span><span class="sy0">;</span>
    dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 111111<br>
b) 111011<br>
c) 101101<br>
d) 101010<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the binary equivalent of 63, which is 111111.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">void</span> dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          len <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
          n <span class="sy0">/=</span> <span class="nu0">2</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) Runtime error<br>
d) Garbage value<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the binary equivalent of 0, which is 0.</i><p><b>5. What is the time complexity of the following code used to convert a decimal number to its binary equivalent?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">void</span> dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          len <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">while</span><span class="br0">(</span>n <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
          n <span class="sy0">/=</span> <span class="nu0">2</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The time complexity of the above code used to convert a decimal number to its binary equivalent is O(logn).</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: c<br>
Explanation: The line “arr[len++] = n % 2” should be inserted to complete the above code.</i><p><b>6. Consider the following recursive implementation used to convert a decimal number to its binary equivalent:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
          <span class="kw1">return</span><span class="sy0">;</span>
        __________<span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">,</span>i<span class="sy0">;</span>
     recursive_dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) arr[len] = n<br>
b) arr[len] = n % 2<br>
c) arr[len++] = n % 2<br>
d) arr[len++] = n<br>
</b></p><i>Answer: c<br>
Explanation: Both of the above mentioned lines are the base cases for the above code.</i><p><b>7. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines is the base case for the above code?<br>
a) if(n ==0 &amp;&amp; len == 0)<br>
b) if(n == 0)<br>
c) if(n ==0 &amp;&amp; len == 0) and if(n == 0)<br>
d) if(n == 1)<br>
</b></p><i>Answer: d<br>
Explanation: The program doesn’t handle negative inputs and so produces a garbage value.</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">100</span><span class="sy0">,</span>i<span class="sy0">;</span>
     recursive_dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) -1100100<br>
b) 1100100<br>
c) 2’s complement of 1100100<br>
d) Garbage value<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the recursive implementation used to convert a decimal number to its binary equivalent is O(logn).</i><p><b>9. What is the time complexity of the recursive implementation used to convert a decimal number to its binary equivalent?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The space complexity of the recursive implementation used to convert a decimal number to its binary equivalent is O(logn).</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the binary equivalent of 111, which is 1101111.</i><p><b>10. What is the space complexity of the recursive implementation used to convert a decimal number to its binary equivalent?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: The function recursive_dec_to_bin() is called 8 times when the above code is executed.</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">111</span><span class="sy0">,</span>i<span class="sy0">;</span>
     recursive_dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1110111<br>
b) 1001111<br>
c) 1101111<br>
d) 1010111<br>
</b></p><i>undefined</i><p><b>12. How many times is the function recursive_dec_to_bin() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">31</span><span class="br0">]</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">void</span> recursive_dec_to_bin<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> len <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="kw1">return</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span><span class="sy0">;</span>
      arr<span class="br0">[</span>len<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> n <span class="sy0">%</span> <span class="nu0">2</span><span class="sy0">;</span>
      recursive_dec_to_bin<span class="br0">(</span>n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">111</span><span class="sy0">,</span>i<span class="sy0">;</span>
    recursive_dec_to_bin<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> i<span class="sy0">&gt;=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">--</span><span class="br0">)</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 7<br>
b) 8<br>
c) 9<br>
d) 10<br>
</b></p><i>undefined</i><p><b>1. Consider the following iterative implementation used to find the length of a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>_____<span class="br0">)</span>
      <span class="br0">{</span>
          len<span class="sy0">++;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following conditions should be checked to complete the above code?<br>
a) temp-&gt;next != 0<br>
b) temp == 0<br>
c) temp != 0<br>
d) temp-&gt;next == 0<br>
</b></p><i>Answer: c<br>
Explanation: The condition “temp != 0” should be checked to complete the above code.</i><p><b>2. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          len<span class="sy0">++;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the length of the linked list, which is 5.</i><p><b>3. What is the time complexity of the following iterative implementation used to find the length of a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          len<span class="sy0">++;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above iterative implementation used to find the length of a linked list is O(n).</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          len<span class="sy0">++;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The program prints the length of the linked list, which is 0.</i><p><b>a) 0<br>
b) Garbage value<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: d<br>
Explanation: The line “if(current_node == 0) return 0” can be used as a base case in the recursive implementation used to find the length of a linked list. Note: The line “if(current_node-&gt;next == 0) return 1” cannot be used because it won’t work when the length of the linked list is zero.</i><p><b>5. Which of the following can be the base case for the recursive implementation used to find the length of linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
          len<span class="sy0">++;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) if(current_node == 0) return 1<br>
b) if(current_node-&gt;next == 0) return 1<br>
c) if(current_node-&gt;next == 0) return 0<br>
d) if(current_node == 0) return 0<br>
</b></p><i>Answer: d<br>
Explanation: The line “1 + recursive_get_len(current_node-&gt;next)” should be inserted to complete the above code.</i><p><b>6. Which of the following lines should be inserted to complete the following recursive implementation used to find the length of a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>current_node<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>current_node <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> _____<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) recursive_get_len(current_node)<br>
b) 1 + recursive_get_len(current_node)<br>
c) recursive_get_len(current_node-&gt;next)<br>
d) 1 + recursive_get_len(current_node-&gt;next)<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the length of the linked list, which is 7.</i><p><b>7. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>current_node<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>current_node <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>current_node<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 6<br>
b) 7<br>
c) 8<br>
d) 9<br>
</b></p><i>Answer: b<br>
Explanation: To find the length of the linked list, the program iterates over the linked list once. So, the time complexity of the above code is O(n).</i><p><b>8. What is the time complexity of the following code used to find the length of a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>current_node<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>current_node <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>current_node<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The program prints the length of the linked list, which is 6.</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The function is called “len + 1” times. Since the length of the linked list in the above code is 6, the function is called 6 + 1 = 7 times.</i><p><b>9. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>current_node<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>current_node <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>current_node<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>undefined</i><p><b>10. How many times is the function recursive_get_len() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
      <span class="kw4">int</span> val<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>current_node<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>current_node <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>current_node<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span> i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>undefined</i><p><b>1. Consider the following iterative implementation to find the length of the string:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>________<span class="br0">)</span>
        len<span class="sy0">++;</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"harsh"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) s[len-1] != 0<br>
b) s[len+1] != 0<br>
c) s[len] != ‘\0’<br>
d) s[len] == ‘\0’<br>
</b></p><i>Answer: c<br>
Explanation: The line “s[len] != ‘\0′” should be inserted to complete the above code.</i><p><b>2. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span>
        len<span class="sy0">++;</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"lengthofstring"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 14<br>
b) 0<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the length of the string “lengthofstring”, which is 14.</i><p><b>3. What is the time complexity of the following code used to find the length of the string?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span>
        len<span class="sy0">++;</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"lengthofstring"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(logn)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the code used to find the length of the string is O(n).</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span>
        len<span class="sy0">++;</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">""</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The program prints the length of an empty string, which is 0.</i><p><b>a) 0<br>
b) 1<br>
c) Runtime error<br>
d) Garbage value<br>
</b></p><i>Answer: c<br>
Explanation: “if(string[len] == ‘\0’) return 0” can be used as base case in the recursive implementation used to find the length of the string.</i><p><b>5. Which of the following can be the base case for the recursive implementation used to find the length of a string?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span>
        len<span class="sy0">++;</span>
      <span class="kw1">return</span> len<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">""</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> get_len<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) if(string[len] == 1) return 1<br>
b) if(string[len+1] == 1) return 1<br>
c) if(string[len] == ‘\0’) return 0<br>
d) if(string[len] == ‘\0’) return 1<br>
</b></p><i>Answer: d<br>
Explanation: The line “1 + recursive_get_len(s, len+1)” should be inserted to complete the code.</i><p><b>6. Consider the following recursive implementation used to find the length of a string:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> ________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"abcdef"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) 1<br>
b) len<br>
c) recursive_get_len(s, len+1)<br>
d) 1 + recursive_get_len(s, len+1)<br>
</b></p><i>Answer: b<br>
Explanation: The above code prints the length of the string “abcdef”, which is 6.</i><p><b>7. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span> len<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"abcdef"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation used to find the length of the string is O(n).</i><p><b>8. What is the time complexity of the following recursive implementation used to find the length of the string?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span> len<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"abcdef"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The function recursive_get_len() is called 8 times when the above code is executed.</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The above program prints the length of the string “123-1-2-3”, which is 9.</i><p><b>9. How many times is the function recursive_get_len() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span> len<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"adghjkl"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 6<br>
b) 7<br>
c) 8<br>
d) 9<br>
</b></p><i>undefined</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_get_len<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>len<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">1</span> <span class="sy0">+</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span> len<span class="sy0">+</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> <span class="sy0">*</span>s <span class="sy0">=</span> <span class="st0">"123-1-2-3"</span><span class="sy0">;</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> recursive_get_len<span class="br0">(</span>s<span class="sy0">,</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 3<br>
b) 6<br>
c) 9<br>
d) 10<br>
</b></p><i>undefined</i><p><b>1. If Matrix A is of order X*Y and Matrix B is of order M*N, then what is the order of the Matrix A*B given that Y=M?<br>
a) Y*N<br>
b) X*M<br>
c) X*N<br>
d) Y*M<br>
</b></p><i>Answer: c<br>
Explanation: The Matrix A*B is of order X*N as it is given that Y=M i.e. number of columns in Matrix A is equal to total number of rows in matrix B. So the Matrix A*B must have X number of rows and N number of columns.</i><p><b>2. How many recursive calls are there in Recursive matrix multiplication through Simple Divide and Conquer Method?<br>
a) 2<br>
b) 6<br>
c) 9<br>
d) 8<br>
</b></p><i>Answer: d<br>
Explanation: For the multiplication two square matrix recursively using Simple Divide and Conquer Method, there are 8 recursive calls performed for high time complexity.</i><p><b>3. What is the time complexity of matrix multiplied recursively by Divide and Conquer Method?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(n!)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of recursive multiplication of two square matrices by the Divide and Conquer method is found to be O(n<sup>3</sup>) since there are total of 8 recursive calls.</i><p><b>4. What is the time complexity of matrix multiplied recursively by Strassen’s Method?<br>
a) O(n<sup>log7</sup>)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(n!)<br>
</b></p><i>Answer: a<br>
Explanation: The time complexity of recursive multiplication of two square matrices by Strassen’s Method is found to be O(n<sup>log7</sup>) since there are total 7 recursive calls.</i><p><b>5. How many recursive calls are there in Recursive matrix multiplication by Strassen’s Method?<br>
a) 5<br>
b) 7<br>
c) 8<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: For the multiplication two square matrix recursively using Strassen’s Method, there are 7 recursive calls performed for high time complexity.</i><p><b>6. Matrix A is of order 3*4 and Matrix B is of order 4*5. How many elements will be there in a matrix A*B multiplied recursively.<br>
a) 12<br>
b) 15<br>
c) 16<br>
d) 20<br>
</b></p><i>Answer: b<br>
Explanation: The resultant matrix will be of order 3*5 when multiplied recursively and therefore the matrix will have 3*5=15 elements.</i><p><b>8. What is the time complexity of the fastest known matrix multiplication algorithm?<br>
a) O(n<sup>log7</sup>)<br>
b) O(n<sup>2.37</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(n!)<br>
</b></p><i>Answer: a<br>
Explanation: Given that B=C, so the two matrix can be recursively multiplied. Therefore, the order of the Matrix X*Y is A*D.</i><p><b>1. Which of the following statement is true about stack?<br>
a) Pop operation removes the top most element<br>
b) Pop operation removes the bottom most element<br>
c) Push operation adds new element at the bottom<br>
d) Push operation removes the top most element<br>
</b></p><i>Answer: a<br>
Explanation: As stack is based on LIFO(Last In First Out) principle so the deletion takes place from the topmost element. Thus pop operator removes topmost element.</i><p><b>2. What is the space complexity of program to reverse stack recursively?<br>
a) O(1)<br>
b) O(log n)<br>
c) O(n)<br>
d) O(n log n)<br>
</b></p><i>Answer: c<br>
Explanation: The recursive program to reverse stack uses memory of the order n to store function call stack.</i><p><b>3. Stack can be reversed without using extra space by _____________<br>
a) using recursion<br>
b) using linked list to implement stack<br>
c) using an extra stack<br>
d) it is not possible<br>
</b></p><i>Answer: b<br>
Explanation: If linked list is used for implementing stack then it can be reversed without using any extra space.</i><p><b>4. Which of the following is considered as the top of the stack in the linked list implementation of the stack?<br>
a) Last node<br>
b) First node<br>
c) Random node<br>
d) Middle node<br>
</b></p><i>Answer: b<br>
Explanation: First node is considered as the top element when stack is implemented using linked list.</i><p><b>5. What is the time complexity of the program to reverse stack when linked list is used for its implementation?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: As a linked list takes O(n) time for getting reversed thus linked list version of stack will also take the same time.</i><p><b>6. Which of the following takes O(n) time in worst case in array implementation of stack?<br>
a) pop<br>
b) push<br>
c) isEmpty<br>
d) pop, push and isEmpty takes constant time<br>
</b></p><i>Answer: d<br>
Explanation: Functions pop, push and isEmpty all are implemented in constant time in worst case.</i><p><b>7. What will be the time complexity of the code to reverse stack recursively?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation for the recursive code to reverse stack will be given by-T(n)=T(n-1)+n.This is calculated to be equal to O(n<sup>2</sup>).</i><p><b>8. Which of the following functions correctly represents the recursive approach to reverse a stack?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> reverse<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> x <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        reverse<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> reverse<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">&gt;=</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> x <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        reverse<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> reverse<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> x <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        reverse<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> reverse<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> x <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
        s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        reverse<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: We keep on holding the elements in call stack until we reach the bottom of the stack.Then we insert elements at the bottom.This reverses our stack.</i><p><b>9. Which of the following correctly represents the function to insert elements at the bottom of stack?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="kw4">int</span> BottomInsert<span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span>
 <span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">)</span> s.<span class="me1">push</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw4">int</span> a <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> BottomInsert<span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> s.<span class="me1">push</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw4">int</span> a <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
		BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> BottomInsert<span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> s.<span class="me1">push</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		<span class="kw4">int</span> a <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> BottomInsert<span class="br0">(</span><span class="kw4">int</span> x<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>s.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> s.<span class="me1">push</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">else</span>
	<span class="br0">{</span>
		s.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		<span class="kw4">int</span> a <span class="sy0">=</span> s.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		BottomInsert<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
		s.<span class="me1">push</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: We hold all the elements in the call stack until we reach the bottom of stack and then the first if statement is executed as the stack is empty at this stage.Finally we push back all the elements held in the call stack. </i><p><b>10. Which of the following code correctly represents the function to reverse stack without using recursion?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="co2">#include &lt;stack&gt;</span>
<span class="kw4">void</span> reverseStack<span class="br0">(</span>stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>input<span class="sy0">,</span> stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>extra<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">while</span><span class="br0">(</span>input.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">)</span>
	<span class="br0">{</span>
		extra.<span class="me1">push</span><span class="br0">(</span>input.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		input.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    input.<span class="me1">swap</span><span class="br0">(</span>extra<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="co2">#include &lt;stack&gt;</span>
<span class="kw4">void</span> reverseStack<span class="br0">(</span>stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>input<span class="sy0">,</span> stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>extra<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">while</span><span class="br0">(</span>input.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
		extra.<span class="me1">push</span><span class="br0">(</span>input.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
		input.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    extra.<span class="me1">swap</span><span class="br0">(</span>input<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="co2">#include &lt;stack&gt;</span>
<span class="kw4">void</span> reverseStack<span class="br0">(</span>stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>input<span class="sy0">,</span> stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>extra<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>input.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">)</span>
    <span class="br0">{</span>
		input.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		extra.<span class="me1">push</span><span class="br0">(</span>input.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    extra.<span class="me1">swap</span><span class="br0">(</span>input<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stack&gt;</span>
<span class="kw4">void</span> reverseStack<span class="br0">(</span>stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>input<span class="sy0">,</span> stack<span class="sy0">&lt;</span>int<span class="sy0">&gt;</span> <span class="sy0">&amp;</span>extra<span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw1">while</span><span class="br0">(</span>input.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
   <span class="br0">{</span>
		input.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
		extra.<span class="me1">push</span><span class="br0">(</span>input.<span class="me1">top</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
   <span class="br0">}</span>
   extra.<span class="me1">swap</span><span class="br0">(</span>input<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: We are using one extra stack to reverse the given stack. First the elements of the original stack are pushed into the other stack which creates a reversed version of the original stack. Then we swap this stack with the original stack.</i><p><b>1. Which of the following sorting algorithm has best case time complexity of O(n<sup>2</sup>)?<br>
a) bubble sort<br>
b) selection sort<br>
c) insertion sort<br>
d) stupid sort<br>
</b></p><i>Answer: b<br>
Explanation: Selection sort is not an adaptive sorting algorithm. It finds the index of minimum element in each iteration even if the given array is already sorted. Thus its best case time complexity becomes O(n<sup>2</sup>).</i><p><b>2. Which of the following is the biggest advantage of selection sort?<br>
a) its has low time complexity<br>
b) it has low space complexity<br>
c) it is easy to implement<br>
d) it requires only n swaps under any condition<br>
</b></p><i>Answer: d<br>
Explanation: Selection sort works by obtaining least value element in each iteration and then swapping it with the current index. So it will take n swaps under any condition which will be useful when memory write operation is expensive.</i><p><b>3. What will be the recurrence relation of the code of recursive selection sort?<br>
a) T(n) = 2T(n/2) + n<br>
b) T(n) = 2T(n/2) + c<br>
c) T(n) = T(n-1) + n<br>
d) T(n) = T(n-1) + c<br>
</b></p><i>Answer: c<br>
Explanation: Function to find the minimum element index takes n time.The recursive call is made to one less element than in the previous call so the overall recurrence relation becomes T(n) = T(n-1) + n.</i><p><b>4. Which of the following sorting algorithm is NOT stable?<br>
a) Selection sort<br>
b) Brick sort<br>
c) Bubble sort<br>
d) Merge sort<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options selection sort is the only algorithm which is not stable. It is because the order of identical elements in sorted output may be different from input array.</i><p><b>5. What will be the best case time complexity of recursive selection sort?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Selection sort’s algorithm is such that it finds the index of minimum element in each iteration even if the given array is already sorted. Thus its best case time complexity becomes O(n<sup>2</sup>).</i><p><b>7. What is the average case time complexity of recursive selection sort?<br>
a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: In selection sort we need to compare elements in order to find the minimum element in each iteration. So we can say that it uses comparisons in order to sort the array. Thus it qualifies as a comparison based sort.</i><p><b>8. What is the bidirectional variant of selection sort?<br>
a) cocktail sort<br>
b) bogo sort<br>
c) gnome sort<br>
d) bubble sort<br>
</b></p><i>Answer: c<br>
Explanation: The overall recurrence relation of recursive selection sort is given by T(n) = T(n-1) + n. It is found to be equal to O(n<sup>2</sup>). It is unvaried throughout the three cases.</i><p><b>9. Choose correct C++ code for recursive selection sort from the following.<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> minIndex<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="sy0">,</span> <span class="kw4">int</span> j<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> i<span class="sy0">;</span> 	
	<span class="kw4">int</span> k <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> i <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">return</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span><span class="sy0">?</span> i <span class="sy0">:</span> k<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> recursiveSelectionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 	 
	<span class="kw4">int</span> x <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> index<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 	 
	<span class="kw1">if</span> <span class="br0">(</span>x <span class="sy0">==</span> index<span class="br0">)</span> 
	<span class="br0">{</span>	    
	    	swap<span class="br0">(</span>a<span class="br0">[</span>x<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span> 
	recursiveSelectionSort<span class="br0">(</span>a<span class="sy0">,</span> n<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  
	recursiveSelectionSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> minIndex<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="sy0">,</span> <span class="kw4">int</span> j<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">==</span> j<span class="br0">)</span> 
		<span class="kw1">return</span> i<span class="sy0">;</span> 	
	<span class="kw4">int</span> k <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> i <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">return</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> a<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span><span class="sy0">?</span> i <span class="sy0">:</span> k<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> recursiveSelectionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
<span class="br0">{</span> 
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
        <span class="kw1">return</span><span class="sy0">;</span> 	 
	<span class="kw4">int</span> x <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> index<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>	 
	<span class="kw1">if</span> <span class="br0">(</span>x <span class="sy0">!=</span> index<span class="br0">)</span> 
	<span class="br0">{</span>
	    	swap<span class="br0">(</span>a<span class="br0">[</span>x<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span> 
	recursiveSelectionSort<span class="br0">(</span>a<span class="sy0">,</span> n<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  
	recursiveSelectionSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> minIndex<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="sy0">,</span> <span class="kw4">int</span> j<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">==</span> j<span class="br0">)</span> 
		<span class="kw1">return</span> i<span class="sy0">;</span> 	
	<span class="kw4">int</span> k <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> i <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span><span class="sy0">?</span> i <span class="sy0">:</span> k<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> recursiveSelectionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> n<span class="br0">)</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 	 
	<span class="kw4">int</span> x <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> index<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 	 
	<span class="kw1">if</span> <span class="br0">(</span>x <span class="sy0">!=</span> index<span class="br0">)</span> 
	<span class="br0">{</span>	    
	    	swap<span class="br0">(</span>a<span class="br0">[</span>x<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span> 
	recursiveSelectionSort<span class="br0">(</span>a<span class="sy0">,</span> n<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
        recursiveSelectionSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"> <span class="co2">#include &lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">int</span> minIndex<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> i<span class="sy0">,</span> <span class="kw4">int</span> j<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">==</span> j<span class="br0">)</span> 
		<span class="kw1">return</span> i<span class="sy0">;</span> 	
	<span class="kw4">int</span> k <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> i <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">return</span> <span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> a<span class="br0">[</span>k<span class="br0">]</span><span class="br0">)</span><span class="sy0">?</span> i <span class="sy0">:</span> k<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> recursiveSelectionSort<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>index <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span><span class="sy0">;</span> 	 
	<span class="kw4">int</span> x <span class="sy0">=</span> minIndex<span class="br0">(</span>a<span class="sy0">,</span> index<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 	 
	<span class="kw1">if</span> <span class="br0">(</span>x <span class="sy0">==</span> index<span class="br0">)</span> 
	<span class="br0">{</span>	    
	    	swap<span class="br0">(</span>a<span class="br0">[</span>x<span class="br0">]</span><span class="sy0">,</span> a<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="br0">}</span>
 	recursiveSelectionSort<span class="br0">(</span>a<span class="sy0">,</span> n<span class="sy0">,</span> index <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span>  
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	recursiveSelectionSort<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: A bidirectional variant of selection sort is called cocktail sort. It’s an algorithm which finds both the minimum and maximum values in the array in every pass. This reduces the number of scans of the array by a factor of 2.</i><p><b>10. What is the number of swaps required to sort the array arr={5,3,2,4,1} using recursive selection sort?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: Using the function recursiveSelectionSort() we find the element that needs to be placed at the current index. For finding the minimum element index we use another function minIndex(). After finding the minimum element index the current element is swapped with this element in the function recursiveSelectionSort().</i><p><b>1. Which of the following methods can be used to find the largest and smallest element in an array?<br>
a) Recursion<br>
b) Iteration<br>
c) Both recursion and iteration<br>
d) No method is suitable<br>
</b></p><i>Answer: c<br>
Explanation: Both recursion and iteration can be used to find the largest and smallest element in an array.</i><p><b>2. Consider the following iterative code snippet to find the largest element:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> get_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> max_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          <span class="kw1">if</span><span class="br0">(</span>________<span class="br0">)</span>
          max_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_element<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) arr[i] &gt; max_element<br>
b) arr[i] &lt; max_element<br>
c) arr[i] == max_element<br>
d) arr[i] != max_element<br>
</b></p><i>Answer: a<br>
Explanation: The line “arr[i] &gt; max_element” should be inserted to complete the above code snippet.</i><p><b>3. Consider the following code snippet to find the smallest element in an array:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> get_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> min_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>_______<span class="br0">)</span>
          min_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_element<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) arr[i] &gt; min_element<br>
b) arr[i] &lt; min_element<br>
c) arr[i] == min_element<br>
d) arr[i] != min_element<br>
</b></p><i>Answer: b<br>
Explanation: The line “arr[i] &lt; min_element” should be inserted to complete the above code.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> max_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max_element<span class="br0">)</span>
          max_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> get_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> min_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> min_element<span class="br0">)</span>
          min_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">7</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> max_element <span class="sy0">=</span> get_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_element <span class="sy0">=</span> get_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5 3<br>
b) 3 5<br>
c) 8 1<br>
d) 1 8<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the values of the largest and the smallest elements in the array, which are 8 and 1 respectively.</i><p><b>5. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> max_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max_element<span class="br0">)</span>
          max_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> get_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> min_element<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> min_element<span class="br0">)</span>
          min_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">7</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,-</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> max_element <span class="sy0">=</span> get_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_element <span class="sy0">=</span> get_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: Since the min_element variable is not initialised, some compilers will auto initialise as 0 which produces -1 as output whereas some compilers won’t initialise automatically. In that case, the result will be a garbage value hence the output depends on the compiler.</i><p><b>a) 1 -1<br>
b) -1 1<br>
c) 1 Garbage value<br>
d) Depends on the compiler<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above iterative implementation used to find the largest and the smallest element in an array is O(n).</i><p><b>6. What is the time complexity of the following iterative implementation used to find the largest and smallest element in an array?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> max_element <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max_element<span class="br0">)</span>
          max_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> get_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> min_element<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;</span> min_element<span class="br0">)</span>
          min_element <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_element<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">7</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,-</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> max_element <span class="sy0">=</span> get_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_element <span class="sy0">=</span> get_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n/2)<br>
</b></p><i>Answer: c<br>
Explanation: The line “max_of_two(arr[idx], recursive_max_element(arr, len, idx + 1))” should be inserted to complete the above code.</i><p><b>7. Consider the following recursive implementation to find the largest element in an array.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> _______<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) max_of_two(arr[idx], recursive_max_element(arr, len, idx))<br>
b) recursive_max_element(arr, len, idx)<br>
c) max_of_two(arr[idx], recursive_max_element(arr, len, idx + 1))<br>
d) recursive_max_element(arr, len, idx + 1)<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the values of the largest and the smallest element in the array, which are 10 and -1 respectively.</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">10</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> max_element <span class="sy0">=</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw4">int</span> min_element <span class="sy0">=</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) -1 10<br>
b) 10 -1<br>
c) 1 10<br>
d) 10 1<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation used to find the largest and smallest element in an array is O(n).</i><p><b>9. What is the time complexity of the following recursive implementation used to find the largest and the smallest element in an array?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">10</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> max_element <span class="sy0">=</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw4">int</span> min_element <span class="sy0">=</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The function recursive_min_element() is called 10 times when the above code is executed.</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the values of the largest and the smallest element in the array, which are 1 and 1.</i><p><b>10. How many times is the function recursive_min_element() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">,</span> idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,-</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">10</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_element <span class="sy0">=</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 9<br>
b) 10<br>
c) 11<br>
d) 12<br>
</b></p><i>undefined</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_max_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_min_element<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="sy0">,</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="sy0">,</span> idx <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> max_element <span class="sy0">=</span> recursive_max_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_element <span class="sy0">=</span> recursive_min_element<span class="br0">(</span>arr<span class="sy0">,</span>n<span class="sy0">,</span>idx<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_element<span class="sy0">,</span>min_element<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1 1<br>
b) 0 0<br>
c) compile time error<br>
d) runtime error<br>
</b></p><i>undefined</i><p><b>1. Which of the following methods can be used to find the largest and smallest number in a linked list?<br>
a) Recursion<br>
b) Iteration<br>
c) Both Recursion and iteration<br>
d) Impossible to find the largest and smallest numbers<br>
</b></p><i>Answer: c<br>
Explanation: Both recursion and iteration can be used to find the largest and smallest number in a linked list.</i><p><b>2. Consider the following code snippet to find the largest element in a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node<span class="br0">{</span>
   <span class="kw4">int</span> val<span class="sy0">;</span>
   <span class="kw4">struct</span> Node <span class="sy0">*</span>next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_max<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>______<span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&gt;</span> max_num<span class="br0">)</span>
		    max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> max_num<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) temp-&gt;next != 0<br>
b) temp != 0<br>
c) head-&gt;next != 0<br>
d) head != 0<br>
</b></p><i>Answer: b<br>
Explanation: The line “temp != 0” should be inserted to complete the above code.</i><p><b>3. Consider the following code snippet to find the smallest element in a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	       <span class="kw1">if</span><span class="br0">(</span>_________<span class="br0">)</span>
		    min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> min_num<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) temp &gt; min_num<br>
b) val &gt; min_min<br>
c) temp-&gt;val &lt; min_num<br>
d) temp-&gt;val &gt; min_num<br>
</b></p><i>Answer: c<br>
Explanation: The line “temp-&gt;val = min_num” should be inserted to complete the above code.</i><p><b>4. What is the output of the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_max<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&gt;</span> max_num<span class="br0">)</span>
		    max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> max_num<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">9</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>i<span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max_num <span class="sy0">=</span> get_max<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_num<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 1<br>
c) runtime error<br>
d) garbage value<br>
</b></p><i>Answer: c<br>
Explanation: The variable temp will always point to the first element in the linked list due to the line “temp = head-&gt;next” in the while loop. So, it will be an infinite while loop and the program will produce  a runtime error.</i><p><b>5. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_max<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&gt;</span> max_num<span class="br0">)</span>
		    max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> max_num<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&lt;</span> min_num<span class="br0">)</span>
		    min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> min_num<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">9</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max_num <span class="sy0">=</span> get_max<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> min_num <span class="sy0">=</span> get_min<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_num<span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The program prints the largest and smallest elements in the linked list, which are 8 and 2 respectively.</i><p><b>a) 2 2<br>
b) 8 8<br>
c) 2 8<br>
d) 8 2<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above iterative code used to find the largest and smallest element in a linked list is O(n).</i><p><b>6. What is the time complexity of the following iterative code used to find the smallest and largest element in a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> get_max<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&gt;</span> max_num<span class="br0">)</span>
		    max_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> max_num<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node<span class="sy0">*</span> temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="kw4">int</span> min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
	  <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">&lt;</span> min_num<span class="br0">)</span>
		    min_num <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
		temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
	  <span class="br0">}</span>
	  <span class="kw1">return</span> min_num<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">9</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
          temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
          temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max_num <span class="sy0">=</span> get_max<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> min_num <span class="sy0">=</span> get_min<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_num<span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The arguments {temp-&gt;val,recursive_get_max(temp-&gt;next)} should be passed to the function max_of_two() to complete the above code.</i><p><b>7. Consider the following recursive implementation to find the largest element in a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_max<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>______<span class="sy0">,</span> _______<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following arguments should be passed to the function max_of two() to complete the above code?<br>
a) temp-&gt;val,recursive_get_max(temp-&gt;next)<br>
b) temp, temp-&gt;next<br>
c) temp-&gt;val, temp-&gt;next-&gt;val<br>
d) temp-&gt;next-&gt;val, temp<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the largest and the smallest elements in the linked list, which are 7 and 0 respectively.</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_max<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_max<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_min<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_min<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">9</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>i<span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> max_num <span class="sy0">=</span> recursive_get_max<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_num <span class="sy0">=</span> recursive_get_min<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_num<span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 7 1<br>
b) 0 7<br>
c) 7 0<br>
d) 1 1<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation used to find the largest and smallest element in linked list is O(n).</i><p><b>9. What is the time complexity of the recursive implementation used to find the largest and smallest element in a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_max<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> max_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_max<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_min<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_min<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">9</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>i<span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> max_num <span class="sy0">=</span> recursive_get_max<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> min_num <span class="sy0">=</span> recursive_get_min<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d %d"</span><span class="sy0">,</span>max_num<span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The program prints the smallest element in the linked list, which is 1.</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The function recursive_get_min() will be called 5 times when the above code is executed.</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_min<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_min<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>i<span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> min_num <span class="sy0">=</span> recursive_get_min<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 0<br>
c) compile time error<br>
d) runtime error<br>
</b></p><i>undefined</i><p><b>11. How many times will the function recursive_get_min() be called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> min_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> recursive_get_min<span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span> temp<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>next <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span>  temp<span class="sy0">-&gt;</span>val<span class="sy0">;</span>
      <span class="kw1">return</span> min_of_two<span class="br0">(</span>temp<span class="sy0">-&gt;</span>val<span class="sy0">,</span>recursive_get_min<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>i<span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span> <span class="sy0">*</span>newNode<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head <span class="sy0">-&gt;</span> next <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           newNode <span class="sy0">=</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span>newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> min_num <span class="sy0">=</span> recursive_get_min<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>min_num<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>undefined</i><p><b>1. Which of the following techniques can be used to search an element in an unsorted array?<br>
a) Iterative linear search<br>
b) Recursive binary search<br>
c) Iterative binary search<br>
d) Normal binary search<br>
</b></p><i>Answer: a<br>
Explanation: Iterative linear search can be used to search an element in an unsorted array.<br>
Note: Binary search can be used only when the array is sorted.</i><p><b>2. Consider the array {1,1,1,1,1}. Select the wrong option?<br>
a) Iterative linear search can be used to search for the elements in the given array<br>
b) Recursive linear search can be used to search for the elements in the given array<br>
c) Recursive binary search can be used to search for the elements in the given array<br>
d) No method is defined to search for an element in the given array<br>
</b></p><i>Answer: d<br>
Explanation: Iterative linear search, Recursive linear search and Recursive binary search can be applied to search for an element in the above given array.</i><p><b>3. What does the following code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
      <span class="kw1">return</span> i<span class="sy0">;</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Search and returns the index of all the occurrences of the number that is searched<br>
b) Search and returns the index of the first occurrence of the number that is searched<br>
c) Search and returns of the last occurrence of the number that is searched<br>
d) Returns the searched element from the given array<br>
</b></p><i>Answer: b<br>
Explanation: The code finds the index of the first occurrence of the number that is searched.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
        <span class="kw1">return</span> i<span class="sy0">;</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Index of 3 is 0<br>
b) Index of 3 is 1<br>
c) Index of 3 is 2<br>
d) Index of 3 is 3<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the index of the first occurrence of 3, which is 1.</i><p><b>5. What is the time complexity of the following code used to search an element in an array?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
        <span class="kw1">return</span> i<span class="sy0">;</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">3</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above code used to search an element in an array is O(n).</i><p><b>6. Consider the following recursive implementation of linear search:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
       <span class="kw1">return</span> idx<span class="sy0">;</span>
     <span class="kw1">return</span> __________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">2</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The recursive call “recursive_search_num(arr, num, idx+1, len)” should be added to complete the above code.</i><p><b>Which of the following recursive calls should be added to complete the above code?<br>
a) recursive_search_num(arr, num+1, idx, len);<br>
b) recursive_search_num(arr, num, idx, len);<br>
c) recursive_search_num(arr, num, idx+1, len);<br>
d) recursive_search_num(arr, num+1, idx+1, len);<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the index of 5, which is 5.</i><p><b>7. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
       <span class="kw1">return</span> idx<span class="sy0">;</span>
     <span class="kw1">return</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">5</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Index of 5 is 5<br>
b) Index of 5 is 6<br>
c) Index of 5 is 7<br>
d) Index of 5 is 8<br>
</b></p><i>Answer: b<br>
Explanation: The function recursive_search_num() is called 6 times when the above code is executed.</i><p><b>8. How many times is the function recursive_search_num() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
     <span class="kw1">return</span> idx<span class="sy0">;</span>
     <span class="kw1">return</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">5</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation of linear search is O(n).</i><p><b>9. What is the time complexity of the following recursive implementation of linear search?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
     <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
     <span class="kw1">return</span> idx<span class="sy0">;</span>
     <span class="kw1">return</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num<span class="sy0">=</span><span class="nu0">5</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>undefined</i><p><b>1. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
      <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
      <span class="kw1">return</span> idx<span class="sy0">;</span>
     <span class="kw1">return</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="sy0">-</span><span class="nu0">11</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,-</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,-</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Index of -2 is 1<br>
b) Index of -2 is 0<br>
c) Index of -2 is -1<br>
d) None of the mentioned<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the index of the first occurrence of -2. Since, -2 doesn’t exist in the array, the program prints -1.</i><p><b>2. What does the following code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="kw4">int</span> recursive_search_num<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> idx<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>idx <span class="sy0">==</span> len<span class="br0">)</span>
      <span class="kw1">return</span> cnt<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
       cnt<span class="sy0">++;</span>
      <span class="kw1">return</span> cnt <span class="sy0">+</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> idx<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,-</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> recursive_search_num<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Adds all the indexes of the number 0<br>
b) Finds the first last occurrence of the number 0<br>
c) Counts the number of occurrences of the number 0<br>
d) None of the mentioned<br>
</b></p><i>Answer: c<br>
Explanation: The above code counts the number of occurrences of the number 0.</i><p><b>3. Consider the following recursive implementation of the binary search:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
       <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
      <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
          __________<span class="sy0">;</span>
      <span class="kw1">else</span>
          hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be added to complete the above code?<br>
a) hi = mid – 1<br>
b) mid = (lo + hi)/2<br>
c) mid = lo – 1<br>
d) lo = mid + 1<br>
</b></p><i>Answer: d<br>
Explanation: The line “lo = mid + 1” should be added to complete the above code.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
        <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
         <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
         lo <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">else</span>
         hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">8</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">7</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The program prints the index of number 7, which is 6.</i><p><b>a) Index of 7 is 4<br>
b) Index of 7 is 5<br>
c) Index of 7 is 6<br>
d) Index of 7 is 7<br>
</b></p><i>Answer: d<br>
Explanation: In this case, when the function recursive_binary_search() is called for the first time we have: lo = 0 and hi = 7. So, the value of mid is:<br>
mid = (lo + hi)/2 = (0 + 7)/2 = 3. Since, arr[mid] = arr[3] = 0, the function returns the value of mid, which is 3.</i><p><b>5. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
       <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
       <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
          lo <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">else</span>
          hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Index of 0 is 0<br>
b) Index of 0 is 1<br>
c) Index of 0 is 2<br>
d) Index of 0 is 3<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above recursive implementation of binary search is O(logn).</i><p><b>6. What is the time complexity of the above recursive implementation of binary search?<br>
a) O(n)<br>
b) O(2<sup>n</sup>)<br>
c) O(logn)<br>
d) O(n!)<br>
</b></p><i>Answer: c<br>
Explanation: Since the array {5,4,3,2,1} is sorted in descending order, it will produce a wrong output.</i><p><b>7. In which of the below cases will the following code produce a wrong output?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
       <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
       <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
          lo <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">else</span>
          hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Array: {0,0,0,0,0,0} Search: -10<br>
b) Array: {1,2,3,4,5} Search: 0<br>
c) Array: {5,4,3,2,1} Search: 1<br>
d) Array: {-5,-4,-3,-2,-1} Search: -1<br>
</b></p><i>Answer: c<br>
Explanation: The function recursive_binary_search() is called 2 times, when the above code is executed.</i><p><b>8. How many times is the function recursive_binary_search() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
       <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
        <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
          lo <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">else</span>
          hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: Since the array is sorted in descending order, the above implementation of binary search will not work for the given array. Even though 1 is present in the array, binary search won’t be able to search it and it will produce -1 as an answer.</i><p><b>9. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> recursive_binary_search<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> num<span class="sy0">,</span> <span class="kw4">int</span> lo<span class="sy0">,</span> <span class="kw4">int</span> hi<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>lo <span class="sy0">&gt;</span> hi<span class="br0">)</span>
        <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw4">int</span> mid <span class="sy0">=</span> <span class="br0">(</span>lo <span class="sy0">+</span> hi<span class="br0">)</span><span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">==</span> num<span class="br0">)</span>
        <span class="kw1">return</span> mid<span class="sy0">;</span>
      <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>mid<span class="br0">]</span> <span class="sy0">&lt;</span> num<span class="br0">)</span>
          lo <span class="sy0">=</span> mid <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">else</span>
          hi <span class="sy0">=</span> mid <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span> num<span class="sy0">,</span> lo<span class="sy0">,</span> hi<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>num <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> indx <span class="sy0">=</span> recursive_binary_search<span class="br0">(</span>arr<span class="sy0">,</span>num<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Index of %d is %d"</span><span class="sy0">,</span>num<span class="sy0">,</span>indx<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>undefined</i><p><b>a) Index of 1 is 4<br>
b) Index of 1 is 5<br>
c) Index of 1 is -1<br>
d) Index of 1 is 0<br>
</b></p><i>undefined</i><p><b>1. Which of the following methods can be used to search an element in a linked list?<br>
a) Iterative linear search<br>
b) Iterative binary search<br>
c) Recursive binary search<br>
d) Normal binary search<br>
</b></p><i>Answer: a<br>
Explanation: Iterative linear search can be used to search an element in a linked list. Binary search can be used only when the list is sorted.</i><p><b>2. Consider the following code snippet to search an element in a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
              <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
           _________<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) temp = next<br>
b) temp-&gt;next = temp<br>
c) temp = temp-&gt;next<br>
d) return 0<br>
</b></p><i>Answer: c<br>
Explanation: The line “temp = temp-&gt;next” should be inserted to complete the above code.</i><p><b>3. What does the following code do?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
              <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span>
      <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span>i<span class="sy0">;</span>
      head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
      temp <span class="sy0">=</span> head<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span><span class="nu0">60</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">else</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Finds the index of the first occurrence of a number in a linked list<br>
b) Finds the index of the last occurrence of a number in a linked list<br>
c) Checks if a number is present in a linked list<br>
d) Checks whether the given list is sorted or not<br>
</b></p><i>Answer: c<br>
Explanation: The above code checks if a number is present in a linked list.</i><p><b>4. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
             <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Found<br>
b) Not found<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: b<br>
Explanation: Since the number -1 is not present in the linked list, the program prints not found.</i><p><b>5. What is the time complexity of the following implementation of linear search on a linked list?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
             <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The time complexity of the above implementation of linear search on a linked list is O(n).</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The condition in the while loop “temp-&gt;next == 0”, checks if the current element is the last element. If the current element is the last element, the value of the current element is not compared with the value to be searched. So, even though the number 6 is present in the linked list, it will print not found.</i><p><b>6. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">struct</span> Node <span class="sy0">*</span>temp <span class="sy0">=</span> head<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>temp <span class="sy0">-&gt;</span> next <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
      <span class="br0">{</span>
            <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
            <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
            temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span><span class="nu0">60</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Found<br>
b) Not found<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: a<br>
Explanation: Since linked list doesn’t allow random access, binary search cannot be applied on a sorted linked list in O(Logn) time.</i><p><b>8. What will be time complexity when binary search is applied on a linked list?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity will be O(n) when binary search is applied on a linked list.</i><p><b>9. Consider the following recursive implementation of linear search on a linked list:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> _________<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) 1<br>
b) 0<br>
c) linear_search(temp, value)<br>
d) linear_search(temp-&gt;next, value)<br>
</b></p><i>Answer: d<br>
Explanation: The line “linear_search(temp-&gt;next, value)”, should be inserted to complete the above code.</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> linear_search<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Found<br>
b) Not found<br>
c) Compile time error<br>
d) Runtime error<br>
</b></p><i>Answer: a<br>
Explanation: Since the element 6 is present in the linked list, the program prints “Found”.</i><p><b>11. How many times is the function linear_search() called when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> linear_search<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The function linear_search() is called 6 times when the above code is executed.</i><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above recursive implementation of linear search is O(n).</i><p><b>12. What is the time complexity of the following recursive implementation of linear search?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;stdlib.h&gt;</span>
<span class="kw4">struct</span> Node
<span class="br0">{</span>
     <span class="kw4">int</span> val<span class="sy0">;</span>
     <span class="kw4">struct</span> Node<span class="sy0">*</span> next<span class="sy0">;</span>
<span class="br0">}</span><span class="sy0">*</span>head<span class="sy0">;</span>
<span class="kw4">int</span> linear_search<span class="br0">(</span><span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">,</span><span class="kw4">int</span> value<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>temp <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>val <span class="sy0">==</span> value<span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">return</span> linear_search<span class="br0">(</span>temp<span class="sy0">-&gt;</span>next<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> n <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span>i<span class="sy0">;</span>
     head <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     head<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">struct</span> Node <span class="sy0">*</span>temp<span class="sy0">;</span>
     temp <span class="sy0">=</span> head<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
           <span class="kw4">struct</span> Node <span class="sy0">*</span>newNode <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">struct</span> Node<span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">struct</span> Node<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>next <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
           newNode<span class="sy0">-&gt;</span>val <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
           temp<span class="sy0">-&gt;</span>next <span class="sy0">=</span> newNode<span class="sy0">;</span>
           temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>next<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> linear_search<span class="br0">(</span>head<span class="sy0">-&gt;</span>next<span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Found"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Not found"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>undefined</i><p><b>1. What will be the output for following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">int</span> func<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> func<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>func<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">else</span>
		<span class="kw1">return</span> x<span class="sy0">*</span>func<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>func<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
    <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> func<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 9<br>
b) 6<br>
c) 8<br>
d) 5<br>
</b></p><i>Answer: c<br>
Explanation: The given program calculates the value of x raised to power y. Thus 2<sup>3</sup> = 8.</i><p><b>2. What will be the time complexity of the following code which raises an integer x to the power y?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">else</span>
		<span class="kw1">return</span> x<span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
    <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(log n)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The recurrence relation for the above code is given by T(n)=2T(n/2)+c. By using master theorem we can calculate the result for this relation. It is found to be equal to O(n).</i><p><b>3. What is the space complexity of the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">else</span>
		<span class="kw1">return</span> x<span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">*</span>power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
    <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: The space complexity of the given code will be equal to O(1) as it uses only constant space in the memory. </i><p><b>4. Recursive program to raise an integer x to power y uses which of the following algorithm?<br>
a) Dynamic programming<br>
b) Backtracking<br>
c) Divide and conquer<br>
d) Greedy algorithm<br>
</b></p><i>Answer: c<br>
Explanation: The recursive approach uses divide and conquer algorithm as we break the problem into smaller parts and then solve the smaller parts and finally combine their results to get the overall solution.</i><p><b>5. What is the least time in which we can raise a number x to power y?<br>
a) O(x)<br>
b) O(y)<br>
c) O(log x)<br>
d) O(log y)<br>
</b></p><i>Answer: d<br>
Explanation: We can optimize the code for finding power of a number by calculating x raised to power y/2 only once and using it depending on whether y is even or odd.</i><p><b>6. What will be the time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> temp<span class="sy0">;</span> 
    <span class="kw1">if</span><span class="br0">(</span> y <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span> 
    temp <span class="sy0">=</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
        <span class="kw1">return</span> temp<span class="sy0">*</span>temp<span class="sy0">;</span> 
    <span class="kw1">else</span>
        <span class="kw1">return</span> x<span class="sy0">*</span>temp<span class="sy0">*</span>temp<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
    <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
&nbsp;
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The given code is the optimized version for finding the power of a number. It forms a recurrence relation given by T(n)=T(n/2)+c which can be solved using master theorem. It is calculated to be equal to O(log n).</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Both iterative and recursive approach can be implemented in log n time but the recursive code requires memory in call stack which makes it less preferable.</i><p><b>7. What is the advantage of iterative code for finding power of number over recursive code?<br>
a) Iterative code requires less time<br>
b) Iterative code requires less space<br>
c) Iterative code is more compiler friendly<br>
d) It has no advantage<br>
</b></p><i>Answer: a<br>
Explanation: It represents the iterative version of required code. It has a time and space complexity of O(log n) and O(1) respectively.</i><p><b>8. Which of the following correctly implements iterative code for finding power of a number?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> res <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span>y <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">&amp;</span> <span class="nu0">1</span><span class="br0">)</span> 
            res <span class="sy0">=</span> res <span class="sy0">*</span> x<span class="sy0">;</span>         
        y <span class="sy0">=</span> y <span class="sy0">&gt;&gt;</span> <span class="nu0">1</span><span class="sy0">;</span> 
        x <span class="sy0">=</span> x <span class="sy0">*</span> x<span class="sy0">;</span>  
    <span class="br0">}</span> 
    <span class="kw1">return</span> res<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
    <span class="kw4">unsigned</span> <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>   
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> res <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span>y <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">&amp;&amp;</span> <span class="nu0">1</span><span class="br0">)</span> 
            res <span class="sy0">=</span> res <span class="sy0">*</span> x<span class="sy0">;</span>         
        y <span class="sy0">=</span> y <span class="sy0">&gt;&gt;</span> <span class="nu0">1</span><span class="sy0">;</span> 
        x <span class="sy0">=</span> x <span class="sy0">*</span> x<span class="sy0">;</span>  
    <span class="br0">}</span> 
    <span class="kw1">return</span> res<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
    <span class="kw4">unsigned</span> <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>   
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> res <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span>y <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">&amp;&amp;</span> <span class="nu0">1</span><span class="br0">)</span> 
        res <span class="sy0">=</span> x <span class="sy0">*</span> x<span class="sy0">;</span>         
        y <span class="sy0">=</span> y <span class="sy0">&gt;&gt;</span> <span class="nu0">1</span><span class="sy0">;</span> 
        x <span class="sy0">=</span> x <span class="sy0">*</span> y<span class="sy0">;</span>  
    <span class="br0">}</span> 
    <span class="kw1">return</span> res<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
    <span class="kw4">unsigned</span> <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>   
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="kw4">int</span> power<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span>  <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> res <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>   
    <span class="kw1">while</span> <span class="br0">(</span>y <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
    <span class="br0">{</span> 
        <span class="kw1">if</span> <span class="br0">(</span>y <span class="sy0">&amp;</span> <span class="nu0">1</span><span class="br0">)</span> 
        res <span class="sy0">=</span> x <span class="sy0">*</span> x<span class="sy0">;</span>         
        y <span class="sy0">=</span> y <span class="sy0">&gt;&gt;</span> <span class="nu0">1</span><span class="sy0">;</span> 
        x <span class="sy0">=</span> x <span class="sy0">*</span> y<span class="sy0">;</span>  
    <span class="br0">}</span> 
    <span class="kw1">return</span> res<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span> 
    <span class="kw4">unsigned</span> <span class="kw4">int</span> y <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>  
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>   
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The recursive code requires memory in call stack which makes it less preferable as compared to iterative approach.</i><p><b>10. What will be the output for following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">float</span> power<span class="br0">(</span><span class="kw4">float</span> x<span class="sy0">,</span> <span class="kw4">int</span> y<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">float</span> temp<span class="sy0">;</span> 
	<span class="kw1">if</span><span class="br0">(</span> y<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span> 
	temp <span class="sy0">=</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>	 
	<span class="kw1">if</span> <span class="br0">(</span>y<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="kw1">return</span> temp<span class="sy0">*</span>temp<span class="sy0">;</span> 
	<span class="kw1">else</span>
	<span class="br0">{</span> 
		<span class="kw1">if</span><span class="br0">(</span>y <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> 
			<span class="kw1">return</span> x<span class="sy0">*</span>temp<span class="sy0">*</span>temp<span class="sy0">;</span> 
		<span class="kw1">else</span>
			<span class="kw1">return</span> <span class="br0">(</span>temp<span class="sy0">*</span>temp<span class="br0">)</span><span class="sy0">/</span>x<span class="sy0">;</span> 
	<span class="br0">}</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">float</span> x <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> 
	<span class="kw4">int</span> y <span class="sy0">=</span> <span class="sy0">-</span><span class="nu0">3</span><span class="sy0">;</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%f"</span><span class="sy0">,</span> power<span class="br0">(</span>x<span class="sy0">,</span> y<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Error<br>
b) 1/4<br>
c) 4<br>
d) 0.25<br>
</b></p><i>Answer: d<br>
Explanation: The given code is capable of handling negative powers too. Thus, the output will be 2<sup>-2</sup> = 0.25.</i><p><b>1. What is the objective of tower of hanoi puzzle?<br>
a) To move all disks to some other rod by following rules<br>
b) To divide the disks equally among the three rods by following rules<br>
c) To move all disks to some other rod in random order<br>
d) To divide the disks equally among three rods in random order<br>
</b></p><i>Answer: a<br>
Explanation: Objective of tower of hanoi problem is to move all disks to some other rod by following the following rules-1) Only one disk can be moved at a time. 2) Disk can only be moved if it is the uppermost disk of the stack. 3) No disk should be placed over a smaller disk.</i><p><b>2. Which of the following is NOT a rule of tower of hanoi puzzle?<br>
a) No disk should be placed over a smaller disk<br>
b) Disk can only be moved if it is the uppermost disk of the stack<br>
c) No disk should be placed over a larger disk<br>
d) Only one disk can be moved at a time<br>
</b></p><i>Answer: c<br>
Explanation: The rule is to not put a disk over a smaller one. Putting a smaller disk over larger one is allowed.</i><p><b>3. The time complexity of the solution tower of hanoi problem using recursion is _________<br>
a) O(n<sup>2</sup>)<br>
b) O(2<sup>n</sup>)<br>
c) O(n log n)<br>
d) O(n)<br>
</b></p><i>Answer: b<br>
Explanation: Time complexity of the problem can be found out by solving the recurrence relation: T(n)=2T(n-1)+c. Result of this relation is found to be equal to 2<sup>n</sup>. It can be solved using substitution.</i><p><b>4. Recurrence equation formed for the tower of hanoi problem is given by _________<br>
a) T(n) = 2T(n-1)+n<br>
b) T(n) = 2T(n/2)+c<br>
c) T(n) = 2T(n-1)+c<br>
d) T(n) = 2T(n/2)+n<br>
</b></p><i>Answer: c<br>
Explanation: As there are 2 recursive calls to n-1 disks and one constant time operation so the recurrence relation will be given by T(n) = 2T(n-1)+c.</i><p><b>5. Minimum number of moves required to solve a tower of hanoi problem with n disks is __________<br>
a) 2<sup>n</sup><br>
b) 2<sup>n</sup>-1<br>
c) n<sup>2</sup><br>
d) n<sup>2</sup>-1<br>
</b></p><i>Answer: b<br>
Explanation: Minimum number of moves can be calculated by solving the recurrence relation – T(n)=2T(n-1)+c. Alternatively we can observe the pattern formed by the series of number of moves 1,3,7,15…..Either way it turn out to be equal to 2<sup>n</sup>-1.</i><p><b>6. Space complexity of recursive solution of tower of hanoi puzzle is ________<br>
a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: Space complexity of tower of hanoi problem can be found out by solving the recurrence relation T(n)=T(n-1)+c. Result of this relation is found out to be n. It can be solved using substitution.</i><p><b>7. Which of the following functions correctly represent the solution to tower of hanoi puzzle?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> ToH<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> a<span class="sy0">,</span><span class="kw4">int</span> b<span class="sy0">,</span><span class="kw4">int</span> c<span class="br0">)</span>
<span class="br0">{</span>
   If<span class="br0">(</span>n<span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
   <span class="br0">{</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>a<span class="sy0">,</span>c<span class="sy0">,</span>b<span class="br0">)</span><span class="sy0">;</span>
       cout<span class="sy0">&lt;&lt;</span>”move a disk from” <span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” to”<span class="sy0">&lt;&lt;</span> c<span class="sy0">;</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>b<span class="sy0">,</span>a<span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
   <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> ToH<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> a<span class="sy0">,</span><span class="kw4">int</span> b<span class="sy0">,</span><span class="kw4">int</span> c
<span class="br0">{</span>
   If<span class="br0">(</span>n<span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
   <span class="br0">{</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>a<span class="sy0">,</span>b<span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
       cout<span class="sy0">&lt;&lt;</span>”move a disk from” <span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” to”<span class="sy0">&lt;&lt;</span> c<span class="sy0">;</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>b<span class="sy0">,</span>a<span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
   <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> ToH<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> a<span class="sy0">,</span><span class="kw4">int</span> b<span class="sy0">,</span><span class="kw4">int</span> c<span class="br0">)</span>
<span class="br0">{</span>
     If<span class="br0">(</span>n<span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
     <span class="br0">{</span>
         ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>a<span class="sy0">,</span>c<span class="sy0">,</span>b<span class="br0">)</span><span class="sy0">;</span>
         cout<span class="sy0">&lt;&lt;</span>”move a disk from” <span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” to”<span class="sy0">&lt;&lt;</span> c<span class="sy0">;</span>
         ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>a<span class="sy0">,</span>b<span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> ToH<span class="br0">(</span><span class="kw4">int</span> n<span class="sy0">,</span><span class="kw4">int</span> a<span class="sy0">,</span><span class="kw4">int</span> b<span class="sy0">,</span><span class="kw4">int</span> c<span class="br0">)</span>
<span class="br0">{</span>
   If<span class="br0">(</span>n<span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>
   <span class="br0">{</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>b<span class="sy0">,</span>a<span class="sy0">,</span>c<span class="br0">)</span><span class="sy0">;</span>
       cout<span class="sy0">&lt;&lt;</span>”move a disk from” <span class="sy0">&lt;&lt;</span>a<span class="sy0">&lt;&lt;</span>” to”<span class="sy0">&lt;&lt;</span> c<span class="sy0">;</span>
       ToH<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>a<span class="sy0">,</span>c<span class="sy0">,</span>b<span class="br0">)</span><span class="sy0">;</span>
   <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The first recursive call moves n-1 disks from a to b using c. Then we move a disk from a to c. Finally the second recursive call moves n-1 disks from b to c using a.</i><p><b>8. Recursive solution of tower of hanoi problem is an example of which of the following algorithm?<br>
a) Dynamic programming<br>
b) Backtracking<br>
c) Greedy algorithm<br>
d) Divide and conquer<br>
</b></p><i>Answer: d<br>
Explanation: The recursive approach uses divide and conquer algorithm as we break the problem into smaller parts and then solve the smaller parts and finally combine their results to get the overall solution.</i><p><b>10. Minimum time required to solve tower of hanoi puzzle with 4 disks assuming one move takes 2 seconds, will be __________<br>
a) 15 seconds<br>
b) 30 seconds<br>
c) 16 seconds<br>
d) 32 seconds<br>
</b></p><i>Answer: a<br>
Explanation: Iterative solution to tower of hanoi puzzle also exists. Its approach depends on whether the total numbers of disks are even or odd.</i><p><b>1. Master’s theorem is used for?<br>
a) solving recurrences<br>
b) solving iterative relations<br>
c) analysing loops<br>
d) calculating the time complexity of any code<br>
</b></p><i>Answer: a<br>
Explanation: Master’s theorem is a direct method for solving recurrences. We can solve any recurrence that falls under any one of the three cases of master’s theorem. </i><p><b>2. How many cases are there under Master’s theorem?<br>
a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: b<br>
Explanation: There are primarily 3 cases under master’s theorem. We can solve any recurrence that falls under any one of these three cases. </i><p><b>3. What is the result of the recurrences which fall under first case of Master’s theorem (let the recurrence be given by T(n)=aT(n/b)+f(n) and f(n)=n<sup>c</sup>?<br>
a) T(n) = O(n^log<sub>b</sub>a)<br>
b) T(n) = O(n<sup>c</sup> log n)<br>
c) T(n) = O(f(n))<br>
d) T(n) = O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: In first case of master’s theorem the necessary condition is that c &lt; log<sub>b</sub>a. If this condition is true then T(n) = O(n^log<sub>b</sub>a).</i><p><b>4. What is the result of the recurrences which fall under second case of Master’s theorem (let the recurrence be given by T(n)=aT(n/b)+f(n) and f(n)=n<sup>c</sup>?<br>
a) T(n) = O(nlog<sub>b</sub>a)<br>
b) T(n) = O(n<sup>c</sup> log n)<br>
c) T(n) = O(f(n))<br>
d) T(n) = O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: In second case of master’s theorem the necessary condition is that c = log<sub>b</sub>a. If this condition is true then T(n) = O(n<sup>c</sup> log n)</i><p><b>5. What is the result of the recurrences which fall under third case of Master’s theorem (let the recurrence be given by T(n)=aT(n/b)+f(n) and f(n)=n<sup>c</sup>?<br>
a) T(n) = O(nlog<sub>b</sub>a)<br>
b) T(n) = O(n<sup>c</sup> log n)<br>
c) T(n) = O(f(n))<br>
d) T(n) = O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: In third case of master’s theorem the necessary condition is that c &gt; log<sub>b</sub>a. If this condition is true then T(n) = O(f(n)).</i><p><b>7. Under what case of Master’s theorem will the recurrence relation of merge sort fall?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) It cannot be solved using master’s theorem<br>
</b></p><i>Answer: b<br>
Explanation: No we cannot solve all the recurrences by only using master’s theorem. We can solve only those which fall under the three cases prescribed in the theorem.</i><p><b>8. Under what case of Master’s theorem will the recurrence relation of stooge sort fall?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) It cannot be solved using master’s theorem<br>
</b></p><i>Answer: b<br>
Explanation: The recurrence relation of merge sort is given by T(n) = 2T(n/2) + O(n). So we can observe that c = Log<sub>b</sub>a so it will fall under case 2 of master’s theorem.</i><p><b>9. Which case of master’s theorem can be extended further?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) No case can be extended<br>
</b></p><i>Answer: a<br>
Explanation:  The recurrence relation of stooge sort is given as T(n) = 3T(2/3n) + O(1). It is found too be equal to O(n<sup>2.7</sup>) using master’s theorem first case.</i><p><b>10. What is the result of the recurrences which fall under the extended second case of Master’s theorem (let the recurrence be given by T(n)=aT(n/b)+f(n) and f(n)=n<sup>c</sup>(log n)k?<br>
a) T(n) = O(nlog<sub>b</sub>a)<br>
b) T(n) = O(n<sup>c</sup> log n)<br>
c) T(n)= O(n<sup>c</sup> (log n)<sup>k+1</sup><br>
d) T(n) = O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The second case of master’s theorem can be extended for a case where f(n) = n<sup>c</sup> (log n)<sup>k</sup> and the resulting recurrence becomes T(n)= O(n<sup>c</sup> (log n))<sup>k+1</sup>.</i><p><b>11. Under what case of Master’s theorem will the recurrence relation of binary search fall?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) It cannot be solved using master’s theorem<br>
</b></p><i>Answer: c<br>
Explanation: In the extended second case of master’s theorem the necessary condition is that c = log<sub>b</sub>a. If this condition is true then T(n)= O(n<sup>c</sup>(log n))<sup>k+1</sup>.</i><p><b>8. What will be the recurrence relation of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">Int sum<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
   If<span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">1</span><span class="br0">)</span>
       <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
   <span class="kw1">else</span>
       <span class="kw1">return</span> n<span class="sy0">+</span>sum<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) T(n) = T(n/2) + n<br>
b) T(n) = T(n-1) + n<br>
c) T(n) = T(n-1) + O(1)<br>
d) T(n) = T(n/2) + O(1)<br>
</b></p><i>Answer: c<br>
Explanation: The given recurrence can be solved by using the second case of Master’s theorem.<br>
T(n) = O(nc log n) = Here nc = n<sup>2</sup><br>
So the solution becomes T(n) = O(n<sup>2</sup>log n).</i><p><b>9. What will be the recurrence relation of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> xpowy<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="kw1">if</span> <span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">1</span><span class="br0">)</span> <span class="kw1">return</span> x<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n <span class="sy0">%</span> <span class="nu0">2</span><span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="kw1">return</span> xpowy<span class="br0">(</span>x<span class="sy0">*</span>x<span class="sy0">,</span> n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="kw1">else</span>
<span class="kw1">return</span> xpowy<span class="br0">(</span>x<span class="sy0">*</span>x<span class="sy0">,</span> n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span> <span class="sy0">*</span> x<span class="sy0">;</span></pre></div></div></div></div></div></div><p><b>a) T(n) = T(n/2) + n<br>
b) T(n) = T(n-1) + n<br>
c) T(n) = T(n-1) + O(1)<br>
d) T(n) = T(n/2) + O(1)<br>
</b></p><i>Answer: c<br>
Explanation: The given recurrence can be solved by using the third case (as f(n) &gt; log21) of Master’s theorem.<br>
T(n) = O(f(n)) = Here f(n) = 2n.<br>
So the solution becomes T(n) = O(2n). </i><p><b>10. What will be the time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> xpowy<span class="br0">(</span><span class="kw4">int</span> x<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> 
        <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">1</span><span class="br0">)</span> 
        <span class="kw1">return</span> x<span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n <span class="sy0">%</span> <span class="nu0">2</span><span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> xpowy<span class="br0">(</span>x<span class="sy0">*</span>x<span class="sy0">,</span> n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
        <span class="kw1">return</span> xpowy<span class="br0">(</span>x<span class="sy0">*</span>x<span class="sy0">,</span> n<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span> <span class="sy0">*</span> x<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(log n)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The given recurrence can be solved by using the first case of Master’s theorem. So the solution becomes T(n) = O(n<sup>2</sup>).</i><p><b>1. Fractional knapsack problem is also known as __________<br>
a) 0/1 knapsack problem<br>
b) Continuous knapsack problem<br>
c) Divisible knapsack problem<br>
d) Non continuous knapsack problem<br>
</b></p><i>Answer: b<br>
Explanation: Fractional knapsack problem is also called continuous knapsack problem. Fractional knapsack is solved using dynamic programming.</i><p><b>2. Fractional knapsack problem is solved most efficiently by which of the following algorithm?<br>
a) Divide and conquer<br>
b) Dynamic programming<br>
c) Greedy algorithm<br>
d) Backtracking<br>
</b></p><i>Answer: c<br>
Explanation: Greedy algorithm is used to solve this problem. We first sort items according to their value/weight ratio and then add item with highest ratio until we cannot add the next item as a whole. At the end, we add the next item as much as we can.</i><p><b>3. What is the objective of the knapsack problem?<br>
a) To get maximum total value in the knapsack<br>
b) To get minimum total value in the knapsack<br>
c) To get maximum weight in the knapsack<br>
d) To get minimum weight in the knapsack<br>
</b></p><i>Answer: a<br>
Explanation: The objective is to fill the knapsack of some given volume with different materials such that the value of selected items is maximized. </i><p><b>4. Which of the following statement about 0/1 knapsack and fractional knapsack problem is correct?<br>
a) In 0/1 knapsack problem items are divisible and in fractional knapsack items are indivisible<br>
b) Both are the same<br>
c) 0/1 knapsack is solved using a greedy algorithm and fractional knapsack is solved using dynamic programming<br>
d) In 0/1 knapsack problem items are indivisible and in fractional knapsack items are divisible<br>
</b></p><i>Answer: d<br>
Explanation: In fractional knapsack problem we can partially include an item into the knapsack whereas in 0/1 knapsack we have to either include or exclude the item wholly.</i><p><b>5. Time complexity of fractional knapsack problem is ____________<br>
a) O(n log n)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(nW)<br>
</b></p><i>Answer: a<br>
Explanation: As the main time taking a step is of sorting so it defines the time complexity of our code. So the time complexity will be O(n log n) if we use quick sort for sorting.</i><p><b>7. Given items as {value,weight} pairs {{40,20},{30,10},{20,5}}. The capacity of knapsack=20. Find the maximum value output assuming items to be divisible.<br>
a) 60<br>
b) 80<br>
c) 100<br>
d) 40<br>
</b></p><i>Answer: a<br>
Explanation: It is possible to solve the problem in O(n) time by adapting the algorithm for finding weighted medians.</i><p><b>9. The main time taking step in fractional knapsack problem is ___________<br>
a) Breaking items into fraction<br>
b) Adding items into knapsack<br>
c) Sorting<br>
d) Looping through sorted items<br>
</b></p><i>Answer: a<br>
Explanation: The value/weight ratio are-{2,3,4}. So we include the second and third items wholly into the knapsack. This leaves only 5 units of volume for the first item. So we include the first item partially.<br>
Final value = 20+30+(40/4)=60.</i><p><b>10. Given items as {value,weight} pairs {{60,20},{50,25},{20,5}}. The capacity of knapsack=40. Find the maximum value output assuming items to be divisible and nondivisible respectively.<br>
a) 100, 80<br>
b) 110, 70<br>
c) 130, 110<br>
d) 110, 80<br>
</b></p><i>Answer: a<br>
Explanation: As fractional knapsack gives extra liberty to include the object partially which is not possible with 0/1 knapsack, thus we get better results with a fractional knapsack. </i><p><b>1. Which of the following algorithms is the best approach for solving Huffman codes?<br>
a) exhaustive search<br>
b) greedy algorithm<br>
c) brute force algorithm<br>
d) divide and conquer algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Greedy algorithm is the best approach for solving the Huffman codes problem since it greedily searches for an optimal solution.</i><p><b>2. How many printable characters does the ASCII character set consists of?<br>
a) 120<br>
b) 128<br>
c) 100<br>
d) 98<br>
</b></p><i>Answer: c<br>
Explanation: Out of 128 characters in an ASCII set, roughly, only 100 characters are printable while the rest are non-printable.</i><p><b>3. Which bit is reserved as a parity bit in an ASCII set?<br>
a) first<br>
b) seventh<br>
c) eighth<br>
d) tenth<br>
</b></p><i>Answer: c<br>
Explanation: In an ASCII character set, seven bits are reserved for character representation while the eighth bit is a parity bit.</i><p><b>4. How many bits are needed for standard encoding if the size of the character set is X?<br>
a) log X<br>
b) X+1<br>
c) 2X<br>
d) X<sup>2</sup><br>
</b></p><i>Answer: a<br>
Explanation: If the size of the character set is X, then [log X] bits are needed for representation in a standard encoding.</i><p><b>6. In Huffman coding, data in a tree always occur?<br>
a) roots<br>
b) leaves<br>
c) left sub trees<br>
d) right sub trees<br>
</b></p><i>Answer: b<br>
Explanation: The code length depends on the frequency of occurrence of characters. The more frequent the character occurs, the less is the length of the code.</i><p><b>9. What will be the cost of the code if character c<sub>i</sub> is at depth d<sub>i</sub> and occurs at frequency f<sub>i</sub>?<br>
a) c<sub>i</sub>f<sub>i</sub><br>
b) ∫c<sub>i</sub>f<sub>i</sub><br>
c) ∑f<sub>i</sub>d<sub>i</sub><br>
d) f<sub>i</sub>d<sub>i</sub><br>
</b></p><i>Answer: b<br>
Explanation: In Huffman encoding, data is always stored at the leaves of a tree inorder to compute the codeword effectively.</i><p><b>11. The type of encoding where no character code is the prefix of another character code is called?<br>
a) optimal encoding<br>
b) prefix encoding<br>
c) frequency encoding<br>
d) trie encoding<br>
</b></p><i>Answer: a<br>
Explanation: By recording the path of the node from root to leaf, the code word for character ‘a’ is found to be 011.</i><p><b>12. What is the running time of the Huffman encoding algorithm?<br>
a) O(C)<br>
b) O(log C)<br>
c) O(C log C)<br>
d) O( N log C)<br>
</b></p><i>Answer: c<br>
Explanation: By recording the path of the node from root to leaf, assigning left branch as 0 and right branch as 1, the codeword for c is 110.</i><p><b>13. What is the running time of the Huffman algorithm, if its implementation of the priority queue is done using linked lists?<br>
a) O(C)<br>
b) O(log C)<br>
c) O(C log C)<br>
d) O(C<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: If character c<sub>i</sub> is at depth d<sub>i</sub> and occurs at frequency f<sub>i</sub>, the cost of the codeword obtained is ∑f<sub>i</sub>d<sub>i</sub>.</i><p><b>1. Which of the problems cannot be solved by backtracking method?<br>
a) n-queen problem<br>
b) subset sum problem<br>
c) hamiltonian circuit problem<br>
d) travelling salesman problem<br>
</b></p><i>Answer: d<br>
Explanation: N-queen problem, subset sum problem, Hamiltonian circuit problems can be solved by backtracking method whereas travelling salesman problem is solved by Branch and bound method.</i><p><b>2. Backtracking algorithm is implemented by constructing a tree of choices called as?<br>
a) State-space tree<br>
b) State-chart tree<br>
c) Node tree<br>
d) Backtracking tree<br>
</b></p><i>Answer: a<br>
Explanation: Backtracking problem is solved by constructing a tree of choices called as the state-space tree. Its root represents an initial state before the search for a solution begins.</i><p><b>3. What happens when the backtracking algorithm reaches a complete solution?<br>
a) It backtracks to the root<br>
b) It continues searching for other possible solutions<br>
c) It traverses from a different route<br>
d) Recursively traverses through the same route<br>
</b></p><i>Answer: b<br>
Explanation: When we reach a final solution using a backtracking algorithm, we either stop or continue searching for other possible solutions.</i><p><b>4. A node is said to be ____________ if it has a possibility of reaching a complete solution.<br>
a) Non-promising<br>
b) Promising<br>
c) Succeeding<br>
d) Preceding<br>
</b></p><i>Answer: b<br>
Explanation: If a node has a possibility of reaching the final solution, it is called a promising node. Otherwise, it is non-promising.</i><p><b>5. In what manner is a state-space tree for a backtracking algorithm constructed?<br>
a) Depth-first search<br>
b) Breadth-first search<br>
c) Twice around the tree<br>
d) Nearest neighbour first<br>
</b></p><i>Answer: a<br>
Explanation: A state-space tree for a backtracking algorithm is constructed in the manner of depth-first search so that it is easy to look into.</i><p><b>7. In general, backtracking can be used to solve?<br>
a) Numerical problems<br>
b) Exhaustive search<br>
c) Combinatorial problems<br>
d) Graph coloring problems<br>
</b></p><i>Answer: b<br>
Explanation: The leaves in a state space tree can either represent non-promising dead ends or complete solutions found by the algorithm.</i><p><b>8. Which one of the following is an application of the backtracking algorithm?<br>
a) Finding the shortest path<br>
b) Finding the efficient quantity to shop<br>
c) Ludo<br>
d) Crossword<br>
</b></p><i>Answer: c<br>
Explanation: Backtracking approach is used to solve complex combinatorial problems which cannot be solved by exhaustive search algorithms.</i><p><b>10. Which of the following logical programming languages is not based on backtracking?<br>
a) Icon<br>
b) Prolog<br>
c) Planner<br>
d) Fortran<br>
</b></p><i>Answer: d<br>
Explanation: Crossword puzzles are based on backtracking approach whereas the rest are travelling salesman problem, knapsack problem and dice game.</i><p><b>11. The problem of finding a list of integers in a given specific range that meets certain conditions is called?<br>
a) Subset sum problem<br>
b) Constraint satisfaction problem<br>
c) Hamiltonian circuit problem<br>
d) Travelling salesman problem<br>
</b></p><i>Answer: a<br>
Explanation: Backtracking is faster than brute force approach since it can remove a large set of answers in one test.</i><p><b>12. Who coined the term ‘backtracking’?<br>
a) Lehmer<br>
b) Donald<br>
c) Ross<br>
d) Ford<br>
</b></p><i>Answer: d<br>
Explanation: Backtracking algorithm form the basis for icon, planner and prolog whereas fortran is an ancient assembly language used in second generation computers.</i><p><b>13. ___________ enumerates a list of promising nodes that could be computed to give the possible solutions of a given problem.<br>
a) Exhaustive search<br>
b) Brute force<br>
c) Backtracking<br>
d) Divide and conquer<br>
</b></p><i>Answer: b<br>
Explanation: Constraint satisfaction problem is the problem of finding a list of integers under given constraints. Constraint satisfaction problem is solved using a backtracking approach.</i><p><b>14. The problem of finding a subset of positive integers whose sum is equal to a given positive integer is called as?<br>
a) n- queen problem<br>
b) subset sum problem<br>
c) knapsack problem<br>
d) hamiltonian circuit problem<br>
</b></p><i>Answer: a<br>
Explanation: D.H. Lehmer was the first person to coin the term backtracking. Initially, the backtracking facility was provided using SNOBOL.</i><p><b>15. The problem of placing n queens in a chessboard such that no two queens attack each other is called as?<br>
a) n-queen problem<br>
b) eight queens puzzle<br>
c) four queens puzzle<br>
d) 1-queen problem<br>
</b></p><i>Answer: c<br>
Explanation: Backtracking is a general algorithm that evaluates partially constructed candidates that can be developed further without violating problem constraints.</i><p><b>1. Who published the eight queens puzzle?<br>
a) Max Bezzel<br>
b) Carl<br>
c) Gauss<br>
d) Friedrich<br>
</b></p><i>Answer: a<br>
Explanation: The first Eight Queen Puzzle was published by Max Friedrich William Bezzel, who was a chess composer by profession in 1848. He was a German chess composer and the first person to publish the puzzle.</i><p><b>2. When was the Eight Queen Puzzle published?<br>
a) 1846<br>
b) 1847<br>
c) 1848<br>
d) 1849<br>
</b></p><i>Answer: c<br>
Explanation: The first Eight Queen Puzzle was published by Max Friedrich William Bezzel, who was a German chess composer by profession. He published the puzzle in 1848.</i><p><b>3. Who published the first solution of the eight queens puzzle?<br>
a) Franz Nauck<br>
b) Max Bezzel<br>
c) Carl<br>
d) Friedrich<br>
</b></p><i>Answer: a<br>
Explanation: The first solution to the Eight Queen Puzzle was given by Franz Nauck in 1850. While the first Eight Queen Puzzle was published by Max Friedrich William Bezzel, who was a German chess composer.</i><p><b>4. When was the first solution to Eight Queen Puzzle published?<br>
a) 1850<br>
b) 1847<br>
c) 1848<br>
d) 1849<br>
</b></p><i>Answer: a<br>
Explanation: The first solution to the Eight Queen Puzzle was given by Franz Nauck in 1850. Max Friedrich William Bezzel, who was a German chess composer by profession published the puzzle in 1848.</i><p><b>5. Who published the extended version of eight queens puzzle?<br>
a) Franz Nauck<br>
b) Max Bezzel<br>
c) Carl<br>
d) Friedrich<br>
</b></p><i>Answer: a<br>
Explanation: The first extended version to the Eight Queen Puzzle was given by Franz Nauck in 1850. Max Friedrich William Bezzel published the puzzle in 1848.</i><p><b>6. For how many queens was the extended version of Eight Queen Puzzle applicable for n*n squares?<br>
a) 5<br>
b) 6<br>
c) 8<br>
d) n<br>
</b></p><i>Answer: d<br>
Explanation: The extended version given by Franz Nauck of the Eight Queen Puzzle was for n queens on n*n square chessboard. Earlier the puzzle was proposed with 8 queens on 8*8 board.</i><p><b>7. Who was the first person to find the solution of Eight Queen Puzzle using determinant?<br>
a) Max Bezzel<br>
b) Frank Nauck<br>
c) Gunther<br>
d) Friedrich<br>
</b></p><i>Answer: c<br>
Explanation: S. Gunther was the first person to propose a solution to the eight queen puzzle using determinant. Max Friedrich William Bezzel published the puzzle and the first solution to the Eight Queen Puzzle was given by Franz Nauck.</i><p><b>8. Who proposed the depth first backtracking algorithm?<br>
a) Edsger Dijkshtra<br>
b) Max Bezzel<br>
c) Frank Nauck<br>
d) Carl Friedrich<br>
</b></p><i>Answer: a<br>
Explanation: In 1972, depth first backtracking algorithm was proposed by Edsger Dijkshtra to illustrate the Eight Queen Puzzle. Max Friedrich William Bezzel published the puzzle and the first solution to the Eight Queen Puzzle was given by Franz Nauck.</i><p><b>9. How many solutions are there for 8 queens on 8*8 board?<br>
a) 12<br>
b) 91<br>
c) 92<br>
d) 93<br>
</b></p><i>Answer: c<br>
Explanation: For 8*8 chess board with 8 queens there are total of 92 solutions for the puzzle. There are total of 12 fundamental solutions to the eight queen puzzle.</i><p><b>10. Who publish the bitwise operation method to solve the eight queen puzzle?<br>
a) Zongyan Qiu<br>
b) Martin Richard<br>
c) Max Bezzel<br>
d) Frank Nauck<br>
</b></p><i>Answer: a<br>
Explanation: The first person to publish the bitwise operation method to solve the eight queen puzzle was Zongyan Qiu. After him, it was published by Martin Richard.</i><p><b>11. How many fundamental solutions are there for the eight queen puzzle?<br>
a) 92<br>
b) 10<br>
c) 11<br>
d) 12<br>
</b></p><i>Answer: d<br>
Explanation: There are total of 12 fundamental solutions to the eight queen puzzle after removing the symmetrical solutions due to rotation. For 8*8 chess board with 8 queens there are total of 92 solutions for the puzzle.</i><p><b>13. How many fundamental solutions are the for 3 queens on a 3*3 board?<br>
a) 1<br>
b) 12<br>
c) 3<br>
d) 0<br>
</b></p><i>Answer: b<br>
Explanation: No three queens lie in a straight line in one of the fundamental solution of the eight queen puzzle.</i><p><b>15. Which ordered board is the highest enumerated board till now?<br>
a) 25*25<br>
b) 26*26<br>
c) 27*27<br>
d) 28*28<br>
</b></p><i>Answer: d<br>
Explanation: There are in total zero solution to the 3 queen puzzle for 3*3 chess board. Hence there are no fundamental solutions. For 8*8 chess board with 8 queens there are total of 12 fundamental solutions for the puzzle.</i><p><b>1. In how many directions do queens attack each other?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: Queens attack each other in three directions- vertical, horizontal and diagonal.</i><p><b>2. Placing n-queens so that no two queens attack each other is called?<br>
a) n-queen’s problem<br>
b) 8-queen’s problem<br>
c) Hamiltonian circuit problem<br>
d) subset sum problem<br>
</b></p><i>Answer: a<br>
Explanation: Placing n queens so that no two queens attack each other is n-queens problem. If n=8, it is called as 8-queens problem.</i><p><b>3. Where is the n-queens problem implemented?<br>
a) carom<br>
b) chess<br>
c) ludo<br>
d) cards<br>
</b></p><i>Answer: b<br>
Explanation: N-queens problem occurs in chess. It is the problem of placing n- queens in a n*n chess board.</i><p><b>5. In n-queen problem, how many values of n does not provide an optimal solution?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: Unlike a real chess game, n-queens occur in a n-queen problem since it is the problem of dealing with n-queens.</i><p><b>6. Which of the following methods can be used to solve n-queen’s problem?<br>
a) greedy algorithm<br>
b) divide and conquer<br>
c) iterative improvement<br>
d) backtracking<br>
</b></p><i>Answer: b<br>
Explanation: N-queen problem does not provide an optimal solution of only three values of n (i.e.) n=2,3.</i><p><b>7. Of the following given options, which one of the following is a correct option that provides an optimal solution for 4-queens problem?<br>
a) (3,1,4,2)<br>
b) (2,3,1,4)<br>
c) (4,3,2,1)<br>
d) (4,2,3,1)<br>
</b></p><i>Answer: d<br>
Explanation: Of the following given approaches, n-queens problem can be solved using backtracking. It can also be solved using branch and bound.</i><p><b>8. How many possible solutions exist for an 8-queen problem?<br>
a) 100<br>
b) 98<br>
c) 92<br>
d) 88<br>
</b></p><i>Answer: a<br>
Explanation: Of the following given options for optimal solutions of 4-queens problem, (3, 1, 4, 2) is the right option.</i><p><b>9. How many possible solutions occur for a 10-queen problem?<br>
a) 850<br>
b) 742<br>
c) 842<br>
d) 724<br>
</b></p><i>Answer: c<br>
Explanation: For an 8-queen problem, there are 92 possible combinations of optimal solutions.</i><p><b>11. What is the domination number for 8-queen’s problem?<br>
a) 8<br>
b) 7<br>
c) 6<br>
d) 5<br>
</b></p><i>Answer: d<br>
Explanation: For a 10-queen problem, 724 possible combinations of optimal solutions are available.</i><p><b>12.  Of the following given options, which one of the following does not provides an optimal solution for 8-queens problem?<br>
a) (5,3,8,4,7,1,6,2)<br>
b) (1,6,3,8,3,2,4,7)<br>
c) (4,1,5,8,6,3,7,2)<br>
d) (6,2,7,1,4,8,5,3)<br>
</b></p><i>Answer: b<br>
Explanation: For n=1, the n-queen problem has a trivial and real solution and it is represented by<a href="https://www.sanfoundry.com/wp-content/uploads/2018/07/n-queens-problem-questions-answers-q10.png"><noscript><img src="https://www.sanfoundry.com/wp-content/uploads/2018/07/n-queens-problem-questions-answers-q10.png" alt="n-queens-problem-questions-answers-q10" width="53" height="49" class="alignnone size-full wp-image-218935" /></noscript><img src="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%2053%2049%22%3E%3C/svg%3E" data-src="https://www.sanfoundry.com/wp-content/uploads/2018/07/n-queens-problem-questions-answers-q10.png" alt="n-queens-problem-questions-answers-q10" width="53" height="49" class="lazyload alignnone size-full wp-image-218935"></a> </i><p><b>1. Which of the following is/are property/properties of a dynamic programming problem?<br>
a) Optimal substructure<br>
b) Overlapping subproblems<br>
c) Greedy approach<br>
d) Both optimal substructure and overlapping subproblems<br>
</b></p><i>Answer: d<br>
Explanation: A problem that can be solved using dynamic programming possesses overlapping subproblems as well as optimal substructure properties.</i><p><b>2. If an optimal solution can be created for a problem by constructing optimal solutions for its subproblems, the problem possesses ____________ property.<br>
a) Overlapping subproblems<br>
b) Optimal substructure<br>
c) Memoization<br>
d) Greedy<br>
</b></p><i>Answer: b<br>
Explanation: Optimal substructure is the property in which an optimal solution is found for the problem by constructing optimal solutions for the subproblems.</i><p><b>3. If a problem can be broken into subproblems which are reused several times, the problem possesses ____________ property.<br>
a) Overlapping subproblems<br>
b) Optimal substructure<br>
c) Memoization<br>
d) Greedy<br>
</b></p><i>Answer: a<br>
Explanation: Overlapping subproblems is the property in which value of a subproblem is used several times.</i><p><b>4. If a problem can be solved by combining optimal solutions to non-overlapping problems, the strategy is called _____________<br>
a) Dynamic programming<br>
b) Greedy<br>
c) Divide and conquer<br>
d) Recursion<br>
</b></p><i>Answer: c<br>
Explanation: In divide and conquer, the problem is divided into smaller non-overlapping subproblems and an optimal solution for each of the subproblems is found. The optimal solutions are then combined to get a global optimal solution. For example, mergesort uses divide and conquer strategy.</i><p><b>7. In dynamic programming, the technique of storing the previously calculated values is called ___________<br>
a) Saving value property<br>
b) Storing value property<br>
c) Memoization<br>
d) Mapping<br>
</b></p><i>Answer: a<br>
Explanation: Dynamic programming calculates the value of a subproblem only once, while other methods that don’t take advantage of the overlapping subproblems property may calculate the value of the same subproblem several times. So, dynamic programming saves the time of recalculation and takes far less time as compared to other methods that don’t take advantage of the overlapping subproblems property.</i><p><b>8. When a top-down approach of dynamic programming is applied to a problem, it usually _____________<br>
a) Decreases both, the time complexity and the space complexity<br>
b) Decreases the time complexity and increases the space complexity<br>
c) Increases the time complexity and decreases the space complexity<br>
d) Increases both, the time complexity and the space complexity<br>
</b></p><i>Answer: b<br>
Explanation: A greedy algorithm gives optimal solution for all subproblems, but when these locally optimal solutions are combined it may NOT result into a globally optimal solution. Hence, a greedy algorithm CANNOT be used to solve all the dynamic programming problems.</i><p><b>9. Which of the following problems is NOT solved using dynamic programming?<br>
a) 0/1 knapsack problem<br>
b) Matrix chain multiplication problem<br>
c) Edit distance problem<br>
d) Fractional knapsack problem<br>
</b></p><i>Answer: c<br>
Explanation: Memoization is the technique in which previously calculated values are stored, so that, these values can be used to solve other subproblems.</i><p><b>10. Which of the following problems should be solved using dynamic programming?<br>
a) Mergesort<br>
b) Binary search<br>
c) Longest common subsequence<br>
d) Quicksort<br>
</b></p><i>Answer: b<br>
Explanation: The top-down approach uses the memoization technique which stores the previously calculated values. Due to this, the time complexity is decreased but the space complexity is increased.</i><p><b>2. Consider the recursive implementation to find the nth fibonacci number:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
    <span class="kw1">if</span> n <span class="sy0">&lt;=</span> <span class="nu0">1</span>
	<span class="kw1">return</span> n
    <span class="kw1">return</span> __________</pre></div></div></div></div></div></div><p><b>Which line would make the implementation complete?<br>
a) fibo(n) + fibo(n)<br>
b) fibo(n) + fibo(n – 1)<br>
c) fibo(n – 1) + fibo(n + 1)<br>
d) fibo(n – 1) + fibo(n – 2)<br>
</b></p><i>Answer: d<br>
Explanation: Each of the above mentioned methods can be used to find the nth fibonacci term.</i><p><b>3. What is the time complexity of the recursive implementation used to find the nth fibonacci term?<br>
a) O(1)<br>
b) O(n<sup>2</sup>)<br>
c) O(n!)<br>
d) Exponential<br>
</b></p><i>Answer: d<br>
Explanation: Consider the first five terms of the fibonacci sequence: 0,1,1,2,3. The 6th term can be found by adding the two previous terms, i.e. fibo(6) = fibo(5) + fibo(4) = 3 + 2 = 5. Therefore,the nth term of a fibonacci sequence would be given by:<br>
fibo(n) = fibo(n-1) + fibo(n-2).</i><p><b>4. Suppose we find the 8th term using the recursive implementation. The arguments passed to the function calls will be as follows:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">fibonacci(8)
fibonacci(7) + fibonacci(6)
fibonacci(6) + fibonacci(5) + fibonacci(5) + fibonacci(4)
fibonacci(5) + fibonacci(4) + fibonacci(4) + fibonacci(3) + fibonacci(4) 
+ fibonacci(3)	+ fibonacci(3) + fibonacci(2)
:
:
:</pre></div></div></div></div></div></div><p><b>Which property is shown by the above function calls?<br>
a) Memoization<br>
b) Optimal substructure<br>
c) Overlapping subproblems<br>
d) Greedy<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation is given by fibo(n) = fibo(n – 1) + fibo(n – 2). So, the time complexity is given by:<br>
T(n) = T(n – 1) + T(n – 2)<br>
Approximately,<br>
T(n) = 2 * T(n – 1)<br>
= 4 * T(n – 2)<br>
= 8 * T(n – 3)<br>
:<br>
:<br>
:<br>
= 2<sup>k</sup> * T(n – k)<br>
This recurrence will stop when n – k = 0<br>
i.e. n = k<br>
Therefore, T(n) = 2<sup>n</sup> * O(0) = 2<sup>n</sup><br>
Hence, it takes exponential time.<br>
It can also be proved by drawing the recursion tree and counting the number of leaves.</i><p><b>5. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">&lt;=</span><span class="nu0">1</span><span class="br0">)</span>
	 <span class="kw1">return</span> n<span class="sy0">;</span>
      <span class="kw1">return</span> fibo<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span> <span class="sy0">+</span> fibo<span class="br0">(</span>n<span class="sy0">-</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>   
      <span class="kw4">int</span> r <span class="sy0">=</span> fibo<span class="br0">(</span><span class="nu0">50000</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>r<span class="br0">)</span><span class="sy0">;</span> 
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1253556389<br>
b) 5635632456<br>
c) Garbage value<br>
d) Runtime error<br>
</b></p><i>Answer: c<br>
Explanation: From the function calls, we can see that fibonacci(4) is calculated twice and fibonacci(3) is calculated thrice. Thus, the same subproblem is solved many times and hence the function calls show the overlapping subproblems property.</i><p><b>6. What is the space complexity of the recursive implementation used to find the nth fibonacci term?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The value of n is 50000. The function is recursive and it’s time complexity is exponential. So, the function will be called almost 2<sup>50000</sup> times. Now, even though NO variables are stored by the function, the space required to store the addresses of these function calls will be enormous. Stack memory is utilized to store these addresses and only a particular amount of stack memory can be used by any program. So, after a certain function call, no more stack space will be available and it will lead to stack overflow causing runtime error.</i><p><b>7. Consider the following code to find the nth fibonacci term:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
    <span class="kw1">if</span> n <span class="sy0">==</span> <span class="nu0">0</span>
       <span class="kw1">return</span> <span class="nu0">0</span> 
    <span class="kw1">else</span>
       prevFib <span class="sy0">=</span> <span class="nu0">0</span>
       curFib <span class="sy0">=</span> <span class="nu0">1</span>
       <span class="kw1">for</span> i <span class="sy0">:</span> <span class="nu0">1</span> to n<span class="sy0">-</span><span class="nu0">1</span>
           nextFib <span class="sy0">=</span> prevFib <span class="sy0">+</span> curFib
	   __________
  	   __________
       <span class="kw1">return</span> curFib</pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The recursive implementation doesn’t store any values and calculates every value from scratch. So, the space complexity is O(1).</i><p><b>8. What is the time complexity of the following for loop method used to compute the nth fibonacci term?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
    <span class="kw1">if</span> n <span class="sy0">==</span> <span class="nu0">0</span>
       <span class="kw1">return</span> <span class="nu0">0</span> 
    <span class="kw1">else</span>
       prevFib <span class="sy0">=</span> <span class="nu0">0</span>
       curFib <span class="sy0">=</span> <span class="nu0">1</span>
       <span class="kw1">for</span> i <span class="sy0">:</span> <span class="nu0">1</span> to n<span class="sy0">-</span><span class="nu0">1</span>
           nextFib <span class="sy0">=</span> prevFib <span class="sy0">+</span> curFib
	   prevFib <span class="sy0">=</span> curFib
           curFib <span class="sy0">=</span> nextFib
       <span class="kw1">return</span> curFib</pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) Exponential<br>
</b></p><i>Answer: c<br>
Explanation: The lines, prevFib = curFib and curFib = nextFib, make the code complete.</i><p><b>9. What is the space complexity of the following for loop method used to compute the nth fibonacci term?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
    <span class="kw1">if</span> n <span class="sy0">==</span> <span class="nu0">0</span>
       <span class="kw1">return</span> <span class="nu0">0</span> 
    <span class="kw1">else</span>
       prevFib <span class="sy0">=</span> <span class="nu0">0</span>
       curFib <span class="sy0">=</span> <span class="nu0">1</span>
       <span class="kw1">for</span> i <span class="sy0">:</span> <span class="nu0">1</span> to n<span class="sy0">-</span><span class="nu0">1</span>
           nextFib <span class="sy0">=</span> prevFib <span class="sy0">+</span> curFib
	   prevFib <span class="sy0">=</span> curFib
           curFib <span class="sy0">=</span> nextFib
       <span class="kw1">return</span> curFib</pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) Exponential<br>
</b></p><i>Answer: b<br>
Explanation: To calculate the nth term, the for loop runs (n – 1) times and each time a for loop is run, it takes a constant time. Therefore, the time complexity is of the order of n.</i><p><b>10. What will be the output when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>n<span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span>
         <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">;</span>
      <span class="kw4">int</span> prevFib<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">,</span>curFib<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw4">int</span> nextFib <span class="sy0">=</span> prevFib <span class="sy0">+</span> curFib<span class="sy0">;</span>
	   prevFib <span class="sy0">=</span> curFib<span class="sy0">;</span>
           curFib <span class="sy0">=</span> nextFib<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> curFib<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> r <span class="sy0">=</span> fibo<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>  
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>r<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 34<br>
b) 55<br>
c) Compile error<br>
d) Runtime error<br>
</b></p><i>Answer: a<br>
Explanation: To calculate the nth term, we just store the previous term and the current term and then calculate the next term using these two terms. It takes a constant space to store these two terms and hence O(1) is the answer. </i><p><b>11. Consider the following code to find the nth fibonacci term using dynamic programming:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="nu0">1</span>. <span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="nu0">2</span>.   <span class="kw4">int</span> fibo_terms<span class="br0">[</span><span class="nu0">100000</span><span class="br0">]</span>  <span class="co1">//arr to store the fibonacci numbers</span>
<span class="nu0">3</span>.   <span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span>
<span class="nu0">4</span>.   <span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span>
<span class="nu0">5</span>.		
<span class="nu0">6</span>.   <span class="kw1">for</span> i<span class="sy0">:</span> <span class="nu0">2</span> to n
<span class="nu0">7</span>.	 <span class="me1">fibo_terms</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span>
<span class="nu0">8</span>.	
<span class="nu0">9</span>.   <span class="kw1">return</span> fibo_terms<span class="br0">[</span>n<span class="br0">]</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The output is the 10th fibonacci number, which is 55.</i><p><b>Which property is shown by line 7 of the above code?<br>
a) Optimal substructure<br>
b) Overlapping subproblems<br>
c) Both overlapping subproblems and optimal substructure<br>
d) Greedy substructure<br>
</b></p><i>Answer: a<br>
Explanation: We find the nth fibonacci term by finding previous fibonacci terms, i.e. by solving subproblems. Hence, line 7 shows the optimal substructure property.</i><p><b>12. Consider the following code to find the nth fibonacci term using dynamic programming:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="nu0">1</span>. <span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="nu0">2</span>.	<span class="kw4">int</span> fibo_terms<span class="br0">[</span><span class="nu0">100000</span><span class="br0">]</span>  <span class="co1">//arr to store the fibonacci numbers</span>
<span class="nu0">3</span>.	<span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span>
<span class="nu0">4</span>.	<span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span>
<span class="nu0">5</span>.		
<span class="nu0">6</span>.	<span class="kw1">for</span> i<span class="sy0">:</span> <span class="nu0">2</span> to n
<span class="nu0">7</span>.		<span class="me1">fibo_terms</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span>
<span class="nu0">8</span>.	
<span class="nu0">9</span>.	<span class="kw1">return</span> fibo_terms<span class="br0">[</span>n<span class="br0">]</span></pre></div></div></div></div></div></div><p><b>Which technique is used by line 7 of the above code?<br>
a) Greedy<br>
b) Recursion<br>
c) Memoization<br>
d) Overlapping subproblems<br>
</b></p><i>Answer: c<br>
Explanation: Line 7 stores the current value that is calculated, so that the value can be used later directly without calculating it from scratch. This is memoization.</i><p><b>13. What is the time complexity of the following dynamic programming implementation used to compute the nth fibonacci term?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="nu0">1</span>. <span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="nu0">2</span>.	<span class="kw4">int</span> fibo_terms<span class="br0">[</span><span class="nu0">100000</span><span class="br0">]</span>  <span class="co1">//arr to store the fibonacci numbers</span>
<span class="nu0">3</span>.	<span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span>
<span class="nu0">4</span>.	<span class="me1">fibo_terms</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span>
<span class="nu0">5</span>.		
<span class="nu0">6</span>.	<span class="kw1">for</span> i<span class="sy0">:</span> <span class="nu0">2</span> to n
<span class="nu0">7</span>.		<span class="me1">fibo_terms</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span>
<span class="nu0">8</span>.	
<span class="nu0">9</span>.	<span class="kw1">return</span> fibo_terms<span class="br0">[</span>n<span class="br0">]</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) Exponential<br>
</b></p><i>Answer: b<br>
Explanation: To calculate the nth term, the for loop runs (n – 1) times and each time a for loop is run, it takes a constant time. Therefore, the time complexity is of the order of n.</i><p><b>14. What is the space complexity of the following dynamic programming implementation used to compute the nth fibonacci term?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
        <span class="kw4">int</span> fibo_terms<span class="br0">[</span><span class="nu0">100000</span><span class="br0">]</span>  <span class="co1">//arr to store the fibonacci numbers</span>
        fibo_terms<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span>
	fibo_terms<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span>
&nbsp;
	<span class="kw1">for</span> i<span class="sy0">:</span> <span class="nu0">2</span> to n
		fibo_terms<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> fibo_terms<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span>
&nbsp;
	<span class="kw1">return</span> fibo_terms<span class="br0">[</span>n<span class="br0">]</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) Exponential<br>
</b></p><i>Answer: b<br>
Explanation: To calculate the nth term, we store all the terms from 0 to n – 1. So, it takes O(n) space.</i><p><b>15. What will be the output when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.</span>
<span class="kw4">int</span> fibo<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">;</span>
      <span class="kw4">int</span> fibo_terms<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy0">;</span>
      fibo_terms<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      fibo_terms<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">2</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
          fibo_terms<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> fibo_terms<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">+</span> fibo_terms<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> fibo_terms<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> r <span class="sy0">=</span> fibo<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>r<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The program prints the 8th fibonacci term, which is 21.</i><p><b>a) 34<br>
b) 55<br>
c) Compile error<br>
d) 21<br>
</b></p><i>undefined</i><p><b>1. You are given infinite coins of denominations v1, v2, v3,…..,vn and a sum S. The coin change problem is to find the minimum number of coins required to get the sum S. This problem can be solved using ____________<br>
a) Greedy algorithm<br>
b) Dynamic programming<br>
c) Divide and conquer<br>
d) Backtracking<br>
</b></p><i>Answer: b<br>
Explanation: The coin change problem has overlapping subproblems(same subproblems are solved multiple times) and optimal substructure(the solution to the problem can be found by finding optimal solutions for subproblems). So, dynamic programming can be used to solve the coin change problem.</i><p><b>2. Suppose you have coins of denominations 1, 3 and 4. You use a greedy algorithm, in which you choose the largest denomination coin which is not greater than the remaining sum. For which of the following sums, will the algorithm NOT produce an optimal answer?<br>
a) 20<br>
b) 12<br>
c) 6<br>
d) 5<br>
</b></p><i>Answer: c<br>
Explanation: Using the greedy algorithm, three coins {4,1,1} will be selected to make a sum of 6. But, the optimal answer is two coins {3,3}.</i><p><b>3. Suppose you have coins of denominations 1,3 and 4. You use a greedy algorithm, in which you choose the largest denomination coin which is not greater than the remaining sum. For which of the following sums, will the algorithm produce an optimal answer?<br>
a) 14<br>
b) 10<br>
c) 6<br>
d) 100<br>
</b></p><i>Answer: d<br>
Explanation: Using the greedy algorithm, three coins {4,1,1} will be selected to make a sum of 6. But, the optimal answer is two coins {3,3}. Similarly, four coins {4,4,1,1} will be selected to make a sum of 10. But, the optimal answer is three coins {4,3,3}. Also, five coins {4,4,4,1,1} will be selected to make a sum of 14. But, the optimal answer is four coins {4,4,3,3}. For a sum of 100, twenty-five coins {all 4’s} will be selected and the optimal answer is also twenty-five coins {all 4’s}.</i><p><b>4. Fill in the blank to complete the code.</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> coins<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span>lookup<span class="br0">[</span><span class="nu0">100000</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp<span class="sy0">,</span>num_coins <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span>sum<span class="sy0">=</span><span class="nu0">100</span><span class="sy0">;</span>
      lookup<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sum<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> min_coins <span class="sy0">=</span> i<span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>j <span class="sy0">&lt;</span> num_coins<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        tmp <span class="sy0">=</span> i <span class="sy0">-</span> coins<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
	        <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span>
	         <span class="kw1">continue</span><span class="sy0">;</span>
	        <span class="kw1">if</span><span class="br0">(</span>lookup<span class="br0">[</span>tmp<span class="br0">]</span> <span class="sy0">&lt;</span> min_coins<span class="br0">)</span>
	       ______________<span class="sy0">;</span>
	   <span class="br0">}</span>
	   lookup<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> min_coins <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>lookup<span class="br0">[</span>sum<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) lookup[tmp] = min_coins<br>
b) min_coins = lookup[tmp] <br>
c) break<br>
d) continue<br>
</b></p><i>Answer: b<br>
Explanation: min_coins = lookup[tmp] will complete the code.</i><p><b>5. You are given infinite coins of N denominations v1, v2, v3,…..,vn and a sum S. The coin change problem is to find the minimum number of coins required to get the sum S. What is the time complexity of a dynamic programming implementation used to solve the coin change problem?<br>
a) O(N)<br>
b) O(S)<br>
c) O(N<sup>2</sup>)<br>
d) O(S*N)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity is O(S*N).</i><p><b>6. Suppose you are given infinite coins of N denominations v1, v2, v3,…..,vn and a sum S. The coin change problem is to find the minimum number of coins required to get the sum S. What is the space complexity of a dynamic programming implementation used to solve the coin change problem?<br>
a) O(N)<br>
b) O(S)<br>
c) O(N<sup>2</sup>)<br>
d) O(S*N)<br>
</b></p><i>Answer: b<br>
Explanation: To get the optimal solution for a sum S, the optimal solution is found for each sum less than equal to S and each solution is stored. So, the space complexity is O(S).</i><p><b>7. You are given infinite coins of denominations 1, 3, 4. What is the total number of ways in which a sum of 7 can be achieved using these coins if the order of the coins is not important?<br>
a) 4<br>
b) 3<br>
c) 5<br>
d) 6<br>
</b></p><i>Answer: c<br>
Explanation: A sum of 7 can be achieved in the following ways:<br>
{1,1,1,1,1,1,1}, {1,1,1,1,3}, {1,3,3}, {1,1,1,4}, {3,4}.<br>
Therefore, the sum can be achieved in 5 ways.</i><p><b>8. You are given infinite coins of denominations 1, 3, 4. What is the minimum number of coins required to achieve a sum of 7?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: A sum of 7 can be achieved by using a minimum of two coins {3,4}.</i><p><b>9. You are given infinite coins of denominations 5, 7, 9. Which of the following sum CANNOT be achieved using these coins?<br>
a) 50<br>
b) 21<br>
c) 13<br>
d) 23<br>
</b></p><i>Answer: c<br>
Explanation: One way to achieve a sum of 50 is to use ten coins of 5. A sum of 21 can be achieved by using three coins of 7. One way to achieve a sum of 23 is to use two coins of 7 and one coin of 9. A sum of 13 cannot be achieved.</i><p><b>10. You are given infinite coins of denominations 3, 5, 7. Which of the following sum CANNOT be achieved using these coins?<br>
a) 15<br>
b) 16<br>
c) 17<br>
d) 4<br>
</b></p><i>Answer: d<br>
Explanation: Sums can be achieved as follows:<br>
15 = {5,5,5}<br>
16 = {3,3,5,5}<br>
17 = {3,7,7}<br>
we can’t achieve for sum=4 because our available denominations are 3,5,7 and sum of any two denominations is greater than 4.<br>
</i><p><b>11. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> coins<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span>lookup<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp<span class="sy0">,</span>num_coins <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span>sum<span class="sy0">=</span><span class="nu0">10</span><span class="sy0">;</span>
      lookup<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>sum<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	    <span class="kw4">int</span> min_coins <span class="sy0">=</span> i<span class="sy0">;</span>
	    <span class="kw1">for</span><span class="br0">(</span>j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>j<span class="sy0">&lt;</span>num_coins<span class="sy0">;</span>j<span class="sy0">++</span><span class="br0">)</span>
	    <span class="br0">{</span>
	         tmp<span class="sy0">=</span>i<span class="sy0">-</span>coins<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
	         <span class="kw1">if</span><span class="br0">(</span>tmp<span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">)</span>
	          <span class="kw1">continue</span><span class="sy0">;</span>
	         <span class="kw1">if</span><span class="br0">(</span>lookup<span class="br0">[</span>tmp<span class="br0">]</span> <span class="sy0">&lt;</span> min_coins<span class="br0">)</span>
		 min_coins<span class="sy0">=</span>lookup<span class="br0">[</span>tmp<span class="br0">]</span><span class="sy0">;</span>
	    <span class="br0">}</span>
	    lookup<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> min_coins <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>lookup<span class="br0">[</span>sum<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the minimum number of coins required to get a sum of 10, which is 3.</i><p><b>12. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> coins<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span>lookup<span class="br0">[</span><span class="nu0">100</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp<span class="sy0">,</span>num_coins <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span>sum<span class="sy0">=</span><span class="nu0">14</span><span class="sy0">;</span>
      lookup<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;=</span>sum<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> min_coins <span class="sy0">=</span> i<span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>j<span class="sy0">&lt;</span>num_coins<span class="sy0">;</span>j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span> 
	         tmp<span class="sy0">=</span>i<span class="sy0">-</span>coins<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
	         <span class="kw1">if</span><span class="br0">(</span>tmp<span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">)</span>
		  <span class="kw1">continue</span><span class="sy0">;</span>
	         <span class="kw1">if</span><span class="br0">(</span>lookup<span class="br0">[</span>tmp<span class="br0">]</span> <span class="sy0">&lt;</span> min_coins<span class="br0">)</span>
		 min_coins<span class="sy0">=</span>lookup<span class="br0">[</span>tmp<span class="br0">]</span><span class="sy0">;</span>
	   <span class="br0">}</span>
	   lookup<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> min_coins <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>lookup<span class="br0">[</span>sum<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the minimum number of coins required to get a sum of 14, which is 4.</i><p><b>1. Given a one-dimensional array of integers, you have to find a sub-array with maximum sum. This is the maximum sub-array sum problem. Which of these methods can be used to solve the problem?<br>
a) Dynamic programming<br>
b) Two for loops (naive method)<br>
c) Divide and conquer<br>
d) Dynamic programming, naïve method and Divide and conquer methods<br>
</b></p><i>Answer: d<br>
Explanation: Dynamic programming, naïve method and Divide and conquer methods can be used to solve the maximum sub array sum problem.</i><p><b>4. Consider the following naive method to find the maximum sub-array sum:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">1000</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span> len<span class="sy0">=</span><span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> cur_max<span class="sy0">,</span> tmp_max<span class="sy0">,</span> strt_idx<span class="sy0">,</span> sub_arr_idx<span class="sy0">;</span>
     cur_max <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>strt_idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> strt_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> strt_idx<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
	  tmp_max<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>sub_arr_idx <span class="sy0">=</span> strt_idx<span class="sy0">;</span> sub_arr_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> sub_arr_idx<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
	       tmp_max <span class="sy0">+=</span>arr<span class="br0">[</span>sub_arr_idx<span class="br0">]</span><span class="sy0">;</span>
	       <span class="kw1">if</span><span class="br0">(</span>tmp_max <span class="sy0">&gt;</span> cur_max<span class="br0">)</span>
		 _____________<span class="sy0">;</span>
	  <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cur_max<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which line should be inserted to complete the above code?<br>
a) tmp_max = cur_max<br>
b) break<br>
c) continue<br>
d) cur_max = tmp_max<br>
</b></p><i>Answer: b<br>
Explanation: The maximum sub-array sum is 5.</i><p><b>5. What is the time complexity of the following naive method used to find the maximum sub-array sum in an array containing n elements?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">1000</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span> len<span class="sy0">=</span><span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> cur_max<span class="sy0">,</span> tmp_max<span class="sy0">,</span> strt_idx<span class="sy0">,</span> sub_arr_idx<span class="sy0">;</span>
     cur_max <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>strt_idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> strt_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> strt_idx<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
	  tmp_max<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>sub_arr_idx <span class="sy0">=</span> strt_idx<span class="sy0">;</span> sub_arr_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> sub_arr_idx<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
	       tmp_max <span class="sy0">+=</span>arr<span class="br0">[</span>sub_arr_idx<span class="br0">]</span><span class="sy0">;</span>
	       <span class="kw1">if</span><span class="br0">(</span>tmp_max <span class="sy0">&gt;</span> cur_max<span class="br0">)</span>
		 _____________<span class="sy0">;</span>
	  <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cur_max<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n<sup>3</sup>)<br>
d) O(1)<br>
</b></p><i>Answer: d<br>
Explanation: All the elements are negative. So, the maximum sub-array sum will be equal to the largest element. The largest element is -1 and therefore, the maximum sub-array sum is -1.</i><p><b>6. What is the space complexity of the following naive method used to find the maximum sub-array sum in an array containing n elements?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">1000</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">,</span> len<span class="sy0">=</span><span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> cur_max<span class="sy0">,</span> tmp_max<span class="sy0">,</span> strt_idx<span class="sy0">,</span> sub_arr_idx<span class="sy0">;</span>
     cur_max <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>strt_idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> strt_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> strt_idx<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
	  tmp_max<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>sub_arr_idx <span class="sy0">=</span> strt_idx<span class="sy0">;</span> sub_arr_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> sub_arr_idx<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
	       tmp_max <span class="sy0">+=</span>arr<span class="br0">[</span>sub_arr_idx<span class="br0">]</span><span class="sy0">;</span>
	       <span class="kw1">if</span><span class="br0">(</span>tmp_max <span class="sy0">&gt;</span> cur_max<span class="br0">)</span>
		 _____________<span class="sy0">;</span>
	  <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cur_max<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n<sup>2</sup>)<br>
b) O(1)<br>
c) O(n<sup>3</sup>)<br>
d) O(n)<br>
</b></p><i>Answer: d<br>
Explanation: If the tmp_max element is greater than the cur_max element, we make cur_max equal to tmp_max, i.e. cur_max = tmp_max.</i><p><b>7. What is the output of the following naive method used to find the maximum sub-array sum?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">1000</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,-</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> cur_max<span class="sy0">,</span> tmp_max<span class="sy0">,</span> strt_idx<span class="sy0">,</span> sub_arr_idx<span class="sy0">;</span>
     cur_max <span class="sy0">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>strt_idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> strt_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> strt_idx<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
	   tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>sub_arr_idx <span class="sy0">=</span> strt_idx<span class="sy0">;</span> sub_arr_idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> sub_arr_idx<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        tmp_max <span class="sy0">+=</span> arr<span class="br0">[</span>sub_arr_idx<span class="br0">]</span><span class="sy0">;</span>
	        <span class="kw1">if</span><span class="br0">(</span>tmp_max <span class="sy0">&gt;</span> cur_max<span class="br0">)</span>
	        cur_max <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
	   <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>cur_max<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The naive method uses two for loops. The outer loop runs from 0 to n,<br>
i.e. i = 0 : n.<br>
The inner loop runs from i to n, i.e. j = i : n.<br>
Therefore, the inner loop runs:<br>
n times when the outer loop runs the first time.<br>
(n-1) times when the outer loop runs the second time.<br>
:<br>
:<br>
:<br>
2 times when the outer loop runs (n-1)th time.<br>
1 time when the outer loop runs nth time.<br>
Therefore, time complexity = n + (n-1) + (n-2) + …… + 2 + 1 = n * (n + 1) /2 = O(n<sup>2</sup>).</i><p><b>a) 6<br>
b) 9<br>
c) 7<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: The naive method uses only a constant space. So, the space complexity is O(1).</i><p><b>8. What is the time complexity of the divide and conquer algorithm used to find the maximum sub-array sum?<br>
a) O(n)<br>
b) O(logn)<br>
c) O(nlogn)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The naive method prints the maximum sub-array sum, which is 7.</i><p><b>9. What is the space complexity of the divide and conquer algorithm used to find the maximum sub-array sum?<br>
a) O(n)<br>
b) O(1)<br>
c) O(n!)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the divide and conquer algorithm used to find the maximum sub-array sum is O(nlogn).</i><p><b>1. Which line should be inserted in the blank to complete the following dynamic programming implementation of the maximum sub-array sum problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a,<span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a<span class="sy1">&gt;</span> b<span class="br0">)</span>
	 <span class="kw1">return</span> a<span class="sy4">;</span>
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> maximum_subarray_sum<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
      sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> _______________________<span class="sy4">;</span>
      <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
	     mx <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
	 <span class="kw1">return</span> mx<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">0</span>,<span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span>, len <span class="sy1">=</span> <span class="nu0">9</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> maximum_subarray_sum<span class="br0">(</span>arr, len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) max_num(sum[idx – 1] + arr[idx], arr[idx])<br>
b) sum[idx – 1] + arr[idx].<br>
c) min_num(sum[idx – 1] + arr[idx], arr[idx])<br>
d) arr[idx].<br>
</b></p><i>Answer: a<br>
Explanation: The array “sum” is used to store the maximum sub-array sum. The appropriate way to do this is by using:<br>
sum[idx] = max_num(sum[idx – 1] + arr[idx], arr[idx]).</i><p><b>2. What is the time complexity of the following dynamic programming algorithm used to find the maximum sub-array sum?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a,<span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a<span class="sy1">&gt;</span> b<span class="br0">)</span>
	 <span class="kw1">return</span> a<span class="sy4">;</span>
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> maximum_subarray_sum<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
      sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max_num<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
      <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
	     mx <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
	 <span class="kw1">return</span> mx<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">0</span>,<span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span>, len <span class="sy1">=</span> <span class="nu0">9</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> maximum_subarray_sum<span class="br0">(</span>arr, len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(logn)<br>
c) O(nlogn)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The time complexity of the above dynamic programming algorithm used to solve maximum sub-array sum is O(n).</i><p><b>3. What is the space complexity of the following dynamic programming algorithm used to find the maximum sub-array sum?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a,<span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a<span class="sy1">&gt;</span> b<span class="br0">)</span>
	 <span class="kw1">return</span> a<span class="sy4">;</span>
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> maximum_subarray_sum<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
      sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max_num<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
      <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	 <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
	     mx <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
	 <span class="kw1">return</span> mx<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">0</span>,<span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span>, len <span class="sy1">=</span> <span class="nu0">9</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> maximum_subarray_sum<span class="br0">(</span>arr, len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(n!)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The above dynamic programming algorithm uses space equal to the length of the array to store the sum values. So, the space complexity is O(n).</i><p><b>4. Consider the following code snippet. Which property is shown by line 4 of the below code snippet?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="nu0">1</span>. <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
<span class="nu0">2</span>. <span class="me1">sum</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">3</span>. <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
<span class="nu0">4</span>.	  <span class="me1">sum</span><span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">5</span>. <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">6</span>. <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
<span class="nu0">7</span>.	 <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
<span class="nu0">8</span>.		<span class="me1">mx</span> <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">9</span>. <span class="kw1">return</span> mx<span class="sy4">;</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The current sum (i.e. sum[idx]) uses the previous sum (i.e. sum[idx – 1]) to get an optimal value. So, line 4 shows the optimal substructure property.</i><p><b>a) Optimal substructure<br>
b) Overlapping subproblems<br>
c) Both overlapping subproblems and optimal substructure<br>
d) Greedy substructure<br>
</b></p><i>Answer: d<br>
Explanation: The array “sum” is used to store the previously calculated values, so that they aren’t recalculated. So, line 4 uses the memoization technique.</i><p><b>5. Consider the following code snippet:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="nu0">1</span>. <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
<span class="nu0">2</span>. <span class="me1">sum</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">3</span>. <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
<span class="nu0">4</span>.	  <span class="me1">sum</span><span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">5</span>. <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">6</span>. <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
<span class="nu0">7</span>.	 <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
<span class="nu0">8</span>.		<span class="me1">mx</span> <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
<span class="nu0">9</span>. <span class="kw1">return</span> mx<span class="sy4">;</span></pre></div></div></div></div></div></div><p><b>Which method is used by line 4 of the above code snippet?<br>
a) Divide and conquer<br>
b) Recursion<br>
c) Both memoization and divide and conquer<br>
d) Memoization<br>
</b></p><i>Answer: b<br>
Explanation: All the elements of the array are positive. So, the maximum sub-array sum is equal to the sum of all the elements, which is 36.</i><p><b>7. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a,<span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a<span class="sy1">&gt;</span> b<span class="br0">)</span>
	<span class="kw1">return</span> a<span class="sy4">;</span>
     <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> maximum_subarray_sum<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
     sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max_num<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
     <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	<span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
	   mx <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
     <span class="kw1">return</span> mx<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">20</span>, <span class="nu0">23</span>, <span class="nu0">10</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">10</span>, <span class="nu0">11</span>, <span class="sy2">-</span><span class="nu0">5</span><span class="br0">}</span>,len <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>
     <span class="kw4">int</span> ans <span class="sy1">=</span> maximum_subarray_sum<span class="br0">(</span>arr, len<span class="br0">)</span><span class="sy4">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 27<br>
b) 37<br>
c) 36<br>
d) 26<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the value of maximum sub-array sum, which is 37.</i><p><b>8. What is the value stored in sum[4] after the following program is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a,<span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a<span class="sy1">&gt;</span> b<span class="br0">)</span>
	  <span class="kw1">return</span> a<span class="sy4">;</span>
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> maximum_subarray_sum<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sum<span class="br0">[</span>len<span class="br0">]</span>, idx<span class="sy4">;</span>
      sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	   sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">=</span> max_num<span class="br0">(</span>sum<span class="br0">[</span>idx <span class="sy2">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span>, arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
      <span class="kw4">int</span> mx <span class="sy1">=</span> sum<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
	  <span class="kw1">if</span><span class="br0">(</span>sum<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy1">&gt;</span> mx<span class="br0">)</span>
	      mx <span class="sy1">=</span>sum<span class="br0">[</span>idx<span class="br0">]</span><span class="sy4">;</span>
      <span class="kw1">return</span> mx<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="nu0">14</span>, <span class="nu0">11</span>, <span class="sy2">-</span><span class="nu0">13</span>, <span class="nu0">10</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="nu0">11</span>, <span class="sy2">-</span><span class="nu0">6</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">5</span><span class="br0">}</span>,len <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> maximum_subarray_sum<span class="br0">(</span>arr, len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 28<br>
b) 25<br>
c) 22<br>
d) 12<br>
</b></p><i>Answer: c<br>
Explanation: After the program is executed the value stored in sum[4] is 22.<br>
Note: You are asked to find the value stored in sum[4] and NOT the output of the program.</i><p><b>1. Kadane’s algorithm is used to find ____________<br>
a) Longest increasing subsequence<br>
b) Longest palindrome subsequence<br>
c) Maximum sub-array sum<br>
d) Longest decreasing subsequence<br>
</b></p><i>Answer: c<br>
Explanation: Kadane’s algorithm is used to find the maximum sub-array sum for a given array.</i><p><b>2. Kadane’s algorithm uses which of the following techniques?<br>
a) Divide and conquer<br>
b) Dynamic programming<br>
c) Recursion<br>
d) Greedy algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Kadane’s algorithm uses dynamic programming.</i><p><b>3. For which of the following inputs would Kadane’s algorithm produce the INCORRECT output?<br>
a) {0,1,2,3}<br>
b) {-1,0,1}<br>
c) {-1,-2,-3,0}<br>
d) {-4,-3,-2,-1}<br>
</b></p><i>Answer: d<br>
Explanation: Kadane’s algorithm works if the input array contains at least one non-negative element. Every element in the array {-4,-3,-2,-1} is negative. Hence Kadane’s algorithm won’t work.</i><p><b>4. For which of the following inputs would Kadane’s algorithm produce a WRONG output?<br>
a) {1,0,-1}<br>
b) {-1,-2,-3}<br>
c) {1,2,3}<br>
d) {0,0,0}<br>
</b></p><i>Answer: b<br>
Explanation: Kadane’s algorithm doesn’t work for all negative numbers. So, the answer is {-1,-2,-3}.</i><p><b>5. Complete the following code for Kadane’s algorithm:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span> 
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy1">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy4">;</span> 
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>	
     <span class="kw4">int</span> ans, sum, idx<span class="sy4">;</span>
     ans <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
     sum <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         sum <span class="sy1">=</span> max_num<span class="br0">(</span><span class="nu0">0</span>,sum <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
         ans <span class="sy1">=</span> ___________<span class="sy4">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="nu0">4</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="nu0">1</span>, <span class="nu0">5</span>, <span class="sy2">-</span><span class="nu0">3</span><span class="br0">}</span>,len<span class="sy1">=</span><span class="nu0">7</span><span class="sy4">;</span>
     <span class="kw4">int</span> ans <span class="sy1">=</span> kadane_algo<span class="br0">(</span>arr,len<span class="br0">)</span><span class="sy4">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) max_num(sum, sum + arr[idx])<br>
b) sum<br>
c) sum + arr[idx] <br>
d) max_num(sum,ans)<br>
</b></p><i>Answer: d<br>
Explanation: The maximum of sum and ans, is stored in ans. So, the answer is max_num(sum, ans).	</i><p><b>6. What is the time complexity of Kadane’s algorithm?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(5)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of Kadane’s algorithm is O(n) because there is only one for loop which scans the entire array exactly once.</i><p><b>7. What is the space complexity of Kadane’s algorithm?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) None of the mentioned<br>
</b></p><i>Answer: a<br>
Explanation: Kadane’s algorithm uses a constant space. So, the space complexity is O(1).</i><p><b>8. What is the output of the following implementation of Kadane’s algorithm?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw1">if</span><span class="br0">(</span>a <span class="sy1">&gt;</span> b<span class="br0">)</span>
	<span class="kw1">return</span> a<span class="sy4">;</span>
       <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>	
<span class="br0">{</span>
       <span class="kw4">int</span> ans, sum, idx<span class="sy4">;</span>
       ans <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
       sum <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
       <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
       <span class="br0">{</span>
	     sum <span class="sy1">=</span> max_num<span class="br0">(</span><span class="nu0">0</span>,sum <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	     ans <span class="sy1">=</span> max_num<span class="br0">(</span>sum,ans<span class="br0">)</span><span class="sy4">;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> ans<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">1</span>, <span class="nu0">5</span>, <span class="sy2">-</span><span class="nu0">3</span><span class="br0">}</span>, len <span class="sy1">=</span> <span class="nu0">8</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> kadane_algo<span class="br0">(</span>arr,len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 6<br>
b) 7<br>
c) 8<br>
d) 9<br>
</b></p><i>Answer: d<br>
Explanation: Kadane’s algorithm produces the maximum sub-array sum, which is equal to 9.</i><p><b>9. What is the output of the following implementation of Kadane’s algorithm?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>  
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy1">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy4">;</span>
      <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>	
<span class="br0">{</span>
      <span class="kw4">int</span> ans, sum, idx<span class="sy4">;</span>
      ans <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
      sum <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	  sum <span class="sy1">=</span> max_num<span class="br0">(</span><span class="nu0">0</span>,sum <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
	  ans <span class="sy1">=</span> max_num<span class="br0">(</span>sum,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> ans<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="sy2">-</span><span class="nu0">3</span><span class="br0">}</span>,len <span class="sy1">=</span> <span class="nu0">8</span><span class="sy4">;</span>
      <span class="kw4">int</span> ans <span class="sy1">=</span> kadane_algo<span class="br0">(</span>arr,len<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) -1<br>
c) -2<br>
d) 0<br>
</b></p><i>Answer: d<br>
Explanation: Kadane’s algorithm produces a wrong output when all the elements are negative. The output produced is 0.</i><p><b>10. Consider the following implementation of Kadane’s algorithm:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1"><span class="nu0">1</span>. <span class="co2">#include&lt;stdio.h&gt;</span>
<span class="nu0">2</span>. <span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a, <span class="kw4">int</span> b<span class="br0">)</span>
<span class="nu0">3</span>. <span class="br0">{</span>
<span class="nu0">4</span>.     <span class="kw1">if</span><span class="br0">(</span>a <span class="sy1">&gt;</span> b<span class="br0">)</span>
<span class="nu0">5</span>.	 <span class="kw1">return</span> a<span class="sy4">;</span>
<span class="nu0">6</span>.     <span class="kw1">return</span> b<span class="sy4">;</span>
<span class="nu0">7</span>. <span class="br0">}</span>
<span class="nu0">8</span>. <span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy2">*</span>arr, <span class="kw4">int</span> len<span class="br0">)</span>	
<span class="nu0">9</span>. <span class="br0">{</span>
<span class="nu0">10</span>.      <span class="kw4">int</span> ans <span class="sy1">=</span> <span class="nu0">0</span>, sum <span class="sy1">=</span> <span class="nu0">0</span>, idx<span class="sy4">;</span>
<span class="nu0">11</span>.	 <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> idx <span class="sy1">&lt;</span> len<span class="sy4">;</span> idx<span class="sy2">++</span><span class="br0">)</span>
<span class="nu0">12</span>.	 <span class="br0">{</span>
<span class="nu0">13</span>.		<span class="me1">sum</span> <span class="sy1">=</span> max_num<span class="br0">(</span><span class="nu0">0</span>,sum <span class="sy2">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">14</span>.		<span class="me1">ans</span> <span class="sy1">=</span> max_num<span class="br0">(</span>sum,ans<span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">15</span>.	 <span class="br0">}</span>
<span class="nu0">16</span>.	 <span class="kw1">return</span> ans<span class="sy4">;</span>
<span class="nu0">17</span>. <span class="br0">}</span>
<span class="nu0">18</span>. <span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="nu0">19</span>. <span class="br0">{</span>
<span class="nu0">20</span>. 	  <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="sy2">-</span><span class="nu0">2</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="sy2">-</span><span class="nu0">5</span>, <span class="sy2">-</span><span class="nu0">3</span><span class="br0">}</span>,len <span class="sy1">=</span> <span class="nu0">8</span><span class="sy4">;</span>
<span class="nu0">21</span>.       <span class="kw4">int</span> ans <span class="sy1">=</span> kadane_algo<span class="br0">(</span>arr,len<span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">22</span>.	  <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span>,ans<span class="br0">)</span><span class="sy4">;</span>
<span class="nu0">23</span>.	  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="nu0">24</span>. <span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: Both change 1 and change 2 should be made to Kadane’s algorithm so that it produces the right output even when all the array elements are negative.</i><p><b>What changes should be made to the Kadane’s algorithm so that it produces the right output even when all array elements are negative?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="cpp"><pre class="de1">	Change <span class="nu0">1</span> <span class="sy1">=</span> Line <span class="nu0">10</span><span class="sy4">:</span> <span class="kw4">int</span> sum <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>, ans <span class="sy1">=</span> arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>
	Change <span class="nu0">2</span> <span class="sy1">=</span> Line <span class="nu0">13</span><span class="sy4">:</span> sum <span class="sy1">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>idx<span class="br0">]</span>,sum<span class="sy2">+</span>arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span></pre></div></div></div></div></div></div><p><b>a) Only Change 1 is sufficient<br>
b) Only Change 2 is sufficient<br>
c) Both Change 1 and Change 2 are necessary<br>
d) No change is required<br>
</b></p><i>undefined</i><p><b>1. The longest increasing subsequence problem is a problem to find the length of a subsequence from a sequence of array elements such that the subsequence is sorted in increasing order and it’s length is maximum. This problem can be solved using __________<br>
a) Recursion<br>
b) Dynamic programming<br>
c) Brute force<br>
d) Recursion, Dynamic programming, Brute force<br>
</b></p><i>Answer: d<br>
Explanation: The longest increasing subsequence problem can be solved using all of the mentioned methods.</i><p><b>6. In the brute force implementation to find the longest increasing subsequence, all the subsequences of a given sequence are found. All the increasing subsequences are then selected and the length of the longest subsequence is found. What is the time complexity of this brute force implementation?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n!)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The longest increasing subsequence is {-10, 9, 10, 13, 14}.</i><p><b>7. Complete the following dynamic programming implementation of the longest increasing subsequence problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> longest_inc_sub<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> tmp_max<span class="sy0">;</span>
      <span class="kw4">int</span> LIS<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>  <span class="co1">// array to store the lengths of the longest increasing subsequence </span>
      LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span> 
           tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
	        <span class="br0">{</span>
		    <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		     ___________<span class="sy0">;</span>  
	        <span class="br0">}</span>
           <span class="br0">}</span>
	   LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max <span class="sy0">=</span> LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	<span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max<span class="br0">)</span>
	   max <span class="sy0">=</span> LIS<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">22</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">33</span><span class="sy0">,</span><span class="nu0">21</span><span class="sy0">,</span><span class="nu0">50</span><span class="sy0">,</span><span class="nu0">41</span><span class="sy0">,</span><span class="nu0">60</span><span class="sy0">,</span><span class="nu0">80</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> longest_inc_sub<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) tmp_max = LIS[j] <br>
b) LIS[i] = LIS[j] <br>
c) LIS[j] = tmp_max<br>
d) tmp_max = LIS[i] <br>
</b></p><i>Answer: d<br>
Explanation: The longest increasing subsequence is {-10, 24, 35, 55, 76, 84}  and it’s length is 6.</i><p><b>8. What is the time complexity of the following dynamic programming implementation used to find the length of the longest increasing subsequence?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> longest_inc_sub<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> tmp_max<span class="sy0">;</span>
      <span class="kw4">int</span> LIS<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>  <span class="co1">// array to store the lengths of the longest increasing subsequence </span>
      LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span> 
           tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
	        <span class="br0">{</span>
		    <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		     tmp_max <span class="sy0">=</span> LIS<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>  
	        <span class="br0">}</span>
           <span class="br0">}</span>
	   LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max <span class="sy0">=</span> LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	<span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max<span class="br0">)</span>
	   max <span class="sy0">=</span> LIS<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">22</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">33</span><span class="sy0">,</span><span class="nu0">21</span><span class="sy0">,</span><span class="nu0">50</span><span class="sy0">,</span><span class="nu0">41</span><span class="sy0">,</span><span class="nu0">60</span><span class="sy0">,</span><span class="nu0">80</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> longest_inc_sub<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(nlogn)<br>
</b></p><i>Answer: b<br>
Explanation: For a given sequence, it is possible that there is more than one subsequence with the longest length.<br>
Consider, the following sequence: {10,11,12,1,2,3}:<br>
There are two longest increasing subsequences: {1,2,3} and {10,11,12}.</i><p><b>9. What is the space complexity of the following dynamic programming implementation used to find the length of the longest increasing subsequence?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> longest_inc_sub<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> tmp_max<span class="sy0">;</span>
      <span class="kw4">int</span> LIS<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>  <span class="co1">// array to store the lengths of the longest increasing subsequence </span>
      LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span> 
           tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
	        <span class="br0">{</span>
		    <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		     tmp_max <span class="sy0">=</span> LIS<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>  
	        <span class="br0">}</span>
           <span class="br0">}</span>
	   LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max <span class="sy0">=</span> LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	<span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max<span class="br0">)</span>
	   max <span class="sy0">=</span> LIS<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">22</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">33</span><span class="sy0">,</span><span class="nu0">21</span><span class="sy0">,</span><span class="nu0">50</span><span class="sy0">,</span><span class="nu0">41</span><span class="sy0">,</span><span class="nu0">60</span><span class="sy0">,</span><span class="nu0">80</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> longest_inc_sub<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(nlogn)<br>
</b></p><i>Answer: d<br>
Explanation: Each array element individually forms a longest increasing subsequence and so, the length of the longest increasing subsequence is 1. So, the number of increasing subsequences with the longest length is 6.</i><p><b>10. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> longest_inc_sub<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> tmp_max<span class="sy0">;</span>
      <span class="kw4">int</span> LIS<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>  <span class="co1">// array to store the lengths of the longest increasing subsequence </span>
      LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	    tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	    <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	    <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
	        <span class="br0">{</span>
		     <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		       tmp_max <span class="sy0">=</span> LIS<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
	        <span class="br0">}</span>
            <span class="br0">}</span>
	    LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw4">int</span> max <span class="sy0">=</span> LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	  <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max<span class="br0">)</span>
	      max <span class="sy0">=</span> LIS<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">22</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">33</span><span class="sy0">,</span><span class="nu0">21</span><span class="sy0">,</span><span class="nu0">50</span><span class="sy0">,</span><span class="nu0">41</span><span class="sy0">,</span><span class="nu0">60</span><span class="sy0">,</span><span class="nu0">80</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> longest_inc_sub<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The time required to find all the subsequences of a given sequence is 2<sup>n</sup>, where ‘n’ is the number of elements in the sequence. So, the time complexity is O(2<sup>n</sup>).</i><p><b>a) 3<br>
b) 4<br>
c) 5<br>
d) 6<br>
</b></p><i>Answer: a<br>
Explanation: tmp_max is used to store the maximum length of an increasing subsequence for any ‘j’ such that: arr[j] &lt; arr[i] and 0 &lt; j &lt; i.<br>
So, tmp_max = LIS[j] completes the code.</i><p><b>11. What is the value stored in LIS[5] after the following program is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> longest_inc_sub<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">,</span> tmp_max<span class="sy0">;</span>
      <span class="kw4">int</span> LIS<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>  <span class="co1">// array to store the lengths of the longest increasing subsequence </span>
      LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   tmp_max <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span>
	        <span class="br0">{</span>
		     <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		     tmp_max <span class="sy0">=</span> LIS<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
	        <span class="br0">}</span>
	   <span class="br0">}</span>
	   LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
       <span class="br0">}</span>
      <span class="kw4">int</span> max <span class="sy0">=</span> LIS<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	 <span class="kw1">if</span><span class="br0">(</span>LIS<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;</span> max<span class="br0">)</span>
	     max <span class="sy0">=</span> LIS<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">return</span> max<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">22</span><span class="sy0">,</span><span class="nu0">9</span><span class="sy0">,</span><span class="nu0">33</span><span class="sy0">,</span><span class="nu0">21</span><span class="sy0">,</span><span class="nu0">50</span><span class="sy0">,</span><span class="nu0">41</span><span class="sy0">,</span><span class="nu0">60</span><span class="sy0">,</span><span class="nu0">80</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> longest_inc_sub<span class="br0">(</span>arr<span class="sy0">,</span> len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation used to find the length of the longest increasing subsequence is O(n<sup>2</sup>).</i><p><b>1. Given a rod of length n and the selling prices of all pieces smaller than equal to n, find the most beneficial way of cutting the rod into smaller pieces. This problem is called the rod cutting problem. Which of these methods can be used to solve the rod cutting problem?<br>
a) Brute force<br>
b) Dynamic programming<br>
c) Recursion<br>
d) Brute force, Dynamic programming and Recursion<br>
</b></p><i>Answer: d<br>
Explanation: Brute force, Dynamic programming and Recursion can be used to solve the rod cutting problem.</i><p><b>What is the maximum value that you can get after cutting the rod and selling the pieces?<br>
a) 10<br>
b) 11<br>
c) 12<br>
d) 13<br>
</b></p><i>Answer: c<br>
Explanation: The pieces {1,2 2} give the maximum value of 12.</i><p><b>3. Consider the brute force implementation of the rod cutting problem in which all the possible cuts are found and the maximum value is calculated. What is the time complexity of this brute force implementation?<br>
a) O(n<sup>2</sup>)<br>
b) O(n<sup>3</sup>)<br>
c) O(nlogn)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The brute force implementation finds all the possible cuts. This takes O(2<sup>n</sup>) time.</i><p><b>Which of these pieces give the maximum price?<br>
a) {1,2,7}<br>
b) {10}<br>
c) {2,2,6}<br>
d) {1,4,5}<br>
</b></p><i>Answer: c<br>
Explanation: The pieces {2,2,6} give the maximum value of 27.</i><p><b>5. Consider the following recursive implementation of the rod cutting problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
            <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_price <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// INT_MIN is the min value an integer can take</span>
      <span class="kw4">int</span> i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>len <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="br0">)</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
	 max_price <span class="sy0">=</span> max_of_two<span class="br0">(</span>_____________<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// subtract 1 because index starts from 0</span>
      <span class="kw1">return</span> max_price<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Complete the above code.<br>
a) max_price, prices[i] + rod_cut(prices,len – i – 1)<br>
b) max_price, prices[i – 1].<br>
c) max_price, rod_cut(prices, len – i – 1)<br>
d) max_price, prices[i – 1] + rod_cut(prices,len – i – 1)<br>
</b></p><i>Answer: a<br>
Explanation: max_price, prices[i] + rod_cut(prices,len – i – 1) completes the above code.</i><p><b>6. What is the time complexity of the following recursive implementation?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
            <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_price <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// INT_MIN is the min value an integer can take</span>
      <span class="kw4">int</span> i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>len <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="br0">)</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         <span class="co1">// subtract 1 because index starts from 0</span>
	 max_price <span class="sy0">=</span> max_of_two<span class="br0">(</span>max_price<span class="sy0">,</span> prices<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span>len <span class="sy0">-</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
      <span class="kw1">return</span> max_price<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above recursive implementation is O(2<sup>n</sup>).</i><p><b>7. What is the space complexity of the following recursive implementation?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
            <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_price <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// INT_MIN is the min value an integer can take</span>
      <span class="kw4">int</span> i<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>len <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="br0">)</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         <span class="co1">// subtract 1 because index starts from 0</span>
	 max_price <span class="sy0">=</span> max_of_two<span class="br0">(</span>max_price<span class="sy0">,</span> prices<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span>len <span class="sy0">-</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
      <span class="kw1">return</span> max_price<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(logn)<br>
c) O(nlogn)<br>
d) O(n!)<br>
</b></p><i>Answer: a<br>
Explanation: The space complexity of the above recursive implementation is O(1) because it uses a constant space.</i><p><b>8. What will  be the value stored in max_value when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_of_two<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
       <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> max_price <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// INT_MIN is the min value an integer can take</span>
       <span class="kw4">int</span> i<span class="sy0">;</span>
       <span class="kw1">if</span><span class="br0">(</span>len <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="br0">)</span>
          <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
       <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          <span class="co1">// subtract 1 because index starts from 0</span>
          max_price <span class="sy0">=</span> max_of_two<span class="br0">(</span>prices<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span>len <span class="sy0">-</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">,</span> max_price<span class="br0">)</span><span class="sy0">;</span> 
       <span class="kw1">return</span> max_price<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
       <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The value stored in max_value after the code is executed is equal to 7.</i><p><b>a) 5<br>
b) 6<br>
c) 7<br>
d) 8<br>
</b></p><i>Answer: b<br>
Explanation: Consider a rod of length 3. The prices are {2,3,6} for lengths {1,2,3} respectively. The pieces {1,1,1} and {3} both give the maximum value of 6.</i><p><b>10.Consider the following dynamic programming implementation of the rod cutting problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_val<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp_price<span class="sy0">,</span>tmp_idx<span class="sy0">;</span>
      max_val<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> tmp_max <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// minimum value an integer can hold</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	         tmp_idx <span class="sy0">=</span> i <span class="sy0">-</span> j<span class="sy0">;</span>
                 <span class="co1">//subtract 1 because index of prices starts from 0</span>
	         tmp_price <span class="sy0">=</span> _____________<span class="sy0">;</span> 
	         <span class="kw1">if</span><span class="br0">(</span>tmp_price <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
	           tmp_max <span class="sy0">=</span> tmp_price<span class="sy0">;</span>
	    <span class="br0">}</span>
	    max_val<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> max_val<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
       <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which line will complete the ABOVE code?<br>
a) prices[j-1] + max_val[tmp_idx] <br>
b) prices[j] + max_val[tmp_idx] <br>
c) prices[j-1] + max_val[tmp_idx – 1] <br>
d) prices[j] + max_val[tmp_idx – 1] <br>
</b></p><i>Answer: a<br>
Explanation: prices[j-1] + max_val[tmp_idx] completes the code.</i><p><b>11. What is the time complexity of the following dynamic programming implementation of the rod cutting problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_val<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp_price<span class="sy0">,</span>tmp_idx<span class="sy0">;</span>
      max_val<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> tmp_max <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// minimum value an integer can hold</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	         tmp_idx <span class="sy0">=</span> i <span class="sy0">-</span> j<span class="sy0">;</span>
                 <span class="co1">//subtract 1 because index of prices starts from 0</span>
	         tmp_price <span class="sy0">=</span> prices<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> max_val<span class="br0">[</span>tmp_idx<span class="br0">]</span><span class="sy0">;</span> 
	         <span class="kw1">if</span><span class="br0">(</span>tmp_price <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
	           tmp_max <span class="sy0">=</span> tmp_price<span class="sy0">;</span>
	    <span class="br0">}</span>
	    max_val<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> max_val<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
       <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation of the rod cutting problem is O(n<sup>2</sup>).</i><p><b>12. What is the space complexity of the following dynamic programming implementation of the rod cutting problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_val<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp_price<span class="sy0">,</span>tmp_idx<span class="sy0">;</span>
      max_val<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> tmp_max <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// minimum value an integer can hold</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	         tmp_idx <span class="sy0">=</span> i <span class="sy0">-</span> j<span class="sy0">;</span>
                 <span class="co1">//subtract 1 because index of prices starts from 0</span>
	         tmp_price <span class="sy0">=</span> prices<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> max_val<span class="br0">[</span>tmp_idx<span class="br0">]</span><span class="sy0">;</span> 
	         <span class="kw1">if</span><span class="br0">(</span>tmp_price <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
	           tmp_max <span class="sy0">=</span> tmp_price<span class="sy0">;</span>
	    <span class="br0">}</span>
	    max_val<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
       <span class="br0">}</span>
       <span class="kw1">return</span> max_val<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
       <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The space complexity of the above dynamic programming implementation of the rod cutting problem is O(n) because it uses a space equal to the length of the rod.</i><p><b>13. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_val<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp_price<span class="sy0">,</span>tmp_idx<span class="sy0">;</span>
      max_val<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> tmp_max <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// minimum value an integer can hold</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	        tmp_idx <span class="sy0">=</span> i <span class="sy0">-</span> j<span class="sy0">;</span>
                <span class="co1">//subtract 1 because index of prices starts from 0</span>
	        tmp_price <span class="sy0">=</span> prices<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> max_val<span class="br0">[</span>tmp_idx<span class="br0">]</span><span class="sy0">;</span>
	        <span class="kw1">if</span><span class="br0">(</span>tmp_price <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		  tmp_max <span class="sy0">=</span> tmp_price<span class="sy0">;</span>
	   <span class="br0">}</span>
	   max_val<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> max_val<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The program prints the maximum price that can be achieved by cutting the rod into pieces, which is equal to 27.<br>
</i><p><b>a) 9<br>
b) 10<br>
c) 11<br>
d) 12<br>
</b></p><i>Answer: a<br>
Explanation: The value stored in max_val[5] after the program is executed is 12.</i><p><b>14. What is the value stored in max_val[5] after the following program is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> rod_cut<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>prices<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> max_val<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>tmp_price<span class="sy0">,</span>tmp_idx<span class="sy0">;</span> 
      max_val<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> tmp_max <span class="sy0">=</span> INT_MIN<span class="sy0">;</span> <span class="co1">// minimum value an integer can hold</span>
	   <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> i<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	   <span class="br0">{</span>
	         tmp_idx <span class="sy0">=</span> i <span class="sy0">-</span> j<span class="sy0">;</span>
                <span class="co1">//subtract 1 because index of prices starts from 0</span>
	         tmp_price <span class="sy0">=</span> prices<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> max_val<span class="br0">[</span>tmp_idx<span class="br0">]</span><span class="sy0">;</span>
	         <span class="kw1">if</span><span class="br0">(</span>tmp_price <span class="sy0">&gt;</span> tmp_max<span class="br0">)</span>
		    tmp_max <span class="sy0">=</span> tmp_price<span class="sy0">;</span>
	   <span class="br0">}</span>
	   max_val<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> tmp_max<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> max_val<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> prices<span class="br0">[</span><span class="br0">]</span><span class="sy0">=</span><span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">18</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">22</span><span class="br0">}</span><span class="sy0">,</span>len_of_rod <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> rod_cut<span class="br0">(</span>prices<span class="sy0">,</span> len_of_rod<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 12<br>
b) 27<br>
c) 10<br>
d) 17<br>
</b></p><i>undefined</i><p><b>1. You are given an array of elements where each array element represents the MAXIMUM number of jumps that can be made in the forward direction from that element. You have to find the minimum number of jumps that are required to reach the end of the array. Which of these methods can be used to solve the problem?<br>
a) Dynamic Programming<br>
b) Greedy Algorithm<br>
c) Recursion<br>
d) Recursion and Dynamic Programming<br>
</b></p><i>Answer: d<br>
Explanation: Both recursion and dynamic programming can be used to solve minimum number of jumps problem.</i><p><b>3. Consider the following recursive implementation:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jumps<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> strt<span class="sy0">,</span> <span class="kw4">int</span> end<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> idx<span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>strt <span class="sy0">==</span> end<span class="br0">)</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>strt<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="co1">// jump cannot be made</span>
	<span class="kw1">return</span> INT_MAX<span class="sy0">;</span>
     <span class="kw4">int</span> min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> idx <span class="sy0">&lt;=</span> arr<span class="br0">[</span>strt<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> strt <span class="sy0">+</span> idx <span class="sy0">&lt;=</span> end<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
	  <span class="kw4">int</span> jumps <span class="sy0">=</span> min_jumps<span class="br0">(</span>____<span class="sy0">,</span>____<span class="sy0">,</span>____<span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	  <span class="kw1">if</span><span class="br0">(</span>jumps <span class="sy0">&lt;</span> min<span class="br0">)</span>
	      min  <span class="sy0">=</span> jumps<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> min<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> min_jumps<span class="br0">(</span>arr<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of these arguments should be passed by the min_jumps function represented by the blanks?<br>
a) arr, strt + idx, end<br>
b) arr + idx, strt, end<br>
c) arr, strt, end<br>
d) arr, strt, end + idx<br>
</b></p><i>Answer: c<br>
Explanation: The jumps made will be:{1 -&gt; 2 -&gt; 4 -&gt; 9}. So, the number of jumps is three.</i><p><b>5. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jumps<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> strt<span class="sy0">,</span> <span class="kw4">int</span> end<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> idx<span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>strt <span class="sy0">==</span> end<span class="br0">)</span>
 	 <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>strt<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="co1">// jump cannot be made</span>
	 <span class="kw1">return</span> INT_MAX<span class="sy0">;</span>
      <span class="kw4">int</span> min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> idx <span class="sy0">&lt;=</span> arr<span class="br0">[</span>strt<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> strt <span class="sy0">+</span> idx <span class="sy0">&lt;=</span> end<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
	   <span class="kw4">int</span> jumps <span class="sy0">=</span> min_jumps<span class="br0">(</span>arr<span class="sy0">,</span> strt <span class="sy0">+</span> idx<span class="sy0">,</span> end<span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	   <span class="kw1">if</span><span class="br0">(</span>jumps <span class="sy0">&lt;</span> min<span class="br0">)</span>
	     min  <span class="sy0">=</span> jumps<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> min<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jumps<span class="br0">(</span>arr<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>Answer: a<br>
Explanation: arr, strt + idx, end should be passed as arguments.</i><p><b>7. Consider the following dynamic programming implementation of the minimum jumps problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jump<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> j<span class="sy0">,</span> idx<span class="sy0">,</span> jumps<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
     jumps<span class="br0">[</span>len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> len <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> idx <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> idx<span class="sy0">--</span><span class="br0">)</span>
     <span class="br0">{</span>
	  <span class="kw4">int</span> tmp_min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> idx <span class="sy0">+</span> j <span class="sy0">&lt;</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
		 <span class="kw1">if</span><span class="br0">(</span>jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> tmp_min<span class="br0">)</span>
		     tmp_min <span class="sy0">=</span> jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	  <span class="br0">}</span>
	  jumps<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> tmp_min<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> jumps<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jump<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following “for” loops can be used instead of the inner for loop so that the output doesn’t change?<br>
a) for(j = 1; j &lt; arr[idx] + len; j++)<br>
b) for(j = 0; j &lt; arr[idx] – len; j++)<br>
c) for(j = idx + 1; j &lt; len &amp;&amp; j &lt;= arr[idx] + idx; j++)<br>
d) No change is required<br>
</b></p><i>Answer: a<br>
Explanation: Consider the array {1,2,3,4,5}. It is possible to reach the end in the following ways: {1 -&gt; 2 -&gt; 3 -&gt; 5} or {1 -&gt; 2 -&gt; 4 -&gt; 5}.<br>
In both the cases the number of jumps is 3, which is minimum. Hence, it is possible to reach the end of the array in multiple ways using minimum number of jumps.</i><p><b>8. What is the time complexity of the following dynamic programming implementation used to find the minimum number of jumps?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jump<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> j<span class="sy0">,</span> idx<span class="sy0">,</span> jumps<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
     jumps<span class="br0">[</span>len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> len <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> idx <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> idx<span class="sy0">--</span><span class="br0">)</span>
     <span class="br0">{</span>
	  <span class="kw4">int</span> tmp_min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> idx <span class="sy0">+</span> j <span class="sy0">&lt;</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
		 <span class="kw1">if</span><span class="br0">(</span>jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> tmp_min<span class="br0">)</span>
		     tmp_min <span class="sy0">=</span> jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	  <span class="br0">}</span>
	  jumps<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> tmp_min<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> jumps<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jump<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The program prints the minimum number of jumps required to reach the end of the array. One way reach the end using minimum number of jumps is<br>
{1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 9}. So, the number of jumps is 4.</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) None of the mentioned<br>
</b></p><i>Answer: b<br>
Explanation: Consider the array {1,0,2,3,4}.<br>
In this case, only one element is 0 but it is not possible to reach the end of the array.</i><p><b>9. What is the space complexity of the following dynamic programming implementation used to find the minimum number of jumps?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jump<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> j<span class="sy0">,</span> idx<span class="sy0">,</span> jumps<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
     jumps<span class="br0">[</span>len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> len <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> idx <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> idx<span class="sy0">--</span><span class="br0">)</span>
     <span class="br0">{</span>
	  <span class="kw4">int</span> tmp_min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> idx <span class="sy0">+</span> j <span class="sy0">&lt;</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
		 <span class="kw1">if</span><span class="br0">(</span>jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> tmp_min<span class="br0">)</span>
		     tmp_min <span class="sy0">=</span> jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	  <span class="br0">}</span>
	  jumps<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> tmp_min<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> jumps<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jump<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(5)<br>
</b></p><i>Answer: d<br>
Explanation: None of the above mentioned “for” loops can be used instead of the inner for loop. Note, for(j = idx + 1; j &lt; len &amp;&amp; j &lt;= arr[idx] + idx; j++) covers the same range as the inner for loop but it produces the wrong output because the indexing inside the loops changes as “j” takes different values in the two “for” loops.</i><p><b>10. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jump<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> j<span class="sy0">,</span> idx<span class="sy0">,</span> jumps<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
      jumps<span class="br0">[</span>len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> len <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> idx <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> idx<span class="sy0">--</span><span class="br0">)</span>
      <span class="br0">{</span>	
	     <span class="kw4">int</span> tmp_min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
	     <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> idx <span class="sy0">+</span> j <span class="sy0">&lt;</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	     <span class="br0">{</span>
		   <span class="kw1">if</span><span class="br0">(</span>jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> tmp_min<span class="br0">)</span>
		      tmp_min <span class="sy0">=</span> jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	     <span class="br0">}</span>
	     jumps<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> tmp_min<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> jumps<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jump<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 7<br>
b) 8<br>
c) 9<br>
d) 10<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation is O(n<sup>2</sup>).</i><p><b>11. What is the output of the following program?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> min_jump<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> j<span class="sy0">,</span> idx<span class="sy0">,</span> jumps<span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
      jumps<span class="br0">[</span>len <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> len <span class="sy0">-</span> <span class="nu0">2</span><span class="sy0">;</span> idx <span class="sy0">&gt;=</span> <span class="nu0">0</span><span class="sy0">;</span> idx<span class="sy0">--</span><span class="br0">)</span>
      <span class="br0">{</span>	
	  <span class="kw4">int</span> tmp_min <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
	  <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> arr<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">&amp;&amp;</span> idx <span class="sy0">+</span> j <span class="sy0">&lt;</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
	  <span class="br0">{</span>
	        <span class="kw1">if</span><span class="br0">(</span>jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> tmp_min<span class="br0">)</span>
		  tmp_min <span class="sy0">=</span> jumps<span class="br0">[</span>idx <span class="sy0">+</span> j<span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
	  <span class="br0">}</span>
	  jumps<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> tmp_min<span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> jumps<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">,</span>len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_jump<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 6<br>
c) 2<br>
d) 7<br>
</b></p><i>Answer: b<br>
Explanation: The space complexity of the above dynamic programming implementation is O(n).</i><p><b>1. The Knapsack problem is an example of ____________<br>
a) Greedy algorithm<br>
b) 2D dynamic programming<br>
c) 1D dynamic programming<br>
d) Divide and conquer<br>
</b></p><i>Answer: b<br>
Explanation: Knapsack problem is an example of 2D dynamic programming.</i><p><b>2. Which of the following methods can be used to solve the Knapsack problem?<br>
a) Brute force algorithm<br>
b) Recursion<br>
c) Dynamic programming<br>
d) Brute force, Recursion and Dynamic Programming<br>
</b></p><i>Answer: d<br>
Explanation: Brute force, Recursion and Dynamic Programming can be used to solve the knapsack problem.</i><p><b>3. You are given a knapsack that can carry a maximum weight of 60. There are 4 items with weights {20, 30, 40, 70} and values {70, 80, 90, 200}. What is the maximum value of the items you can carry using the knapsack?<br>
a) 160<br>
b) 200<br>
c) 170<br>
d) 90<br>
</b></p><i>Answer: a<br>
Explanation: The maximum value you can get is 160. This can be achieved by choosing the items 1 and 3 that have a total weight of 60.</i><p><b>4. Which of the following problems is equivalent to the 0-1 Knapsack problem?<br>
a) You are given a bag that can carry a maximum weight of W. You are given N items which have a weight of {w1, w2, w3,…., wn} and a value of {v1, v2, v3,…., vn}. You can break the items into smaller pieces. Choose the items in such a way that you get the maximum value<br>
b) You are studying for an exam and you have to study N questions. The questions take {t1, t2, t3,…., tn} time(in hours) and carry {m1, m2, m3,…., mn} marks. You can study for a maximum of T hours. You can either study a question or leave it. Choose the questions in such a way that your score is maximized<br>
c) You are given infinite coins of denominations {v1, v2, v3,….., vn} and a sum S. You have to find the minimum number of coins required to get the sum S<br>
d) You are given a suitcase that can carry a maximum weight of 15kg. You are given 4 items which have a weight of {10, 20, 15,40} and a value of {1, 2, 3,4}. You can break the items into smaller pieces. Choose the items in such a way that you get the maximum value<br>
</b></p><i>Answer: b<br>
Explanation: In this case, questions are used instead of items. Each question has a score which is same as each item having a value. Also, each question takes a time t which is same as each item having a weight w. You have to maximize the score in time T which is same as maximizing the value using a bag of weight W.</i><p><b>5. What is the time complexity of the brute force algorithm used to solve the Knapsack problem?<br>
a) O(n)<br>
b) O(n!)<br>
c) O(2<sup>n</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: In the brute force algorithm all the subsets of the items are found and the value of each subset is calculated. The subset of items with the maximum value and a weight less than equal to the maximum allowed weight gives the answer. The time taken to calculate all the subsets is O(2<sup>n</sup>).</i><p><b>7. Consider the following dynamic programming implementation of the Knapsack problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> find_max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> knapsack<span class="br0">(</span><span class="kw4">int</span> W<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>wt<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>val<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>n <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>W <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> itm<span class="sy0">,</span>w<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
         ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
        ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;=</span> w<span class="br0">)</span>
                  ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> ______________<span class="sy0">;</span>
               <span class="kw1">else</span>
                  ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>W<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> w<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="br0">}</span><span class="sy0">,</span> v<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">120</span><span class="br0">}</span><span class="sy0">,</span> W <span class="sy0">=</span> <span class="nu0">50</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> knapsack<span class="br0">(</span>W<span class="sy0">,</span> w<span class="sy0">,</span> v<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines completes the above code?<br>
a) find_max(ans[itm – 1][w – wt[itm – 1]] + val[itm – 1], ans[itm – 1][w])<br>
b) find_max(ans[itm – 1][w – wt[itm – 1]], ans[itm – 1][w])<br>
c) ans[itm][w] = ans[itm – 1][w];<br>
d) ans[itm+1][w] = ans[itm – 1][w];<br>
</b></p><i>Answer: b<br>
Explanation: The Knapsack problem cannot be solved using the greedy algorithm.</i><p><b>8. What is the time complexity of the following dynamic programming implementation of the Knapsack problem with n items and a maximum weight of W?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> find_max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> knapsack<span class="br0">(</span><span class="kw4">int</span> W<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>wt<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>val<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>n <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>W <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> itm<span class="sy0">,</span>w<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
         ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
        ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;=</span> w<span class="br0">)</span>
                 ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> find_max<span class="br0">(</span>ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="sy0">-</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="sy0">+</span>val<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">,</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                  ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>W<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> w<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="br0">}</span><span class="sy0">,</span> v<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">120</span><span class="br0">}</span><span class="sy0">,</span> W <span class="sy0">=</span> <span class="nu0">50</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> knapsack<span class="br0">(</span>W<span class="sy0">,</span> w<span class="sy0">,</span> v<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(n + w)<br>
c) O(nW)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: find_max(ans[itm – 1][w – wt[itm – 1]] + val[itm – 1], ans[itm – 1][w]) completes the above code.</i><p><b>9. What is the space complexity of the following dynamic programming implementation of the Knapsack problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> find_max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> knapsack<span class="br0">(</span><span class="kw4">int</span> W<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>wt<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>val<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>n <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>W <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> itm<span class="sy0">,</span>w<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
         ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
        ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;=</span> w<span class="br0">)</span>
                ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> find_max<span class="br0">(</span>ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w <span class="sy0">-</span> wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="sy0">+</span>val<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">,</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>W<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> w<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="br0">}</span><span class="sy0">,</span> v<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">120</span><span class="br0">}</span><span class="sy0">,</span> W <span class="sy0">=</span> <span class="nu0">50</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> knapsack<span class="br0">(</span>W<span class="sy0">,</span> w<span class="sy0">,</span> v<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(n + w)<br>
c) O(nW)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation of the Knapsack problem is O(nW).</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> find_max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> knapsack<span class="br0">(</span><span class="kw4">int</span> W<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>wt<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>val<span class="sy0">,</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>n <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>W <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> itm<span class="sy0">,</span>w<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
         ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
         ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>itm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> itm <span class="sy0">&lt;=</span> n<span class="sy0">;</span> itm<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>w <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> w <span class="sy0">&lt;=</span> W<span class="sy0">;</span> w<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;=</span> w<span class="br0">)</span>
                ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> find_max<span class="br0">(</span>ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="sy0">-</span>wt<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="sy0">+</span>val<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">,</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                ans<span class="br0">[</span>itm<span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>itm <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>w<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>W<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> w<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="br0">}</span><span class="sy0">,</span> v<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">60</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">120</span><span class="br0">}</span><span class="sy0">,</span> W <span class="sy0">=</span> <span class="nu0">50</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> knapsack<span class="br0">(</span>W<span class="sy0">,</span> w<span class="sy0">,</span> v<span class="sy0">,</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation of the Knapsack problem is O(nW).</i><p><b>a) 120<br>
b) 100<br>
c) 180<br>
d) 220<br>
</b></p><i>Answer: d<br>
Explanation: The output of the above code is 220.</i><p><b>1. Which of the following methods can be used to solve the matrix chain multiplication problem?<br>
a) Dynamic programming<br>
b) Brute force<br>
c) Recursion<br>
d) Dynamic Programming, Brute force, Recursion<br>
</b></p><i>Answer: d<br>
Explanation: Dynamic Programming, Brute force, Recursion methods can be used to solve the matrix chain multiplication problem.</i><p><b>3. Consider the two matrices P and Q which are 10 x 20 and 20 x 30 matrices respectively. What is the number of multiplications required to multiply the two matrices?<br>
a) 10*20<br>
b) 20*30<br>
c) 10*30<br>
d) 10*20*30<br>
</b></p><i>Answer: d<br>
Explanation: The recurrence relation is given by:<br>
dp[i,j] = 0 if i=j<br>
dp[i,j] = min{dp[i,k] + dp[k+1,j]} + mat[i-1]*mat[k]*mat[j].</i><p><b>4. Consider the matrices P, Q and R which are 10 x 20, 20 x 30 and 30 x 40 matrices respectively. What is the minimum number of multiplications required to multiply the three matrices?<br>
a) 18000<br>
b) 12000<br>
c) 24000<br>
d) 32000<br>
</b></p><i>Answer: d<br>
Explanation: The number of multiplications required is 10*20*30.</i><p><b>5. Consider the matrices P, Q, R and S which are 20 x 15, 15 x 30, 30 x 5 and 5 x 40 matrices respectively. What is the minimum number of multiplications required to multiply the four matrices?<br>
a) 6050<br>
b) 7500<br>
c) 7750<br>
d) 12000<br>
</b></p><i>Answer: a<br>
Explanation: The minimum number of multiplications are 18000. This is the case when the matrices are parenthesized as (P*Q)*R.</i><p><b>6. Consider the brute force implementation in which we find all the possible ways of multiplying the given set of n matrices. What is the time complexity of this implementation?<br>
a) O(n!)<br>
b) O(n<sup>3</sup>)<br>
c) O(n<sup>2</sup>)<br>
d) Exponential<br>
</b></p><i>Answer: c<br>
Explanation: The minimum number of multiplications required is 7750.</i><p><b>7. Consider the following dynamic programming implementation of the matrix chain problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> ________________________<span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">40</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) arr[row][k] – arr[k + 1][col] + mat[row – 1] * mat[k] * mat[col];<br>
b) arr[row][k] + arr[k + 1][col] – mat[row – 1] * mat[k] * mat[col];<br>
c) arr[row][k] + arr[k + 1][col] + mat[row – 1] * mat[k] * mat[col];<br>
d) arr[row][k] – arr[k + 1][col] – mat[row – 1] * mat[k] * mat[col];<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of finding all the possible ways of multiplying a set of n matrices is given by (n-1)<sup>th</sup> Catalan number which is exponential.</i><p><b>8. What is the time complexity of the following dynamic programming implementation of the matrix chain problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">40</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The line arr[row][k] + arr[k + 1][col] + mat[row – 1] * mat[k] * mat[col] should be inserted to complete the above code.</i><p><b>9. What is the space complexity of the following dynamic programming implementation of the matrix chain problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">40</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above dynamic programming implementation of the matrix chain multiplication is O(n<sup>3</sup>).</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
           <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">40</span><span class="sy0">,</span><span class="nu0">50</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation of the matrix chain multiplication is O(n<sup>2</sup>).</i><p><b>a) 64000<br>
b) 70000<br>
c) 120000<br>
d) 150000<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the minimum number of multiplications required, which is 64000.</i><p><b>11. What is the value stored in arr[2][3] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                     <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                     arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">40</span><span class="sy0">,</span><span class="nu0">50</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 64000<br>
b) 60000<br>
c) 24000<br>
d) 12000<br>
</b></p><i>Answer: b<br>
Explanation: The value stored in arr[2][3] when the above code is executed is 60000.</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">10</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">6</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2000<br>
b) 3000<br>
c) 4000<br>
d) 5000<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the minimum number of multiplications required to multiply the given matrices, which is 4000.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> mat_chain_multiplication<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>mat<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>k<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="sy0">,</span>len<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>n<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> len <span class="sy0">&lt;</span> n<span class="sy0">;</span> len<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> row <span class="sy0">&lt;=</span> n <span class="sy0">-</span> len <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span> 
               col <span class="sy0">=</span> row <span class="sy0">+</span> len <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
               arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> INT_MAX<span class="sy0">;</span>
               <span class="kw1">for</span><span class="br0">(</span>k <span class="sy0">=</span> row<span class="sy0">;</span> k <span class="sy0">&lt;=</span> col <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> k<span class="sy0">++</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw4">int</span> tmp <span class="sy0">=</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">+</span> arr<span class="br0">[</span>k <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> mat<span class="br0">[</span>row <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>k<span class="br0">]</span> <span class="sy0">*</span> mat<span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                    <span class="kw1">if</span><span class="br0">(</span>tmp <span class="sy0">&lt;</span> arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> tmp<span class="sy0">;</span>
               <span class="br0">}</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> mat<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">20</span><span class="sy0">,</span><span class="nu0">25</span><span class="sy0">,</span><span class="nu0">30</span><span class="sy0">,</span><span class="nu0">35</span><span class="sy0">,</span><span class="nu0">40</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> mat_chain_multiplication<span class="br0">(</span>mat<span class="sy0">,</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 32000<br>
b) 28000<br>
c) 64000<br>
d) 70000<br>
</b></p><i>Answer: c<br>
Explanation: The output of the program is 64000.</i><p><b>1. Which of the following methods can be used to solve the longest common subsequence problem?<br>
a) Recursion<br>
b) Dynamic programming<br>
c) Both recursion and dynamic programming<br>
d) Greedy algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Both recursion and dynamic programming can be used to solve the longest subsequence problem.</i><p><b>2. Consider the strings “PQRSTPQRS” and “PRATPBRQRPS”. What is the length of the longest common subsequence?<br>
a) 9<br>
b) 8<br>
c) 7<br>
d) 6<br>
</b></p><i>Answer: c<br>
Explanation: The longest common subsequence is “PRTPQRS” and its length is 7.</i><p><b>3. Which of the following problems can be solved using the longest subsequence problem?<br>
a) Longest increasing subsequence<br>
b) Longest palindromic subsequence<br>
c) Longest bitonic subsequence<br>
d) Longest decreasing subsequence<br>
</b></p><i>Answer: b<br>
Explanation: To find the longest palindromic subsequence in a given string, reverse the given string and then find the longest common subsequence in the given string and the reversed string.</i><p><b>4. Longest common subsequence is an example of ____________<br>
a) Greedy algorithm<br>
b) 2D dynamic programming<br>
c) 1D dynamic programming<br>
d) Divide and conquer<br>
</b></p><i>Answer: b<br>
Explanation: Longest common subsequence is an example of 2D dynamic programming.</i><p><b>5. What is the time complexity of the brute force algorithm used to find the longest common subsequence?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the brute force algorithm used to find the longest common subsequence is O(2<sup>n</sup>).</i><p><b>6. Consider the following dynamic programming implementation of the longest common subsequence problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
            <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
            <span class="br0">{</span>
                 <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  ______________<span class="sy0">;</span>
                <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">" abcedfg"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"bcdfh"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines completes the above code?<br>
a) arr[i][j] = 1 + arr[i][j].<br>
b) arr[i][j] = 1 + arr[i – 1][j – 1].<br>
c) arr[i][j] = arr[i – 1][j – 1].<br>
d) arr[i][j] = arr[i][j].<br>
</b></p><i>Answer: b<br>
Explanation: The line, arr[i][j] = 1 + arr[i – 1][j – 1] completes the above code.</i><p><b>7. What is the time complexity of the following dynamic programming implementation of the longest common subsequence problem where length of one string is “m” and the length of the other string is “n”?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
            <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
            <span class="br0">{</span>
                 <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">" abcedfg"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"bcdfh"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(m)<br>
c) O(m + n)<br>
d) O(mn)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above dynamic programming implementation of the longest common subsequence is O(mn).</i><p><b>8. What is the space complexity of the following dynamic programming implementation of the longest common subsequence problem where length of one string is “m” and the length of the other string is “n”?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
            <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
            <span class="br0">{</span>
                 <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">" abcedfg"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"bcdfh"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(m)<br>
c) O(m + n)<br>
d) O(mn)<br>
</b></p><i>Answer: d<br>
Explanation: The space complexity of the above dynamic programming implementation of the longest common subsequence is O(mn).</i><p><b>9. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"hbcfgmnapq"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"cbhgrsfnmq"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The program prints the length of the longest common subsequence, which is 4.</i><p><b>a) 3<br>
b) 4<br>
c) 5<br>
d) 6<br>
</b></p><i>Answer: d<br>
Explanation: The length of the longest common subsequence is 4. But ‘fgmna’ is not the longest common subsequence as its length is 5.</i><p><b>10. Which of the following is the longest common subsequence between the strings “hbcfgmnapq” and “cbhgrsfnmq” ?<br>
a) hgmq<br>
b) cfnq<br>
c) bfmq<br>
d) fgmna<br>
</b></p><i>Answer: a<br>
Explanation: The value stored in arr[2][3] is 1.</i><p><b>11. What is the value stored in arr[2][3] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"hbcfgmnapq"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"cbhgrsfnmq"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the length of the longest common subsequence, which is 0.</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lcs<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>str2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len1<span class="sy0">,</span>len2<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> str2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"efgh"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> lcs<span class="br0">(</span>str1<span class="sy0">,</span>str2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 3<br>
b) 2<br>
c) 1<br>
d) 0<br>
</b></p><i>undefined</i><p><b>1. Which of the following methods can be used to solve the longest palindromic subsequence problem?<br>
a) Dynamic programming<br>
b) Recursion<br>
c) Brute force<br>
d) Dynamic programming, Recursion, Brute force<br>
</b></p><i>Answer: d<br>
Explanation: Dynamic programming, Recursion, Brute force can be used to solve the longest palindromic subsequence problem.</i><p><b>2. Which of the following is not a palindromic subsequence of the string “ababcdabba”?<br>
a) abcba<br>
b) abba<br>
c) abbbba<br>
d) adba<br>
</b></p><i>Answer: d<br>
Explanation: ‘adba’ is not a palindromic sequence.</i><p><b>3. For which of the following, the length of the string is not equal to the length of the longest palindromic subsequence?<br>
a) A string that is a palindrome<br>
b) A string of length one<br>
c) A string that has all the same letters(e.g. aaaaaa)<br>
d) Some strings of length two<br>
</b></p><i>Answer: d<br>
Explanation: A string of length 2 for eg: ab is not a palindrome.</i><p><b>4. What is the length of the longest palindromic subsequence for the string “ababcdabba”?<br>
a) 6<br>
b) 7<br>
c) 8<br>
d) 9<br>
</b></p><i>Answer: b<br>
Explanation: The longest palindromic subsequence is “abbabba” and its length is 7.</i><p><b>5. What is the time complexity of the brute force algorithm used to find the length of the longest palindromic subsequence?<br>
a) O(1)<br>
b) O(2<sup>n</sup>)<br>
c) O(n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: In the brute force algorithm, all the subsequences are found and the length of the longest palindromic subsequence is calculated. This takes exponential time.</i><p><b>7. Longest palindromic subsequence is an example of ______________<br>
a) Greedy algorithm<br>
b) 2D dynamic programming<br>
c) 1D dynamic programming<br>
d) Divide and conquer<br>
</b></p><i>Answer: a<br>
Explanation: A single character of any string can always be considered as a palindrome and its length is one.</i><p><b>8. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      ______________<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"ababcdabba"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines completes the above code?<br>
a) strrev(str2)<br>
b) str2 = str1<br>
c) len2 = strlen(str2)<br>
d) strlen(str2)<br>
</b></p><i>Answer: b<br>
Explanation: Longest palindromic subsequence is an example of 2D dynamic programming.</i><p><b>9. What is the time complexity of the following dynamic programming implementation to find the longest palindromic subsequence where the length of the string is n?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"ababcdabba"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(n<sup>2</sup>)<br>
d) O(2)<br>
</b></p><i>Answer: a<br>
Explanation: To find the longest palindromic subsequence, we need to reverse the copy of the string, which is done by  strrev.</i><p><b>10. What is the space complexity of the following dynamic programming implementation to find the longest palindromic subsequence where the length of the string is n?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                   arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"ababcdabba"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(n<sup>2</sup>)<br>
d) O(2)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation to find the longest palindromic subsequence is O(n<sup>2</sup>).</i><p><b>11. What is the value stored in arr[3][3] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
                <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                    arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="kw1">else</span>
                    arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"ababcdabba"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation to find the longest palindromic subsequence is O(n<sup>2</sup>).</i><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: a<br>
Explanation: The value stored in arr[3][3] when the above code is executed is 2.</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the length of the longest palindromic subsequence, which is 1.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> lps<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>str1<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>len<span class="sy0">;</span>
      len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">char</span> str2<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>str2<span class="sy0">,</span> str1<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>str2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>str1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> str2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">+</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max_num<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> str1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abdgkagdjbccbba"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> lps<span class="br0">(</span>str1<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 5<br>
b) 7<br>
c) 9<br>
d) 11<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the length of the longest palindromic subsequence, which is 9.</i><p><b>1. Which of the following methods can be used to solve the edit distance problem?<br>
a) Recursion<br>
b) Dynamic programming<br>
c) Both dynamic programming and recursion<br>
d) Greedy Algorithm<br>
</b></p><i>Answer: c<br>
Explanation: Both dynamic programming and recursion can be used to solve the edit distance problem.</i><p><b>3. Which of the following is an application of the edit distance problem?<br>
a) Approximate string matching<br>
b) Spelling correction<br>
c) Similarity of DNA<br>
d) Approximate string matching, Spelling Correction and Similarity of DNA<br>
</b></p><i>Answer: a<br>
Explanation: d(s,s) = 0, since each string can be transformed into itself without any change.<br>
d(s1, s2) &gt; 0 when s1 != s2, since the transformation would require at least one operation.<br>
d(s1, s2) = d(s2, s1)<br>
d(s1, s3) &lt;= d(s1, s2) + d(s2, s3)<br>
Thus, the edit distance satisfies the axioms of a metric.</i><p><b>4. In which of the following cases will the edit distance between two strings be zero?<br>
a) When one string is a substring of another<br>
b) When the lengths of the two strings are equal<br>
c) When the two strings are equal<br>
d) The edit distance can never be zero<br>
</b></p><i>Answer: d<br>
Explanation: All of the mentioned are the applications of the edit distance problem.</i><p><b>6. Consider the strings “monday” and “tuesday”. What is the edit distance between the two strings?<br>
a) 3<br>
b) 4<br>
c) 5<br>
d) 6<br>
</b></p><i>Answer: c<br>
Explanation: The edit distance will be zero only when the two strings are equal.</i><p><b>7. Consider the two strings “”(empty string) and “abcd”. What is the edit distance between the two strings?<br>
a) 0<br>
b) 4<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: a<br>
Explanation: Consider the strings “abcd” and “efghi”. The string “efghi” can be converted to “abcd” by deleting “i” and converting “efgh” to “abcd”. The cost of transformation is 5, which is equal to the length of the larger string.</i><p><b>8. Consider the following dynamic programming implementation of the edit distance problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
               min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                       min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                         min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="br0">}</span>
                _____________<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"defg"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be added to complete the above code?<br>
a) arr[i-1][j] = min<br>
b) arr[i][j-1] = min<br>
c) arr[i-1][j-1] = min<br>
d) arr[i][j] = min<br>
</b></p><i>Answer: b<br>
Explanation: “monday” can be converted to “tuesday” by replacing “m” with “t”, “o” with “u”, “n” with “e” and inserting “s” at the appropriate position. So, the edit distance is 4.</i><p><b>9. What is the time complexity of the following dynamic programming implementation of the edit distance problem where “m” and “n” are the lengths of two strings?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
               min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                       min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                         min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="br0">}</span>
                arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"defg"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(m + n)<br>
c) O(mn)<br>
d) O(n)<br>
</b></p><i>Answer: b<br>
Explanation: The empty string can be transformed into “abcd” by inserting “a”, “b”, “c” and “d” at appropriate positions. Thus, the edit distance is 4.</i><p><b>10. What is the space complexity of the following dynamic programming implementation of the edit distance problem where “m” and “n” are the lengths of the two strings?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
               min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
               <span class="br0">{</span>
                    <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                       min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                         min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="br0">}</span>
                arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"defg"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(m + n)<br>
c) O(mn)<br>
d) O(n)<br>
</b></p><i>Answer: d<br>
Explanation: The line arr[i][j] = min completes the above code.</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
              min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                      min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="br0">}</span>
              <span class="kw1">else</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="br0">}</span>
              arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"defg"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation of the edit distance problem is O(mn).</i><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation of the edit distance problem is O(mn).</i><p><b>12. What is the value stored in arr[2][2] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                 min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
                 <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 <span class="br0">{</span>
                      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                        min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                 <span class="br0">}</span>
                 <span class="kw1">else</span>
                 <span class="br0">{</span>
                      <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                        min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
                 <span class="br0">}</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"defg"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the edit distance between the strings “abcd” and “defg”, which is 4.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
              min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="br0">}</span>
              <span class="kw1">else</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="br0">}</span>
              arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"pqrstuv"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"prstuv"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: The value stored in arr[2][2] when the above code is executed is 2.</i><p><b>1. Wagner–Fischer is a ____________ algorithm.<br>
a) Brute force<br>
b) Greedy<br>
c) Dynamic programming<br>
d) Recursive<br>
</b></p><i>Answer: c<br>
Explanation: Wagner–Fischer belongs to the dynamic programming type of algorithms.</i><p><b>2. Wagner–Fischer algorithm is used to find ____________<br>
a) Longest common subsequence<br>
b) Longest increasing subsequence<br>
c) Edit distance between two strings<br>
d) Longest decreasing subsequence<br>
</b></p><i>Answer: c<br>
Explanation: Wagner–Fischer algorithm is used to find the edit distance between two strings.</i><p><b>3. What is the edit distance between the strings “abcd” and “acbd” when the allowed operations are insertion, deletion and substitution?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: The string “abcd” can be changed to “acbd” by substituting “b” with “c” and “c” with “b”. Thus, the edit distance is 2.</i><p><b>4. For which of the following pairs of strings is the edit distance maximum?<br>
a) sunday &amp; monday<br>
b) monday &amp; tuesday<br>
c) tuesday &amp; wednesday<br>
d) wednesday &amp; thursday<br>
</b></p><i>Answer: d<br>
Explanation: The edit distances are 2, 4, 4 and 5 respectively. Hence, the maximum edit distance is between the strings wednesday and thursday.</i><p><b>5. Consider the following implementation of the Wagner–Fischer algorithm:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
              min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                      ____________<span class="sy0">;</span>
              <span class="br0">}</span>
              <span class="kw1">else</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                      min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="br0">}</span>
              arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) arr[i][j] = min<br>
b) min = arr[i-1][j-1] – 1;<br>
c) min = arr[i-1][j-1].<br>
d) min = arr[i-1][j-1] + 1;<br>
</b></p><i>Answer: c<br>
Explanation: The line min = arr[i-1][j-1] completes the above code.</i><p><b>6. What is the time complexity of the Wagner–Fischer algorithm where “m” and “n” are the lengths of the two strings?<br>
a) O(1)<br>
b) O(n+m)<br>
c) O(mn)<br>
d) O(nlogm)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the Wagner–Fischer algorithm is O(mn).</i><p><b>7. What is the space complexity of the above implementation of Wagner–Fischer algorithm where “m” and “n” are the lengths of the two strings?<br>
a) O(1)<br>
b) O(n+m)<br>
c) O(mn)<br>
d) O(nlogm)<br>
</b></p><i>Answer: c<br>
Explanation: The space complexity of the above Wagner–Fischer algorithm is O(mn).</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
               min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
               <span class="br0">{</span>
                   <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                      min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                   <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
               <span class="br0">}</span>
               arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"somestring"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"anotherthing"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 6<br>
b) 7<br>
c) 8<br>
d) 9<br>
</b></p><i>Answer: a<br>
Explanation: The program prints the edit distance between the strings “somestring” and “anotherthing”, which is 6.</i><p><b>9. What is the value stored in arr[3][3] when the below code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
      len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
      len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
                <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                <span class="br0">{</span>
                     <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                       min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw1">else</span>
                <span class="br0">{</span>
                    <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
                <span class="br0">}</span>
                arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
          <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"somestring"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"anotherthing"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The value stored in arr[3][3] is 3.</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&lt;</span> b<span class="br0">)</span>
         <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> edit_distance<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s1<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s2<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> len1<span class="sy0">,</span>len2<span class="sy0">,</span>i<span class="sy0">,</span>j<span class="sy0">,</span>min<span class="sy0">;</span>
     len1 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s1<span class="br0">)</span><span class="sy0">;</span>
     len2 <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>len1 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len2 <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
       arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len1<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len2<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
              min <span class="sy0">=</span> get_min<span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>s1<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> s2<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                     min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="br0">}</span>
              <span class="kw1">else</span>
              <span class="br0">{</span>
                  <span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> min<span class="br0">)</span>
                      min <span class="sy0">=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="br0">}</span>
              arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> min<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>len1<span class="br0">]</span><span class="br0">[</span>len2<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> s1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcd"</span><span class="sy0">,</span> s2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"dcba"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> edit_distance<span class="br0">(</span>s1<span class="sy0">,</span> s2<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The program prints the edit distance between the strings “abcd” and “dcba”, which is 4.</i><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>undefined</i><p><b>1. Which of the following is NOT a Catalan number?<br>
a) 1<br>
b) 5<br>
c) 14<br>
d) 43<br>
</b></p><i>Answer: d<br>
Explanation: Catalan numbers are given by: (2n!)/((n+1)!n!).<br>
For n = 0, we get C0 = 1.<br>
For n = 3, we get C3 = 5.<br>
For n = 4, we get C4 = 14.<br>
For n = 5, we get C3 = 42.</i><p><b>2. Which of the following numbers is the 6th Catalan number?<br>
a) 14<br>
b) 429<br>
c) 132<br>
d) 42<br>
</b></p><i>Answer: d<br>
Explanation: Catalan numbers are given by: (2n!)/((n+1)!n!).<br>
First Catalan number is given by n = 0.<br>
So the 6th Catalan number will be given by n = 5, which is 42.</i><p><b>3. Which of the following is not an application of Catalan Numbers?<br>
a) Counting the number of Dyck words<br>
b) Counting the number of expressions containing n pairs of parenthesis<br>
c) Counting the number of ways in which a convex polygon can be cut into triangles by connecting vertices with straight lines<br>
d) Creation of head and tail for a given number of tosses<br>
</b></p><i>Answer: d<br>
Explanation: Counting the number of Dyck words, Counting the number of expressions containing n pairs of parenthesis, Counting the number of ways in which a convex polygon can be cut into triangles by connecting vertices with straight lines are the applications of Catalan numbers where as creation of head and tails for a given number of tosses is an application of Pascal’s triangle.</i><p><b>4. Which of the following methods can be used to find the nth Catalan number?<br>
a) Recursion<br>
b) Binomial coefficients<br>
c) Dynamic programming<br>
d) Recursion, Binomial Coefficients, Dynamic programming<br>
</b></p><i>Answer: d<br>
Explanation: All of the mentioned methods can be used to find the nth Catalan number.</i><p><b>5. The recursive formula for Catalan number is given by Cn = ∑Ci*C(n-i).<br>
Consider the following dynamic programming implementation for Catalan numbers:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cat_number<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>arr<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>k<span class="sy0">;</span>
     arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>k <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++,</span>k<span class="sy0">--</span><span class="br0">)</span>
           ______________________<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
     ans <span class="sy0">=</span> cat_number<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines completes the above code?<br>
a) arr[i] = arr[j] * arr[k];<br>
b) arr[j] += arr[i] * arr[k];<br>
c) arr[i] += arr[j] * arr[k].<br>
d) arr[j] = arr[i] * arr[k];<br>
</b></p><i>Answer: c<br>
Explanation: The line arr[i] += arr[j] * arr[k] reflects the recursive formula Cn = ∑Ci*C(n-i).</i><p><b>6. Which of the following implementations of Catalan numbers has the smallest time complexity?<br>
a) Dynamic programming<br>
b) Binomial coefficients<br>
c) Recursion<br>
d) All have equal time complexity<br>
</b></p><i>Answer: b<br>
Explanation: The time complexities are as follows:<br>
Dynamic programming: O(n<sup>2</sup>)<br>
Recursion: Exponential<br>
Binomial coefficients: O(n).</i><p><b>7. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cat_number<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>arr<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>k<span class="sy0">;</span>
     arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>k <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++,</span>k<span class="sy0">--</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">*</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span>
     ans <span class="sy0">=</span> cat_number<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 42<br>
b) 132<br>
c) 429<br>
d) 1430<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the 8th Catalan number, which is 429.</i><p><b>8. Which of the following implementations of Catalan numbers has the largest space complexity(Don’t consider the stack space)?<br>
a) Dynamic programming<br>
b) Binomial coefficients<br>
c) Recursion<br>
d) All have equal space complexities<br>
</b></p><i>Answer: a<br>
Explanation: The space complexities are as follows:<br>
Dynamic programming: O(n)<br>
Recursion: O(1)<br>
Binomial coefficients: O(1).</i><p><b>9. What will be the value stored in arr[5] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cat_number<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>arr<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>k<span class="sy0">;</span>
     arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>k <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++,</span>k<span class="sy0">--</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">*</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
     ans <span class="sy0">=</span> cat_number<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 14<br>
b) 42<br>
c) 132<br>
d) 429<br>
</b></p><i>Answer: b<br>
Explanation: The 6th Catalan number will be stored in arr[5], which is 42.</i><p><b>10. Which of the following errors will occur when the below code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> cat_number<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> i<span class="sy0">,</span>j<span class="sy0">,</span>arr<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>k<span class="sy0">;</span>
     arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span>k <span class="sy0">=</span> i <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> i<span class="sy0">;</span> j<span class="sy0">++,</span>k<span class="sy0">--</span><span class="br0">)</span>
           arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">*</span> arr<span class="br0">[</span>k<span class="br0">]</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> ans<span class="sy0">,</span> n <span class="sy0">=</span> <span class="nu0">100</span><span class="sy0">;</span>
     ans <span class="sy0">=</span> cat_number<span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es1">\n</span>"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The 100th Catalan number is too large to be stored in an integer. So, the error produced will be integer value out of range.(It will be a logical error and the compiler wont show it).</i><p><b>a) Segmentation fault<br>
b) Array size too large<br>
c) Integer value out of range<br>
d) Array index out of range<br>
</b></p><i>undefined</i><p><b>1. Which of the following methods can be used to solve the assembly line scheduling problem?<br>
a) Recursion<br>
b) Brute force<br>
c) Dynamic programming<br>
d) All of the mentioned<br>
</b></p><i>Answer: d<br>
Explanation: All of the above mentioned methods can be used to solve the assembly line scheduling problem.</i><p><b>2. What is the time complexity of the brute force algorithm used to solve the assembly line scheduling problem?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: In the brute force algorithm, all the possible ways are calculated which are of the order of 2<sup>n</sup>.</i><p><b>3. In the dynamic programming implementation of the assembly line scheduling problem, how many lookup tables are required?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: In the dynamic programming implementation of the assembly line scheduling problem, 2 lookup tables are required one for storing the minimum time and the other for storing the assembly line number.</i><p><b>4. Consider the following assembly line problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">time_to_reach[2][3] = {{17, 2, 7}, {19, 4, 9}}
time_spent[2][4] = {{6, 5, 15, 7}, {5, 10, 11, 4}}
entry_time[2] = {8, 10}
exit_time[2] = {10, 7}
num_of_stations = 4</pre></div></div></div></div></div></div><p><b>For the optimal solution which should be the starting assembly line?<br>
a) Line 1<br>
b) Line 2<br>
c) All of the mentioned<br>
d) None of the mentioned<br>
</b></p><i>Answer: b<br>
Explanation: For the optimal solution, the starting assembly line is line 2.</i><p><b>5. Consider the following assembly line problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">time_to_reach[2][3] = {{17, 2, 7}, {19, 4, 9}}
time_spent[2][4] = {{6, 5, 15, 7}, {5, 10, 11, 4}}
entry_time[2] = {8, 10}
exit_time[2] = {10, 7}
num_of_stations = 4</pre></div></div></div></div></div></div><p><b>For the optimal solution, which should be the exit assembly line?<br>
a) Line 1<br>
b) Line 2<br>
c) All of the mentioned<br>
d) None of the mentioned<br>
</b></p><i>Answer: b<br>
Explanation: For the optimal solution, the exit assembly line is line 2.</i><p><b>6. Consider the following assembly line problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="txt"><pre class="de1">time_to_reach[2][3] = {{17, 2, 7}, {19, 4, 9}}
time_spent[2][4] = {{6, 5, 15, 7}, {5, 10, 11, 4}}
entry_time[2] = {8, 10}
exit_time[2] = {10, 7}
num_of_stations = 4</pre></div></div></div></div></div></div><p><b>What is the minimum time required to build the car chassis?<br>
a) 40<br>
b) 41<br>
c) 42<br>
d) 43<br>
</b></p><i>Answer: d<br>
Explanation: The minimum time required is 43.<br>
The path is S2,1 -&gt; S1,2 -&gt; S2,3 -&gt; S2,4, where Si,j : i = line number, j = station number </i><p><b>7. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a<span class="sy0">&lt;</span>b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> minimum_time_required<span class="br0">(</span><span class="kw4">int</span> reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>entry<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span><span class="kw3">exit</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> t1<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>i<span class="sy0">;</span>
     t1<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     t2<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         t1<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
         __________<span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The line t2[i] = get_min(t2[i-1]+spent[1][i], t1[i-1]+reach[0][i-1]+spent[1][i]) should be added to complete the above code.</i><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) t2[i] = get_min(t2[i-1]+spent[1][i], t1[i-1]+reach[0][i-1]+spent[1][i])<br>
b) t2[i] = get_min(t2[i-1]+spent[1][i], t1[i-1]+spent[1][i])<br>
c) t2[i] = get_min(t2[i-1]+spent[1][i], t1[i-1]+reach[0][i-1])<br>
d) none of the mentioned<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the above dynamic programming implementation of the assembly line scheduling problem is O(n).</i><p><b>8. What is the time complexity of the above dynamic programming implementation of the assembly line scheduling problem?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: The space complexity of the above dynamic programming implementation of the assembly line scheduling problem is O(n).</i><p><b>9. What is the space complexity of the above dynamic programming implementation of the assembly line scheduling problem?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: The program prints the optimal time required to build the car chassis, which is 34.</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a<span class="sy0">&lt;</span>b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> minimum_time_required<span class="br0">(</span><span class="kw4">int</span> reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>entry<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span><span class="kw3">exit</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> t1<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> i<span class="sy0">;</span>
     t1<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     t2<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         t1<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
         t2<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> time_to_reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>
                           <span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> time_spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>
                        <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> entry_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> exit_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> num_of_stations <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> minimum_time_required<span class="br0">(</span>time_to_reach<span class="sy0">,</span> time_spent<span class="sy0">,</span> 
              entry_time<span class="sy0">,</span> exit_time<span class="sy0">,</span> num_of_stations<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 32<br>
b) 33<br>
c) 34<br>
d) 35<br>
</b></p><i>Answer: c<br>
Explanation: The value stored in t1[2] when the above code is executed is 20.</i><p><b>11. What is the value stored in t1[2] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a<span class="sy0">&lt;</span>b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> minimum_time_required<span class="br0">(</span><span class="kw4">int</span> reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>entry<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span><span class="kw3">exit</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> t1<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>i<span class="sy0">;</span>
      t1<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      t2<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          t1<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          t2<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="kw1">return</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> time_to_reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>
                            <span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> time_spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>
                        <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> entry_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> exit_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> num_of_stations <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> minimum_time_required<span class="br0">(</span>time_to_reach<span class="sy0">,</span> time_spent<span class="sy0">,</span> 
               entry_time<span class="sy0">,</span> exit_time<span class="sy0">,</span> num_of_stations<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 16<br>
b) 18<br>
c) 20<br>
d) 22<br>
</b></p><i>Answer: c<br>
Explanation: The value stored in t2[3] when the above code is executed is 25.</i><p><b>12. What is the value stored in t2[3] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw1">if</span><span class="br0">(</span>a<span class="sy0">&lt;</span>b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
     <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> minimum_time_required<span class="br0">(</span><span class="kw4">int</span> reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>entry<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span><span class="kw3">exit</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> t1<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span>i<span class="sy0">;</span>
     t1<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     t2<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         t1<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
         t2<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> time_to_reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>
                           <span class="br0">{</span><span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> time_spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="sy0">,</span>
                        <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> entry_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> exit_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">;</span>
    <span class="kw4">int</span> num_of_stations <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
    <span class="kw4">int</span> ans <span class="sy0">=</span> minimum_time_required<span class="br0">(</span>time_to_reach<span class="sy0">,</span> time_spent<span class="sy0">,</span> 
              entry_time<span class="sy0">,</span> exit_time<span class="sy0">,</span> num_of_stations<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 19<br>
b) 23<br>
c) 25<br>
d) 27<br>
</b></p><i>Answer: d<br>
Explanation: The program prints the optimal time required to build the car chassis, which is 88.</i><p><b>13. What is the output of the  following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_min<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a<span class="sy0">&lt;</span>b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> minimum_time_required<span class="br0">(</span><span class="kw4">int</span> reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>entry<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span><span class="kw3">exit</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> t1<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">,</span> i<span class="sy0">;</span>
      t1<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      t2<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> entry<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          t1<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          t2<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> get_min<span class="br0">(</span>t2<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> t1<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>reach<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span>spent<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> get_min<span class="br0">(</span>t1<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> t2<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">+</span><span class="kw3">exit</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> time_to_reach<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">16</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">12</span><span class="br0">}</span><span class="sy0">,</span>
                           <span class="br0">{</span><span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">17</span><span class="sy0">,</span> <span class="nu0">8</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> time_spent<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">13</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">19</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">,</span>
                        <span class="br0">{</span><span class="nu0">15</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">16</span><span class="sy0">,</span> <span class="nu0">13</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> entry_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> exit_time<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">13</span><span class="br0">}</span><span class="sy0">;</span>
     <span class="kw4">int</span> num_of_stations <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> minimum_time_required<span class="br0">(</span>time_to_reach<span class="sy0">,</span> time_spent<span class="sy0">,</span> 
               entry_time<span class="sy0">,</span> exit_time<span class="sy0">,</span> num_of_stations<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>undefined</i><p><b>a) 62<br>
b) 69<br>
c) 75<br>
d) 88<br>
</b></p><i>undefined</i><p><b>1. Given a string, you have to find the minimum number of characters to be inserted in the string so that the string becomes a palindrome. Which of the following methods can be used to solve the problem?<br>
a) Greedy algorithm<br>
b) Recursion<br>
c) Dynamic programming<br>
d) Both recursion and dynamic programming<br>
</b></p><i>Answer: d<br>
Explanation: Dynamic programming and recursion can be used to solve the problem.</i><p><b>2. In which of the following cases the minimum no of insertions to form palindrome is maximum?<br>
a) String of length one<br>
b) String with all same characters<br>
c) Palindromic string<br>
d) Non palindromic string<br>
</b></p><i>Answer: d<br>
Explanation: In string of length one, string with all same characters and a palindromic string the no of insertions is zero since the strings are already palindromes. To convert a non-palindromic string to a palindromic string, the minimum length of string to be added is 1 which is greater than all the other above cases. Hence the minimum no of insertions to form palindrome is maximum in non-palindromic strings.</i><p><b>4. Consider the string “efge”. What is the minimum number of insertions required to make the string a palindrome?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: In the worst case, the minimum number of insertions to be made to convert the string into a palindrome is equal to length of the string minus one. For example, consider the string “abc”. The string can be converted to “abcba” by inserting “a” and “b”. The number of insertions is two, which is equal to length minus one.</i><p><b>5. Consider the string “abbccbba”. What is the minimum number of insertions required to make the string a palindrome?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: The string can be converted to “efgfe” by inserting “f” or to “egfge” by inserting “g”. Thus, only one insertion is required.</i><p><b>6. Which of the following problems can be used to solve the minimum number of insertions to form a palindrome problem?<br>
a) Minimum number of jumps problem<br>
b) Longest common subsequence problem<br>
c) Coin change problem<br>
d) Knapsack problems<br>
</b></p><i>Answer: a<br>
Explanation: The given string is already a palindrome. So, no insertions are required.</i><p><b>7. Consider the following dynamic programming implementation:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> _____________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcda"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be added to complete the code?<br>
a) arr[len][len] <br>
b) len + arr[len][len] <br>
c) len<br>
d) len – arr[len][len] <br>
</b></p><i>Answer: b<br>
Explanation: A variation of longest common subsequence can be used to solve the minimum number of insertions to form a palindrome problem.</i><p><b>8. What is the time complexity of the following dynamic programming implementation of the minimum number of insertions to form a palindrome problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len <span class="sy0">-</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcda"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(mn)<br>
</b></p><i>Answer: d<br>
Explanation: arr[len][len] contains the length of the longest palindromic subsequence. So, len – arr[len][len] gives the minimum number of insertions required to form a palindrome.</i><p><b>9. What is the space complexity of the following dynamic programming implementation of the minimum number of insertions to form a palindrome problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len <span class="sy0">-</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcda"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(mn)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation is O(n<sup>2</sup>).</i><p><b>10. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len <span class="sy0">-</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcda"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation is O(n<sup>2</sup>).</i><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: The length of the longest palindromic subsequence is 3. So, the output will be 5 – 3 = 2.</i><p><b>11. What is the value stored in arr[2][4] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len <span class="sy0">-</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"abcda"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: a<br>
Explanation: The value stored in arr[2][4] when the above code is executed is 2.</i><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> max<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> min_ins<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>s<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">char</span> rev<span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw3">strcpy</span><span class="br0">(</span>rev<span class="sy0">,</span> s<span class="br0">)</span><span class="sy0">;</span>
      strrev<span class="br0">(</span>rev<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
          arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">if</span><span class="br0">(</span>s<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">==</span> rev<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span>
              <span class="kw1">else</span>
                  arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> max<span class="br0">(</span>arr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> len <span class="sy0">-</span> arr<span class="br0">[</span>len<span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">char</span> s<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"efgfe"</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> min_ins<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 2<br>
c) 4<br>
d) 6<br>
</b></p><i>Answer: a<br>
Explanation: Since the string “efgfe” is already a palindrome, the number of insertions required is 0.</i><p><b>1. Given a 2D matrix, find a submatrix that has the maximum sum. Which of the following methods can be used to solve this problem?<br>
a) Brute force<br>
b) Recursion<br>
c) Dynamic programming<br>
d) Brute force, Recursion, Dynamic programming<br>
</b></p><i>Answer: d<br>
Explanation: Brute force, Recursion and Dynamic programming can be used to find the submatrix that has the maximum sum.</i><p><b>2. In which of the following cases, the maximum sum rectangle is the 2D matrix itself?<br>
a) When all the elements are negative<br>
b) When all the elements are positive<br>
c) When some elements are positive and some negative<br>
d) When diagonal elements are positive and rest are negative<br>
</b></p><i>Answer: a<br>
Explanation: When all the elements of a matrix are positive, the maximum sum rectangle is the 2D matrix itself.</i><p><b>5. Consider the 2×3 matrix {{1,2,3},{1,2,3}}. What is the sum of elements of the maximum sum rectangle?<br>
a) 3<br>
b) 6<br>
c) 12<br>
d) 18<br>
</b></p><i>Answer: d<br>
Explanation: If the matrix size is 1×1 then the element itself is the maximum sum of that 1×1 matrix. If all elements are zero, then the sum of any submatrix of the given matrix is zero. If all elements are negative, then the maximum element in that matrix is the highest sum in that matrix which is again 1X1 submatrix of the given matrix. Hence all three statements are correct.</i><p><b>6. Consider the 2×2 matrix {{-1,-2},{-3,-4}}. What is the sum of elements of the maximum sum rectangle?<br>
a) 0<br>
b) -1<br>
c) -7<br>
d) -12<br>
</b></p><i>Answer: a<br>
Explanation: If a matrix contains all non-zero elements with at least one positive and at least on negative element, then the sum of elements of the maximum sum rectangle cannot be zero.</i><p><b>7. Consider the 3×3 matrix {{2,1,-3},{6,3,4},{-2,3,0}}. What is the sum of the elements of the maximum sum rectangle?<br>
a) 13<br>
b) 16<br>
c) 14<br>
d) 19<br>
</b></p><i>Answer: c<br>
Explanation: Since all the elements of the 2×3 matrix are positive, the maximum sum rectangle is the matrix itself and the sum of elements is 12.</i><p><b>8. What is the time complexity of the brute force implementation of the maximum sum rectangle problem?<br>
a) O(n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n<sup>3</sup>)<br>
d) O(n<sup>4</sup>)<br>
</b></p><i>Answer: b<br>
Explanation: Since all the elements of the 2×2 matrix are negative, the maximum sum rectangle is {-1}, a 1×1 matrix containing the largest element. The sum of elements of the maximum sum rectangle is -1.</i><p><b>9. The dynamic programming implementation of the maximum sum rectangle problem uses which of the following algorithm?<br>
a) Hirschberg’s algorithm<br>
b) Needleman-Wunsch algorithm<br>
c) Kadane’s algorithm<br>
d) Wagner Fischer algorithm<br>
</b></p><i>Answer: c<br>
Explanation: The complete matrix represents the maximum sum rectangle and it’s sum is 14.</i><p><b>10. Consider the following code snippet:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> max_sum_rectangle<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> row<span class="sy0">,</span><span class="kw4">int</span> col<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> left<span class="sy0">,</span> right<span class="sy0">,</span> tmp<span class="br0">[</span>row<span class="br0">]</span><span class="sy0">,</span> mx_sm <span class="sy0">=</span> INT_MIN<span class="sy0">,</span> idx<span class="sy0">,</span> val<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>left <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> left <span class="sy0">&lt;</span> col<span class="sy0">;</span> left<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>right <span class="sy0">=</span> left<span class="sy0">;</span> right <span class="sy0">&lt;</span> col<span class="sy0">;</span> right<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>right <span class="sy0">==</span> left<span class="br0">)</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                     tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                      tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               val <span class="sy0">=</span> kadane_algo<span class="br0">(</span>tmp<span class="sy0">,</span>row<span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">&gt;</span> mx_sm<span class="br0">)</span>
                  ______<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> mx_sm<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) val = mx_sm<br>
b) return val<br>
c) mx_sm = val<br>
d) return mx_sm<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the brute force implementation of the maximum sum rectangle problem is O(n<sup>4</sup>).</i><p><b>11. What is the time complexity of the following dynamic programming implementation of the maximum sum rectangle problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> max_sum_rectangle<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> row<span class="sy0">,</span><span class="kw4">int</span> col<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> left<span class="sy0">,</span> right<span class="sy0">,</span> tmp<span class="br0">[</span>row<span class="br0">]</span><span class="sy0">,</span> mx_sm <span class="sy0">=</span> INT_MIN<span class="sy0">,</span> idx<span class="sy0">,</span> val<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>left <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> left <span class="sy0">&lt;</span> col<span class="sy0">;</span> left<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>right <span class="sy0">=</span> left<span class="sy0">;</span> right <span class="sy0">&lt;</span> col<span class="sy0">;</span> right<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>right <span class="sy0">==</span> left<span class="br0">)</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                     tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                      tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               val <span class="sy0">=</span> kadane_algo<span class="br0">(</span>tmp<span class="sy0">,</span>row<span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">&gt;</span> mx_sm<span class="br0">)</span>
                 mx_sm <span class="sy0">=</span> val<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> mx_sm<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(row*col)<br>
b) O(row)<br>
c) O(col)<br>
d) O(row*col*col)<br>
</b></p><i>Answer: c<br>
Explanation: The dynamic programming implementation of the maximum sum rectangle problem uses Kadane’s algorithm.</i><p><b>12. What is the space complexity of the following dynamic programming implementation of the maximum sum rectangle problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> max_sum_rectangle<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> row<span class="sy0">,</span><span class="kw4">int</span> col<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> left<span class="sy0">,</span> right<span class="sy0">,</span> tmp<span class="br0">[</span>row<span class="br0">]</span><span class="sy0">,</span> mx_sm <span class="sy0">=</span> INT_MIN<span class="sy0">,</span> idx<span class="sy0">,</span> val<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>left <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> left <span class="sy0">&lt;</span> col<span class="sy0">;</span> left<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>right <span class="sy0">=</span> left<span class="sy0">;</span> right <span class="sy0">&lt;</span> col<span class="sy0">;</span> right<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>right <span class="sy0">==</span> left<span class="br0">)</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                     tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                      tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               val <span class="sy0">=</span> kadane_algo<span class="br0">(</span>tmp<span class="sy0">,</span>row<span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">&gt;</span> mx_sm<span class="br0">)</span>
                 mx_sm <span class="sy0">=</span> val<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> mx_sm<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(row*col)<br>
b) O(row)<br>
c) O(col)<br>
d) O(row*col*col)<br>
</b></p><i>Answer: c<br>
Explanation: The line “mx_sm = val” should be inserted to complete the above code.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> ans<span class="sy0">,</span> sum<span class="sy0">,</span> idx<span class="sy0">;</span>
      ans <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      sum <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          sum <span class="sy0">=</span> max_num<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>sum <span class="sy0">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          ans <span class="sy0">=</span> max_num<span class="br0">(</span>sum<span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> ans<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> max_sum_rectangle<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> row<span class="sy0">,</span><span class="kw4">int</span> col<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> left<span class="sy0">,</span> right<span class="sy0">,</span> tmp<span class="br0">[</span>row<span class="br0">]</span><span class="sy0">,</span> mx_sm <span class="sy0">=</span> INT_MIN<span class="sy0">,</span> idx<span class="sy0">,</span> val<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>left <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> left <span class="sy0">&lt;</span> col<span class="sy0">;</span> left<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>right <span class="sy0">=</span> left<span class="sy0">;</span> right <span class="sy0">&lt;</span> col<span class="sy0">;</span> right<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                <span class="kw1">if</span><span class="br0">(</span>right <span class="sy0">==</span> left<span class="br0">)</span>
                <span class="br0">{</span>
                    <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                     tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
                <span class="br0">}</span>
                <span class="kw1">else</span>
                <span class="br0">{</span>
                     <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                       tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
                <span class="br0">}</span>
                val <span class="sy0">=</span> kadane_algo<span class="br0">(</span>tmp<span class="sy0">,</span>row<span class="br0">)</span><span class="sy0">;</span>
                <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">&gt;</span> mx_sm<span class="br0">)</span>
                mx_sm <span class="sy0">=</span> val<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>  
      <span class="kw1">return</span> mx_sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
       <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">20</span><span class="br0">}</span><span class="sy0">,</span> <span class="br0">{</span><span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
       <span class="kw4">int</span> row <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
       <span class="kw4">int</span> ans <span class="sy0">=</span> max_sum_rectangle<span class="br0">(</span>arr<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
       <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: The time complexity of the above dynamic programming implementation of the maximum sum rectangle is O(row*col*col).</i><p><b>a) 7<br>
b) 8<br>
c) 9<br>
d) 10<br>
</b></p><i>Answer: b<br>
Explanation: The space complexity of the above dynamic programming implementation of the maximum sum rectangle problem is O(row).</i><p><b>14. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;limits.h&gt;</span>
<span class="kw4">int</span> max_num<span class="br0">(</span><span class="kw4">int</span> a<span class="sy0">,</span> <span class="kw4">int</span> b<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>a <span class="sy0">&gt;</span> b<span class="br0">)</span>
        <span class="kw1">return</span> a<span class="sy0">;</span>
      <span class="kw1">return</span> b<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> kadane_algo<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> ans<span class="sy0">,</span> sum<span class="sy0">,</span> idx<span class="sy0">;</span>
      ans <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      sum <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> len<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          sum <span class="sy0">=</span> max_num<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span>sum <span class="sy0">+</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
          ans <span class="sy0">=</span> max_num<span class="br0">(</span>sum<span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> ans<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> max_sum_rectangle<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy0">,</span><span class="kw4">int</span> row<span class="sy0">,</span><span class="kw4">int</span> col<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> left<span class="sy0">,</span> right<span class="sy0">,</span> tmp<span class="br0">[</span>row<span class="br0">]</span><span class="sy0">,</span> mx_sm <span class="sy0">=</span> INT_MIN<span class="sy0">,</span> idx<span class="sy0">,</span> val<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>left <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> left <span class="sy0">&lt;</span> col<span class="sy0">;</span> left<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
           <span class="kw1">for</span><span class="br0">(</span>right <span class="sy0">=</span> left<span class="sy0">;</span> right <span class="sy0">&lt;</span> col<span class="sy0">;</span> right<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
               <span class="kw1">if</span><span class="br0">(</span>right <span class="sy0">==</span> left<span class="br0">)</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                      tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               <span class="kw1">else</span>
               <span class="br0">{</span>
                   <span class="kw1">for</span><span class="br0">(</span>idx <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> idx <span class="sy0">&lt;</span> row<span class="sy0">;</span> idx<span class="sy0">++</span><span class="br0">)</span>
                      tmp<span class="br0">[</span>idx<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>idx<span class="br0">]</span><span class="br0">[</span>right<span class="br0">]</span><span class="sy0">;</span>
               <span class="br0">}</span>
               val <span class="sy0">=</span> kadane_algo<span class="br0">(</span>tmp<span class="sy0">,</span>row<span class="br0">)</span><span class="sy0">;</span>
               <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">&gt;</span> mx_sm<span class="br0">)</span>
               mx_sm <span class="sy0">=</span> val<span class="sy0">;</span>
           <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> mx_sm<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">=</span><span class="br0">{</span><span class="br0">{</span> <span class="nu0">7</span><span class="sy0">,</span>  <span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">6</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">15</span><span class="br0">}</span><span class="sy0">,</span>
                    <span class="br0">{</span> <span class="nu0">10</span><span class="sy0">,</span>  <span class="sy0">-</span><span class="nu0">6</span><span class="sy0">,</span>  <span class="nu0">3</span><span class="sy0">,</span>  <span class="sy0">-</span><span class="nu0">4</span><span class="sy0">,</span>  <span class="nu0">11</span><span class="br0">}</span><span class="sy0">,</span>
                    <span class="br0">{</span> <span class="sy0">-</span><span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">3</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span>  <span class="nu0">2</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">5</span><span class="br0">}</span><span class="sy0">,</span>
                    <span class="br0">{</span> <span class="nu0">3</span><span class="sy0">,</span>  <span class="nu0">0</span><span class="sy0">,</span>  <span class="nu0">1</span><span class="sy0">,</span>  <span class="nu0">0</span><span class="sy0">,</span>  <span class="nu0">3</span><span class="br0">}</span><span class="br0">}</span><span class="sy0">;</span>
      <span class="kw4">int</span> row <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> max_sum_rectangle<span class="br0">(</span>arr<span class="sy0">,</span>row<span class="sy0">,</span>col<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 17<br>
b) 18<br>
c) 19<br>
d) 20<br>
</b></p><i>Answer: b<br>
Explanation: The program prints the sum of elements of the maximum sum rectangle, which is 8.</i><p><b>1. Given an array, check if the array can be divided into two subsets such that the sum of elements of the two subsets is equal. This is the balanced partition problem. Which of the following methods can be used to solve the balanced partition problem?<br>
a) Dynamic programming<br>
b) Recursion<br>
c) Brute force<br>
d) Dynamic programming, Recursion, Brute force<br>
</b></p><i>Answer: d<br>
Explanation: All of the mentioned methods can be used to solve the balanced partition problem.</i><p><b>2. In which of the following cases, it is not possible to have two subsets with equal sum?<br>
a) When the number of elements is odd<br>
b) When the number of elements is even<br>
c) When the sum of elements is odd<br>
d) When the sum of elements is even<br>
</b></p><i>Answer: c<br>
Explanation: When the sum of all the elements is odd, it is not possible to have two subsets with equal sum.</i><p><b>3. What is the time complexity of the brute force algorithm used to solve the balanced partition problem?<br>
a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(2<sup>n</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: In the brute force implementation, all the possible subsets will be formed. This takes exponential time.</i><p><b>4. Consider a variation of the balanced partition problem in which we find two subsets such that |S1 – S2| is minimum. Consider the array {1, 2, 3, 4, 5}. Which of the following pairs of subsets is an optimal solution for the above problem?<br>
a) {5, 4} &amp; {3, 2, 1}<br>
b) {5} &amp; {4, 3, 2, 1}<br>
c) {4, 2} &amp; {5, 3, 1}<br>
d) {5, 3} &amp; {4, 2, 1}<br>
</b></p><i>Answer: d<br>
Explanation: For S1 = {5, 3} and S2 = {4, 2, 1}, sum(S1) – sum(S2) = 1, which is the optimal solution.</i><p><b>5. Consider the following code:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> _______________<span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be inserted to complete the above code?<br>
a) ans[i – arr[j – 1]][j – 1] <br>
b) ans[i][j] <br>
c) ans[i][j] || ans[i – arr[j – 1]][j – 1] <br>
d) ans[i][j] &amp;&amp; ans[i – arr[j – 1]][j – 1] <br>
</b></p><i>Answer: c<br>
Explanation: The line “ans[i][j] || ans[i – arr[j – 1]][j – 1]” completes the above code.</i><p><b>6. What is the time complexity of the following dynamic programming implementation of the balanced partition problem where “n” is the number of elements and “sum” is their sum?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(sum)<br>
b) O(n)<br>
c) O(sum * n)<br>
d) O(sum + n)<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the above dynamic programming implementation of the balanced partition problem is     O(sum * n).</i><p><b>7. What is the space complexity of the following dynamic programming implementation of the balanced partition problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(sum)<br>
b) O(n)<br>
c) O(sum * n)<br>
d) O(sum + n)<br>
</b></p><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation of the balanced partition problem is    O(sum * n).</i><p><b>8. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">else</span>
         <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The partitions are S1 = {6, 7} and S2 = {1, 3, 4, 5} and the sum of each partition is 13. So, the array can be divided into balanced partitions.</i><p><b>9. What is the value stored in ans[3][3] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) -1<br>
d) -2<br>
</b></p><i>Answer: b<br>
Explanation: The value stored in ans[3][3] indicates if a sum of 3 can be obtained using a subset of the first 3 elements. Since the sum can be obtained the value stored is 1.</i><p><b>10. What is the sum of each of the balanced partitions for the array {5, 6, 7, 10, 3, 1}?<br>
a) 16<br>
b) 32<br>
c) 0<br>
d) 64<br>
</b></p><i>Answer: a<br>
Explanation: The sum of all the elements of the array is 32. So, the sum of all the elements of each partition should be 16.</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>12. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> balanced_partition<span class="br0">(</span><span class="kw4">int</span> <span class="sy0">*</span>arr<span class="sy0">,</span> <span class="kw4">int</span> len<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      sm <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>sm <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>len <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> len<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
      ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sm<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>j <span class="sy0">&lt;=</span> len<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
             <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>
                 ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> ans<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> ans<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> ans<span class="br0">[</span>sm<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>len<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">2</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">5</span><span class="sy0">,</span> <span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">7</span><span class="sy0">,</span> <span class="nu0">8</span><span class="sy0">,</span> <span class="nu0">9</span><span class="br0">}</span><span class="sy0">,</span> len <span class="sy0">=</span> <span class="nu0">9</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> balanced_partition<span class="br0">(</span>arr<span class="sy0">,</span>len<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span>ans <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">else</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>1. You are given n dice each having f faces. You have to find the number of ways in which a sum of S can be achieved. This is the dice throw problem. Which of the following methods can be used to solve the dice throw problem?<br>
a) Brute force<br>
b) Recursion<br>
c) Dynamic programming<br>
d) Brute force, Recursion and Dynamic Programming<br>
</b></p><i>Answer: d<br>
Explanation: Brute force, Recursion and Dynamic Programming can be used to solve the dice throw problem. </i><p><b>2. You have n dice each having f faces. What is the number of permutations that can be obtained when you roll the n dice together?<br>
a) n*n*n…f times<br>
b) f*f*f…n times<br>
c) n*n*n…n times<br>
d) f*f*f…f times<br>
</b></p><i>Answer: b<br>
Explanation: Each die can take f values and there are n dice. So, the total number of permutations is f*f*f…n times.</i><p><b>3. You have 3 dice each having 6 faces. What is the number of permutations that can be obtained when you roll the 3 dice together?<br>
a) 27<br>
b) 36<br>
c) 216<br>
d) 81<br>
</b></p><i>Answer: c<br>
Explanation: The total number of permutations that can be obtained is 6 * 6 * 6 = 216.</i><p><b>4. You have 2 dice each of them having 6 faces numbered from 1 to 6. What is the number of ways in which a sum of 11 can be achieved?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The sum of 11 can be achieved when the dice show {6, 5} or {5, 6}.</i><p><b>5. There are n dice with f faces. The faces are numbered from 1 to f. What is the minimum possible sum that can be obtained when the n dice are rolled together?<br>
a) 1<br>
b) f<br>
c) n<br>
d) n*f<br>
</b></p><i>Answer: c<br>
Explanation: The sum will be minimum when all the faces show a value 1. The sum in this case will be n.</i><p><b>6. There are n dice with f faces. The faces are numbered from 1 to f. What is the maximum possible sum that can be obtained when the n dice are rolled together?<br>
a) 1<br>
b) f*f<br>
c) n*n<br>
d) n*f<br>
</b></p><i>Answer: d<br>
Explanation: The sum will be maximum when all the faces show a value f. The sum in this case will be n*f.</i><p><b>7. There are 10 dice having 5 faces. The faces are numbered from 1 to 5. What is the number of ways in which a sum of 4 can be achieved?<br>
a) 0<br>
b) 2<br>
c) 4<br>
d) 8<br>
</b></p><i>Answer: a<br>
Explanation: Since there are 10 dice and the minimum value each die can take is 1, the minimum possible sum is 10. Hence, a sum of 4 cannot be achieved.</i><p><b>8. Consider the following dynamic programming implementation of the dice throw problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span> 
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> _____________<span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>Which of the following lines should be added to complete the above code?<br>
a) arr[num_of_dice][S] <br>
b) arr[dice][sm] <br>
c) arr[dice][S] <br>
d) arr[S][dice] <br>
</b></p><i>Answer: a<br>
Explanation: The line arr[num_of_dice][S] completes the above code.</i><p><b>9. What is time complexity of the following dynamic programming implementation of the dice throw problem where f is the number of faces, n is the number of dice and s is the sum to be found?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span> 
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n*f)<br>
b) O(f*s)<br>
c) O(n*s)<br>
d) O(n*f*s)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above dynamic programming implementation is O(n*f*s).</i><p><b>10. What is space complexity of the following dynamic programming implementation of the dice throw problem where f is the number of faces, n is the number of dice and s is the sum to be found?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span> 
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n*f)<br>
b) O(f*s)<br>
c) O(n*s)<br>
d) O(n*f*s)<br>
</b></p><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation is O(n*s).</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: a<br>
Explanation: The output of the above code is 10.</i><p><b>a) 10<br>
b) 12<br>
c) 14<br>
d) 16<br>
</b></p><i>Answer: b<br>
Explanation: The value stored in arr[2][2] is 1.</i><p><b>12. What will be the value stored in arr[2][2] when the following code is executed?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                  arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: a<br>
Explanation: The minimum possible sum is 4. So, the output for sum = 3 is 0.</i><p><b>13. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
           arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The output of the above code is 4.</i><p><b>14. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="kw4">int</span> get_ways<span class="br0">(</span><span class="kw4">int</span> num_of_dice<span class="sy0">,</span> <span class="kw4">int</span> num_of_faces<span class="sy0">,</span> <span class="kw4">int</span> S<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> arr<span class="br0">[</span>num_of_dice <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>S <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> dice<span class="sy0">,</span> face<span class="sy0">,</span> sm<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
          <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
            arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
         arr<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span> dice <span class="sy0">&lt;=</span> num_of_dice<span class="sy0">;</span> dice<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>sm <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> sm <span class="sy0">&lt;=</span> S<span class="sy0">;</span> sm<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              <span class="kw1">for</span><span class="br0">(</span>face <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> face <span class="sy0">&lt;=</span> num_of_faces <span class="sy0">&amp;&amp;</span> face <span class="sy0">&lt;</span> sm<span class="sy0">;</span> face<span class="sy0">++</span><span class="br0">)</span>
                 arr<span class="br0">[</span>dice<span class="br0">]</span><span class="br0">[</span>sm<span class="br0">]</span> <span class="sy0">+=</span> arr<span class="br0">[</span>dice <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sm <span class="sy0">-</span> face<span class="br0">]</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> arr<span class="br0">[</span>num_of_dice<span class="br0">]</span><span class="br0">[</span>S<span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> num_of_dice <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">,</span> num_of_faces <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">,</span> sum <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span>
      <span class="kw4">int</span> ans <span class="sy0">=</span> get_ways<span class="br0">(</span>num_of_dice<span class="sy0">,</span> num_of_faces<span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 2<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>undefined</i><p><b>1. You are given a boolean expression which consists of operators &amp;, | and ∧ (AND, OR and XOR) and symbols T or F (true or false). You have to find the number of ways in which the symbols can be parenthesized so that the expression evaluates to true. This is the boolean parenthesization problem. Which of the following methods can be used to solve the problem?<br>
a) Dynamic programming<br>
b) Recursion<br>
c) Brute force<br>
d) Dynamic programming, Recursion and Brute force<br>
</b></p><i>Answer: d<br>
Explanation: Dynamic programming, Recursion and Brute force can be used to solve the Boolean parenthesization problem.</i><p><b>2. Consider the expression T &amp; F | T. What is the number of ways in which the expression can be parenthesized so that the output is T (true)?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The expression can be parenthesized as T &amp; (F | T) and (T &amp; F) | T so that the output is T.</i><p><b>3. Consider the expression T &amp; F ∧ T.  What is the number of ways in which the expression can be parenthesized so that the output is T (true)?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: The expression can be parenthesized as (T &amp; F) ∧ T  or  T &amp; (F ∧ T), so that the output is T.</i><p><b>4. Consider the expression T | F ∧ T. In how many ways can the expression be parenthesized so that the output is F (false)?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: b<br>
Explanation: The expression can be parenthesized as (T | F) ∧ T, so that the output is F (false).</i><p><b>5. Which of the following gives the total number of ways of parenthesizing an expression with n + 1 terms?<br>
a) n factorial<br>
b) n square<br>
c) n cube<br>
d) nth catalan number<br>
</b></p><i>Answer: d<br>
Explanation: The nth Catalan number gives the total number of ways of parenthesizing an expression with n + 1 terms.</i><p><b>6. What is the maximum number of ways in which a boolean expression with n + 1 terms can be parenthesized, such that the output is true?<br>
a) nth catalan number<br>
b) n factorial<br>
c) n cube<br>
d) n square<br>
</b></p><i>Answer: a<br>
Explanation: The number of ways will be maximum when all the possible parenthesizations result in a true value. The number of possible parenthesizations is given by the nth catalan number.</i><p><b>7. Consider the following dynamic programming implementation of the boolean parenthesization problem:</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> count_bool_parenthesization<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>sym<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>op<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> str_len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>sym<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> True<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">,</span>False<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> row<span class="sy0">,</span>col<span class="sy0">,</span>length<span class="sy0">,</span>l<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> row <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> row<span class="sy0">++,</span>col<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">if</span><span class="br0">(</span>sym<span class="br0">[</span>row<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'T'</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="br0">}</span>
          <span class="kw1">else</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>length <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> length <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> length<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> length<span class="sy0">;</span> col <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> col<span class="sy0">++,</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              <span class="kw1">for</span><span class="br0">(</span>l <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> l <span class="sy0">&lt;</span> length<span class="sy0">;</span> l<span class="sy0">++</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw4">int</span> pos <span class="sy0">=</span> row <span class="sy0">+</span> l<span class="sy0">;</span>
                  <span class="kw4">int</span> t_row_pos <span class="sy0">=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw4">int</span> t_pos_col <span class="sy0">=</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'|'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'&amp;'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'^'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
              <span class="br0">}</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> True<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>str_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>8. Which of the following lines should be added to complete the “if(op[k] == ‘&amp;’)” part of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> count_bool_parenthesization<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>sym<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>op<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> str_len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>sym<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> True<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">,</span>False<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> row<span class="sy0">,</span>col<span class="sy0">,</span>length<span class="sy0">,</span>l<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> row <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> row<span class="sy0">++,</span>col<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">if</span><span class="br0">(</span>sym<span class="br0">[</span>row<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'T'</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="br0">}</span>
          <span class="kw1">else</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>length <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> length <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> length<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> length<span class="sy0">;</span> col <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> col<span class="sy0">++,</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              <span class="kw1">for</span><span class="br0">(</span>l <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> l <span class="sy0">&lt;</span> length<span class="sy0">;</span> l<span class="sy0">++</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw4">int</span> pos <span class="sy0">=</span> row <span class="sy0">+</span> l<span class="sy0">;</span>
                  <span class="kw4">int</span> t_row_pos <span class="sy0">=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw4">int</span> t_pos_col <span class="sy0">=</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'|'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'&amp;'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'^'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      _______________<span class="sy0">;</span>
                  <span class="br0">}</span>
              <span class="br0">}</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> True<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>str_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>9. What is the time complexity of the following dynamic programming implementation of the boolean parenthesization problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> count_bool_parenthesization<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>sym<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>op<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> str_len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>sym<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> True<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">,</span>False<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> row<span class="sy0">,</span>col<span class="sy0">,</span>length<span class="sy0">,</span>l<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> row <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> row<span class="sy0">++,</span>col<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">if</span><span class="br0">(</span>sym<span class="br0">[</span>row<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'T'</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="br0">}</span>
          <span class="kw1">else</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>length <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> length <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> length<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> length<span class="sy0">;</span> col <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> col<span class="sy0">++,</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              <span class="kw1">for</span><span class="br0">(</span>l <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> l <span class="sy0">&lt;</span> length<span class="sy0">;</span> l<span class="sy0">++</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw4">int</span> pos <span class="sy0">=</span> row <span class="sy0">+</span> l<span class="sy0">;</span>
                  <span class="kw4">int</span> t_row_pos <span class="sy0">=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw4">int</span> t_pos_col <span class="sy0">=</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'|'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                      True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'&amp;'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'^'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                      <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                       <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="br0">}</span>
              <span class="br0">}</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> True<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>str_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The following lines should be added:<br>
False[row][col] += False[row][pos] * False[pos+1][col];<br>
True[row][col] += t_row_pos * t_pos_col + False[row][pos] * False[pos+1][col];</i><p><b>10. What is the space complexity of the following dynamic programming implementation of the boolean parenthesization problem?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">int</span> count_bool_parenthesization<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>sym<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>op<span class="br0">)</span>
<span class="br0">{</span>
      <span class="kw4">int</span> str_len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>sym<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw4">int</span> True<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">,</span>False<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">;</span>
      <span class="kw4">int</span> row<span class="sy0">,</span>col<span class="sy0">,</span>length<span class="sy0">,</span>l<span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> row <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> row<span class="sy0">++,</span>col<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">if</span><span class="br0">(</span>sym<span class="br0">[</span>row<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'T'</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
          <span class="br0">}</span>
          <span class="kw1">else</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">for</span><span class="br0">(</span>length <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> length <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> length<span class="sy0">++</span><span class="br0">)</span>
      <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> length<span class="sy0">;</span> col <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> col<span class="sy0">++,</span> row<span class="sy0">++</span><span class="br0">)</span>
          <span class="br0">{</span>
              True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              <span class="kw1">for</span><span class="br0">(</span>l <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> l <span class="sy0">&lt;</span> length<span class="sy0">;</span> l<span class="sy0">++</span><span class="br0">)</span>
              <span class="br0">{</span>
                  <span class="kw4">int</span> pos <span class="sy0">=</span> row <span class="sy0">+</span> l<span class="sy0">;</span>
                  <span class="kw4">int</span> t_row_pos <span class="sy0">=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw4">int</span> t_pos_col <span class="sy0">=</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'|'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                      False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                      True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'&amp;'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="br0">}</span>
                  <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'^'</span><span class="br0">)</span>
                  <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                       <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                       <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                  <span class="br0">}</span>
              <span class="br0">}</span>
          <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">return</span> True<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>str_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The following lines should be added:<br>
True[row][col] += True[row][pos] * True[pos+1][col];<br>
False[row][col] += t_row_pos * t_pos_col – True[row][pos] * True[pos+1][col];</i><p><b>a) O(1)<br>
b) O(n)<br>
c) O(n<sup>2</sup>)<br>
d) O(n<sup>3</sup>)<br>
</b></p><i>Answer: d<br>
Explanation: The time complexity of the above dynamic programming implementation is O(n<sup>3</sup>).</i><p><b>11. What is the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;stdio.h&gt;</span>
<span class="co2">#include&lt;string.h&gt;</span>
<span class="kw4">int</span> count_bool_parenthesization<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>sym<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>op<span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">int</span> str_len <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>sym<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw4">int</span> True<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">,</span>False<span class="br0">[</span>str_len<span class="br0">]</span><span class="br0">[</span>str_len<span class="br0">]</span><span class="sy0">;</span>
     <span class="kw4">int</span> row<span class="sy0">,</span>col<span class="sy0">,</span>length<span class="sy0">,</span>l<span class="sy0">;</span>
     <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> row <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> row<span class="sy0">++,</span>col<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">if</span><span class="br0">(</span>sym<span class="br0">[</span>row<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'T'</span><span class="br0">)</span>
         <span class="br0">{</span>
             True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
             False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
         <span class="br0">}</span>
         <span class="kw1">else</span>
         <span class="br0">{</span>
             True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
             False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">for</span><span class="br0">(</span>length <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> length <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> length<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
         <span class="kw1">for</span><span class="br0">(</span>row <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> col <span class="sy0">=</span> length<span class="sy0">;</span> col <span class="sy0">&lt;</span> str_len<span class="sy0">;</span> col<span class="sy0">++,</span> row<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
             True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
             False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
             <span class="kw1">for</span><span class="br0">(</span>l <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> l <span class="sy0">&lt;</span> length<span class="sy0">;</span> l<span class="sy0">++</span><span class="br0">)</span>
             <span class="br0">{</span>
                 <span class="kw4">int</span> pos <span class="sy0">=</span> row <span class="sy0">+</span> l<span class="sy0">;</span>
                 <span class="kw4">int</span> t_row_pos <span class="sy0">=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span>
                 <span class="kw4">int</span> t_pos_col <span class="sy0">=</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                 <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'|'</span><span class="br0">)</span>
                 <span class="br0">{</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                 <span class="br0">}</span>
                 <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'&amp;'</span><span class="br0">)</span>
                 <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> t_row_pos <span class="sy0">*</span> t_pos_col <span class="sy0">-</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                 <span class="br0">}</span>
                 <span class="kw1">if</span><span class="br0">(</span>op<span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'^'</span><span class="br0">)</span>
                 <span class="br0">{</span>
                     True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                       <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                     False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> <span class="sy0">+=</span> True<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> True<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span> 
                                       <span class="sy0">+</span> False<span class="br0">[</span>row<span class="br0">]</span><span class="br0">[</span>pos<span class="br0">]</span> <span class="sy0">*</span> False<span class="br0">[</span>pos<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>col<span class="br0">]</span><span class="sy0">;</span>
                 <span class="br0">}</span>
             <span class="br0">}</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
     <span class="kw1">return</span> True<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>str_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
     <span class="kw4">char</span> sym<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"TTTT"</span><span class="sy0">;</span>
     <span class="kw4">char</span> op<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"|^^"</span><span class="sy0">;</span>
     <span class="kw4">int</span> ans <span class="sy0">=</span> count_bool_parenthesization<span class="br0">(</span>sym<span class="sy0">,</span>op<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d"</span><span class="sy0">,</span>ans<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The space complexity of the above dynamic programming implementation is O(n<sup>2</sup>).</i><p><b>1. What is the meaning of cipher in cryptography?<br>
a) an algorithm that performs encryption<br>
b) an algorithm that generates a secret code<br>
c) an algorithm that performs encryption or decryption<br>
d) a secret code<br>
</b></p><i>Answer: c<br>
Explanation: Cipher is an algorithm for performing encryption or decryption. In cryptography, a set of defined steps are followed to generate ciphers.</i><p><b>2. Which of the following is a type of traditional cipher?<br>
a) transportation cipher<br>
b) transposition cipher<br>
c) transforming cipher<br>
d) vigenere cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of a traditional cipher. First is transposition cipher and the second is substitution cipher.</i><p><b>3. Which of the following ciphers are created by shuffling the letters of a word?<br>
a) substitution cipher<br>
b) transposition cipher<br>
c) vigenere cipher<br>
d) hill cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of traditional ciphers – Transposition and substitution cipher. In transposition cipher the letters of the given data are shuffled in a particular order, fixed by a given rule.</i><p><b>4. Which of the following is a type of substitution cipher?<br>
a) Mono alphabetic cipher<br>
b) transposition cipher<br>
c) transportation cipher<br>
d) transforming cipher<br>
</b></p><i>Answer: a<br>
Explanation: In substitution cipher the plain text is replaced by cipher text according to a fixed rule. There are two types of substitution cipher – Mono alphabetic and Poly alphabetic cipher.</i><p><b>5. Which of the following is not a type of mono alphabetic cipher?<br>
a) additive cipher<br>
b) multiplicative cipher<br>
c) afffine cipher<br>
d) hill cipher<br>
</b></p><i>Answer: d<br>
Explanation: In mono alphabetic cipher each symbol of plain text is replaced by a particular respective symbol in the cipher text. There are three types of mono alphabetic ciphers- additive, multiplicative and affine.</i><p><b>6. Which of the following is not a type of poly alphabetic cipher?<br>
a) Auto key cipher<br>
b) Hill cipher<br>
c) Playfair cipher<br>
d) Additive cipher<br>
</b></p><i>Answer:d<br>
Explanation: In poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. Out of the given options, only additive cipher is not a poly alphabetic cipher.</i><p><b>7. What will be the ciphered text for the input string “sanfoundry” with key string as “code” to the program of keyword cipher?<br>
a) SCMBNUMERY<br>
b) SSCMBNUMERY<br>
c) NIFO<br>
d) NILO<br>
</b></p><i>Answer: a<br>
Explanation: Keyword cipher is type of mono alphabetic cipher. In this algorithm the letters {A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z} by<br>
{C,O,D,E,A,B,F,G,H,I,J,K,L,M,N,P,Q,R,S,T,U,V,W,X,Y,Z} respectively.</i><p><b>8. Which of the following is a type of transposition cipher?<br>
a) Rail Fence cipher<br>
b) Hill cipher<br>
c) Rotor cipher<br>
d) One time pad<br>
</b></p><i>Answer: a<br>
Explanation: In transposition cipher the letters of the given data are shuffled in a particular order, fixed by a given rule. There are two types of transposition cipher – Rail fence cipher and Columnar transposition cipher.</i><p><b>9. What will be output for the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include&lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
string encrypter<span class="br0">(</span>string keyword<span class="br0">)</span> 
<span class="br0">{</span> 
	string encoded <span class="sy0">=</span> <span class="st0">""</span><span class="sy0">;</span> 	
	bool arr<span class="br0">[</span><span class="nu0">26</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>keyword.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span><span class="br0">(</span>keyword<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;=</span> <span class="st0">'A'</span> <span class="sy0">&amp;&amp;</span> keyword<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> <span class="st0">'Z'</span><span class="br0">)</span> 
		<span class="br0">{</span> 		
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>keyword<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span><span class="nu0">65</span><span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
			<span class="br0">{</span> 
				encoded <span class="sy0">+=</span> keyword<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
				arr<span class="br0">[</span>keyword<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span><span class="nu0">65</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
			<span class="br0">}</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>keyword<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;=</span> <span class="st0">'a'</span> <span class="sy0">&amp;&amp;</span> keyword<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span> <span class="st0">'z'</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			<span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>keyword<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span><span class="nu0">97</span><span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
			<span class="br0">{</span> 
				encoded <span class="sy0">+=</span> keyword<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">32</span><span class="sy0">;</span> 
				alpha<span class="br0">[</span>keyword<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-</span><span class="nu0">97</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> 
			<span class="br0">}</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span><span class="nu0">26</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span><span class="br0">(</span>arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">=</span><span class="nu0">1</span><span class="sy0">;</span> 
			encoded <span class="sy0">+=</span> <span class="kw4">char</span><span class="br0">(</span>i <span class="sy0">+</span> <span class="nu0">65</span><span class="br0">)</span><span class="sy0">;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span> encoded<span class="sy0">;</span> 
<span class="br0">}</span> 
string ciphertxt<span class="br0">(</span>string msg<span class="sy0">,</span> string encoded<span class="br0">)</span> 
<span class="br0">{</span> 
	string cipher<span class="sy0">=</span><span class="st0">""</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>msg.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
		<span class="kw1">if</span> <span class="br0">(</span>msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;=</span><span class="st0">'a'</span> <span class="sy0">&amp;&amp;</span> msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span><span class="st0">'z'</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			<span class="kw4">int</span> pos <span class="sy0">=</span> msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">97</span><span class="sy0">;</span> 
			cipher <span class="sy0">+=</span> encoded<span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;=</span><span class="st0">'A'</span> <span class="sy0">&amp;&amp;</span> msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;=</span><span class="st0">'Z'</span><span class="br0">)</span> 
		<span class="br0">{</span> 
			<span class="kw4">int</span> pos <span class="sy0">=</span> msg<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">-</span> <span class="nu0">65</span><span class="sy0">;</span> 
			cipher <span class="sy0">+=</span> encoded<span class="br0">[</span>pos<span class="br0">]</span><span class="sy0">;</span> 
		<span class="br0">}</span> 
		<span class="kw1">else</span>
		<span class="br0">{</span> 
			cipher <span class="sy0">+=</span> msg<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 
		<span class="br0">}</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span> cipher<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	string keyword<span class="sy0">;</span> 
	keyword <span class="sy0">=</span> <span class="st0">"cipher"</span><span class="sy0">;</span> 	
	string encoded <span class="sy0">=</span> encrypter<span class="br0">(</span>keyword<span class="br0">)</span><span class="sy0">;</span> 
	string message <span class="sy0">=</span> <span class="st0">"hello"</span><span class="sy0">;</span> 
	cout  <span class="sy0">&lt;&lt;</span> ciphertxt<span class="br0">(</span>message<span class="sy0">,</span>encoded<span class="br0">)</span> <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) bejjm<br>
b) LFPDAR<br>
c) BEJJM<br>
d) lfpdar<br>
</b></p><i>Answer: c<br>
Explanation: The given code is the implementation of keyword cipher. It is an example of mono alphabetic cipher. The given string is always converted into an uppercase ciphered text.</i><p><b>10. What will be output for the given code taking input string as “sanfoundry”?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">package com.<span class="me1">sanfoundry</span>.<span class="me1">setandstring</span><span class="sy0">;</span>
import java.<span class="me1">util</span>.<span class="me1">Scanner</span><span class="sy0">;</span>
public class MonoalphabeticCipher
<span class="br0">{</span>
      public <span class="kw4">static</span> <span class="kw4">char</span> p<span class="br0">[</span><span class="br0">]</span>  <span class="sy0">=</span> <span class="br0">{</span> <span class="st0">'a'</span><span class="sy0">,</span> <span class="st0">'b'</span><span class="sy0">,</span> <span class="st0">'c'</span><span class="sy0">,</span> <span class="st0">'d'</span><span class="sy0">,</span> <span class="st0">'e'</span><span class="sy0">,</span> <span class="st0">'f'</span><span class="sy0">,</span> <span class="st0">'g'</span><span class="sy0">,</span> <span class="st0">'h'</span><span class="sy0">,</span> <span class="st0">'i'</span><span class="sy0">,</span> <span class="st0">'j'</span><span class="sy0">,</span>
                                  <span class="st0">'k'</span><span class="sy0">,</span> <span class="st0">'l'</span><span class="sy0">,</span> <span class="st0">'m'</span><span class="sy0">,</span> <span class="st0">'n'</span><span class="sy0">,</span> <span class="st0">'o'</span><span class="sy0">,</span> <span class="st0">'p'</span><span class="sy0">,</span> <span class="st0">'q'</span><span class="sy0">,</span> <span class="st0">'r'</span><span class="sy0">,</span> <span class="st0">'s'</span><span class="sy0">,</span> <span class="st0">'t'</span><span class="sy0">,</span>
                                  <span class="st0">'u'</span><span class="sy0">,</span> <span class="st0">'v'</span><span class="sy0">,</span> <span class="st0">'w'</span><span class="sy0">,</span> <span class="st0">'x'</span><span class="sy0">,</span> <span class="st0">'y'</span><span class="sy0">,</span> <span class="st0">'z'</span> <span class="br0">}</span><span class="sy0">;</span>
      public <span class="kw4">static</span> <span class="kw4">char</span> ch<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span> <span class="st0">'Q'</span><span class="sy0">,</span> <span class="st0">'W'</span><span class="sy0">,</span> <span class="st0">'E'</span><span class="sy0">,</span> <span class="st0">'R'</span><span class="sy0">,</span> <span class="st0">'T'</span><span class="sy0">,</span> <span class="st0">'Y'</span><span class="sy0">,</span> <span class="st0">'U'</span><span class="sy0">,</span> <span class="st0">'I'</span><span class="sy0">,</span> <span class="st0">'O'</span><span class="sy0">,</span> <span class="st0">'P'</span><span class="sy0">,</span>
                                  <span class="st0">'A'</span><span class="sy0">,</span> <span class="st0">'S'</span><span class="sy0">,</span> <span class="st0">'D'</span><span class="sy0">,</span> <span class="st0">'F'</span><span class="sy0">,</span> <span class="st0">'G'</span><span class="sy0">,</span> <span class="st0">'H'</span><span class="sy0">,</span> <span class="st0">'J'</span><span class="sy0">,</span> <span class="st0">'K'</span><span class="sy0">,</span> <span class="st0">'L'</span><span class="sy0">,</span> <span class="st0">'Z'</span><span class="sy0">,</span>
                                  <span class="st0">'X'</span><span class="sy0">,</span> <span class="st0">'C'</span><span class="sy0">,</span> <span class="st0">'V'</span><span class="sy0">,</span> <span class="st0">'B'</span><span class="sy0">,</span> <span class="st0">'N'</span><span class="sy0">,</span> <span class="st0">'M'</span> <span class="br0">}</span><span class="sy0">;</span>
      public <span class="kw4">static</span> String doEncryption<span class="br0">(</span>String s<span class="br0">)</span>
      <span class="br0">{</span> 
           <span class="kw4">char</span> c<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> new <span class="kw4">char</span><span class="br0">[</span><span class="br0">(</span>s.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">]</span><span class="sy0">;</span>
           <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> s.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
           <span class="br0">{</span>
                <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> <span class="nu0">26</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
                <span class="br0">{</span> 
                     <span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">==</span> s.<span class="me1">charAt</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span>
                     <span class="br0">{</span>
                         c<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> ch<span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
                          <span class="kw2">break</span><span class="sy0">;</span>
                     <span class="br0">}</span>
                <span class="br0">}</span>
            <span class="br0">}</span>  <span class="kw1">return</span> <span class="br0">(</span>new String<span class="br0">(</span>c<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>   
        public <span class="kw4">static</span> <span class="kw4">void</span> main<span class="br0">(</span>String args<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span>
        <span class="br0">{</span>
             Scanner sc <span class="sy0">=</span> new Scanner<span class="br0">(</span>System.<span class="me1">in</span><span class="br0">)</span><span class="sy0">;</span>
             System.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Enter the message: "</span><span class="br0">)</span><span class="sy0">;</span>
             String en <span class="sy0">=</span> doEncryption<span class="br0">(</span>sc.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">toLowerCase</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
             System.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Encrypted message: "</span> <span class="sy0">+</span> en<span class="br0">)</span><span class="sy0">;</span>
             sc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) Encrypted message: LQFYGXFRKN<br>
b) Encrypted message: NKRFXGYFQL<br>
c) Encrypted message: lqfygxfrkn<br>
d) Encrypted message: nkrfxgyfql<br>
</b></p><i>Answer: a<br>
Explanation: The given code is an example of mono-alphabetic cipher. The code replaces the letters of the input string by corresponding keyboard letters.</i><p><b>11. In which of the following cipher the plain text and the ciphered text does not have same number of letters?<br>
a) keyword cipher<br>
b) vigenere cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher and mono alphabetic cipher the number of letters in the plain text and ciphered text remain same. But in poly alphabetic cipher the number of letters change. So here as vigenere cipher is the only poly alphabetic cipher so it will be the answer. </i><p><b>1. What is the meaning of cipher in cryptography?<br>
a) an algorithm that performs encryption<br>
b) an algorithm that generates a secret code<br>
c) an algorithm that performs encryption or decryption<br>
d) a secret code<br>
</b></p><i>Answer: c<br>
Explanation: Cipher is an algorithm for performing encryption or decryption. In cryptography, a set of defined steps are followed to generate ciphers. These are necessary to prevent data breach.</i><p><b>2. Which of the following ciphers are created by shuffling the letters of a word?<br>
a) rotor cipher<br>
b) rail fence cipher<br>
c) vigenere cipher<br>
d) hill cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of traditional ciphers- Transposition and substitution cipher. In transposition cipher the letters of the given data are shuffled in a particular order, fixed by a given rule. Rail fence cipher is an example of transposition cipher.</i><p><b>3. Which of the following is a type of substitution cipher?<br>
a) poly alphabetic cipher<br>
b) transposition cipher<br>
c) columnar cipher<br>
d) rail fence cipher<br>
</b></p><i>Answer: a<br>
Explanation: In substitution cipher the plain text is replaced by cipher text according to a fixed rule. There are two types of substitution cipher- Mono alphabetic and Poly alphabetic cipher.</i><p><b>4. Which of the following correctly defines poly alphabetic cipher?<br>
a) a substitution based cipher which uses multiple substitution at different positions<br>
b) a substitution based cipher which uses fixed substitution over entire message<br>
c) a transposition based cipher which uses multiple substitution at different positions<br>
d) a transposition based cipher which uses fixed substitution over entire message<br>
</b></p><i>Answer: a<br>
Explanation: Poly alphabetic cipher is a type of substitution cipher. It uses multiple substitution at different positions in order to cipher the plain text.</i><p><b>5. Which of the following is not a type of poly alphabetic cipher?<br>
a) Rotor cipher<br>
b) Hill cipher<br>
c) One time pad cipher<br>
d) Affine cipher<br>
</b></p><i>Answer: d<br>
Explanation: In poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. Out of the given options, only affine cipher is not a poly alphabetic cipher.</i><p><b>6. Which of the following is a type of traditional cipher?<br>
a) transportation cipher<br>
b) transposition cipher<br>
c) transforming cipher<br>
d) translating cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of a traditional cipher. First is transposition cipher and the second is substitution cipher. </i><p><b>8. Which cipher is represented by the following function?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw4">void</span> Cipher<span class="br0">(</span>string msg<span class="sy0">,</span> string key<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="co1">// Get key matrix from the key string </span>
	<span class="kw4">int</span> keyMat<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">;</span> 
	getKeyMatrix<span class="br0">(</span>key<span class="sy0">,</span> keyMat<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw4">int</span> msgVector<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		msgVector<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">(</span>msg<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">65</span><span class="sy0">;</span> 
	<span class="kw4">int</span> cipherMat<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="co1">// Following function generates </span>
	<span class="co1">// the encrypted vector </span>
	encrypt<span class="br0">(</span>cipherMat<span class="sy0">,</span> keyMat<span class="sy0">,</span> msgVector<span class="br0">)</span><span class="sy0">;</span> 
	string CipherText<span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		CipherText <span class="sy0">+=</span> cipherMat<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> <span class="nu0">65</span><span class="sy0">;</span> 	
	cout  <span class="sy0">&lt;&lt;</span> CipherText<span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) vigenere cipher<br>
b) hill cipher<br>
c) keyword cipher<br>
d) rotor cipher<br>
</b></p><i>Answer: a<br>
Explanation: Mono alphabetic ciphers can be decoded by using the method frequency analysis. But in poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. This makes it very difficult to be decoded by using frequency analysis.</i><p><b>9. Which cipher is represented by the following function?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">public class Cipher
<span class="br0">{</span>
    public <span class="kw4">static</span> String encrypt<span class="br0">(</span>String text<span class="sy0">,</span> final String key<span class="br0">)</span>
    <span class="br0">{</span>
        String res <span class="sy0">=</span> <span class="st0">""</span><span class="sy0">;</span>
        text <span class="sy0">=</span> text.<span class="me1">toUpperCase</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> text.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="br0">{</span>
            <span class="kw4">char</span> c <span class="sy0">=</span> text.<span class="me1">charAt</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span> <span class="br0">(</span>c <span class="sy0">&lt;</span> <span class="st0">'A'</span> <span class="sy0">||</span> c <span class="sy0">&gt;</span> <span class="st0">'Z'</span><span class="br0">)</span>
                <span class="kw1">continue</span><span class="sy0">;</span>
            res <span class="sy0">+=</span> <span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span>c <span class="sy0">+</span> key.<span class="me1">charAt</span><span class="br0">(</span>j<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">2</span> <span class="sy0">*</span> <span class="st0">'A'</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">26</span> <span class="sy0">+</span> <span class="st0">'A'</span><span class="br0">)</span><span class="sy0">;</span>
            j <span class="sy0">=</span> <span class="sy0">++</span>j <span class="sy0">%</span> key.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> res<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) vigenere cipher<br>
b) hill cipher<br>
c) keyword cipher<br>
d) rotor cipher<br>
</b></p><i>Answer: b<br>
Explanation: The given function represents hill cipher. It is a type of poly alphabetic substitution which is based on linear algebra. </i><p><b>10. In which of the following cipher the plain text and the ciphered text does not have same number of letters?<br>
a) affine cipher<br>
b) hill cipher<br>
c) columnar cipher<br>
d) additive cipher<br>
</b></p><i>Answer: a<br>
Explanation: The given function represents the function of hill cipher. It is a type of poly alphabetic substitution which makes use of the vigenere table for making substitutions in the plain text.</i><p><b>11. What will be the ciphered text if the string “SANFOUNDRY” is given as input to the code of vigenere cipher with keyword as “HELLO”?<br>
a) UEWIIDKLL<br>
b) ZEYQCOCM<br>
c) ZEYQCBROCM<br>
d) ZEYQCBROCMJDH<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher and mono alphabetic cipher the number of letters remains the same in ciphered and deciphered text. But in poly alphabetic cipher the number of letters are different. So here as hill cipher is the only poly alphabetic cipher so it will be the answer. </i><p><b>12. What will be the ciphered text if the string “HELLO” is given as input to the code of hill cipher with keyword as “SANFOUNDRY”?<br>
a) EZJ<br>
b) JEZ<br>
c) ZEJ<br>
d) JZE<br>
</b></p><i>Answer: c<br>
Explanation: Vigenere cipher is a type of poly alphabetic substitution which uses vigenere table for making substitutions in the plain text. Using the table we find the solution to be ZEYQCBROCM.</i><p><b>1. What is the meaning of cipher in computer terminology?<br>
a) an algorithm that performs encryption<br>
b) an algorithm that generates a secret code<br>
c) an algorithm that performs encryption or decryption<br>
d) a secret code<br>
</b></p><i>Answer: c<br>
Explanation: Cipher can be defined to be an algorithm that performs encryption or decryption. In cryptography, a set of defined steps are followed to generate ciphers.</i><p><b>2. Which of the following cipher is created by shuffling the letters of a word?<br>
a) substitution cipher<br>
b) transposition cipher<br>
c) mono alphabetic cipher<br>
d) poly alphabetic cipher<br>
</b></p><i>Answer: b<br>
Explanation: Types of traditional ciphers- Transposition and substitution cipher. In transposition cipher the letters of the given message are shuffled in a particular order, fixed by a given rule.</i><p><b>3. Which of the following is not a type of transposition cipher?<br>
a) Rail fence cipher<br>
b) Columnar transposition cipher<br>
c) One time pad cipher<br>
d) Route cipher<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options only One time pad cipher is not a type of transposition cipher. It is a type of substitution cipher.</i><p><b>4. Which of the following is not a type of mono alphabetic cipher?<br>
a) additive cipher<br>
b) multiplicative cipher<br>
c) afffine cipher<br>
d) hill cipher<br>
</b></p><i>Answer: d<br>
Explanation: In mono alphabetic cipher each symbol of plain text is replaced by a particular respective symbol in the cipher text. There are three types of mono alphabetic ciphers- additive, multiplicative and affine.</i><p><b>5. Route cipher falls under the category of?<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: c<br>
Explanation: Route cipher is a transposition cipher. It falls under the category of transposition cipher as it encrypts the plain text by rearranging its letters.</i><p><b>6. Which of the following ciphered text would have used transposition cipher for encryption of the plain text “SANFOUNDRY”?<br>
a) SSCMBNUMERY<br>
b) TBMGPVOESZ<br>
c) UCNHQWPFTA<br>
d) SNONRAFUDY<br>
</b></p><i>Answer: d<br>
Explanation: We know that transposition cipher encrypts the plain text by shuffling the letters of the plain text. So out of the given options, only “SNONRAFUDY” has the same set of letters as “SANFOUNDRY”.</i><p><b>7. Which of the following is a type of transposition cipher?<br>
a) Rail Fence cipher<br>
b) Hill cipher<br>
c) Rotor cipher<br>
d) One time pad<br>
</b></p><i>Answer: a<br>
Explanation: In transposition cipher the letters of the given message are shuffled in a particular order, fixed by a given rule. Two types of transposition cipher are – Rail fence cipher and Columnar transposition cipher.</i><p><b>8. In which of the following cipher the plain text and the ciphered text have same set of letters?<br>
a) one time pad cipher<br>
b) columnar transposition cipher<br>
c) playfair cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher, the letters remain same in ciphered and plain text. Their position is only changed whereas in substitution cipher the letters become different in encrypted text. So columnar transposition cipher will be the correct option.</i><p><b>10. What will be the encrypted text corresponding to plain text “SANFOUNDRY” using rail fence cipher with key value given to be 2?<br>
a) SNONRAFUDY<br>
b) SORAFUDYNN<br>
c) SNAUDNORFY<br>
d) SANFOUNDRY<br>
</b></p><i>Answer: a<br>
Explanation: Combining transposition cipher with substitution cipher helps in overcoming its weaknesses. But it causes the cipher to become more laborious to decode and it becomes more prone to errors.</i><p><b>11. What will be the encrypted text corresponding to plain text “SANFOUNDRY” using columnar transposition cipher with the keyword as “GAMES”?<br>
a) SNONRAFUDY<br>
b) SORAFUDYNN<br>
c) SNAUDNORFY<br>
d) ANFRSUNDOY<br>
</b></p><i>Answer: a<br>
Explanation: For encrypting a plain text using rail fence cipher we use a table having a number of rows equal to key value as shown below. Then we read along the rows to get the ciphered text. So the ciphered text will be “SNONRAFUDY”.</i><p><b>1. Which of the following cipher replaces letters with symbols?<br>
a) polybius square ciper<br>
b) affine cipher<br>
c) caesar cipher<br>
d) pigpen cipher<br>
</b></p><i>Answer: d<br>
Explanation: Pigpen cipher encrypts the plain text by replacing each letter with a corresponding symbol. Pigpen cipher is an example of geometric substitution cipher.</i><p><b>2. Which of the following is not an alternative name of pigpen cipher?<br>
a) pen cipher<br>
b) freemason’s cipher<br>
c) napoleon cipher<br>
d) tic-tac-toe cipher<br>
</b></p><i>Answer: a<br>
Explanation: Pigpen cipher is also known by the names like:- freemason’s cipher, napoleon cipher, tic-tac-toe cipher, masonic cipher. It is a cipher which is believed to be used by freemasons in the 18th century.</i><p><b>3. Which of the following cipher was used by freemasons?<br>
a) Vigenere cipher<br>
b) Autokey cipher<br>
c) Pigpen cipher<br>
d) Hill cipher<br>
</b></p><i>Answer: c<br>
Explanation: Pigpen cipher is believed to be used by freemasons in the 18th century. Pigpen cipher is an example of geometric substitution cipher.</i><p><b>4. Choose the weakest cipher from the following?<br>
a) vigenere cipher<br>
b) rail fence cipher<br>
c) hill cipher<br>
d) pigpen cipher<br>
</b></p><i>Answer: d<br>
Explanation: Pigpen cipher is the weakest cipher out of the given options. This is because it is a simple geometric substitution cipher so can be easily cracked using frequency analysis.</i><p><b>5. Which of the following is not a poly alphabetic substitution cipher?<br>
a) vigenere cipher<br>
b) one time pad cipher<br>
c) play fair cipher<br>
d) pigpen cipher<br>
</b></p><i>Answer: d<br>
Explanation: Pigpen cipher is the only non poly alphabetic substitution cipher out of the given options. It is an example of geometric substitution cipher.</i><p><b>6. Pigpen cipher is an example of?<br>
a) Mono alphabetic substitution cipher<br>
b) Transposition cipher<br>
c) Poly alphabetic substitution cipher<br>
d) Geometric substitution cipher<br>
</b></p><i>Answer: a<br>
Explanation: Pigpen cipher encrypts the plain text by replacing each letter with a corresponding symbol. Pigpen cipher is an example of geometric substitution cipher.</i><p><b>9. What will be the ciphered text corresponding to plain text “ACT” if pigpen cipher is used for encryption?<br>
a) _| |_ &gt;<br>
b) |_ &gt; |_<br>
c) _| |_&lt;<br>
d) |_&lt; _|<br>
</b></p><i>Answer: a<br>
Explanation: Vigenere cipher is more secure as compared to pigpen cipher. It is because pigpen cipher is geometric substitution cipher and vigenere cipher is poly alphabetic substitution cipher.</i><p><b>10. What will be the plain text corresponding to ciphered text “|_  _|  &gt;” if pigpen cipher is used for encryption?<br>
a) cat<br>
b) hat<br>
c) dog<br>
d) rat<br>
</b></p><i>Answer: b<br>
Explanation: Pigpen cipher is a very weak cipher as it just replaces letters with corresponding symbols. It can be easily broken using frequency analysis.</i><p><b>11. What is common between affine cipher and pigpen cipher.<br>
a) both are mono alphabetic substitution cipher<br>
b) both are poly alphabetic substitution cipher<br>
c) both can be cracked using frequency analysis<br>
d) both are transposition cipher<br>
</b></p><i>Answer: a<br>
Explanation: Pigpen cipher replaces letters of the plain text with corresponding symbols. These symbols are fragment of a grid.</i><p><b>1. What is the meaning of cipher in cryptography?<br>
a) an algorithm that performs encryption<br>
b) an algorithm that generates a secret code<br>
c) an algorithm that performs encryption or decryption<br>
d) a secret code<br>
</b></p><i>Answer: c<br>
Explanation: Cipher is an algorithm for performing encryption or decryption. In cryptography, a set of defined steps are followed to generate ciphers. These are necessary to prevent data breach.</i><p><b>2. Vigenere cipher is an example of ______________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Vigenere cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitution at different positions in order to cipher the plain text.</i><p><b>3. Encryption in Vigenere cipher is done using _________<br>
a) vigenere formula<br>
b) vigenere cycle<br>
c) vigenere square<br>
d) vigenere addition<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text using vigenre cipher is done by making use of vigenere table. It is also known as vigenere square.</i><p><b>4. Which of the following correctly defines poly alphabetic cipher?<br>
a) a substitution based cipher which uses multiple substitution at different positions<br>
b) a substitution based cipher which uses fixed substitution over entire message<br>
c) a transposition based cipher which uses multiple substitution at different positions<br>
d) a transposition based cipher which uses fixed substitution over entire message<br>
</b></p><i>Answer: a<br>
Explanation: Poly alphabetic cipher is a type of substitution cipher. It uses multiple substitution at different positions in order to cipher the plain text.</i><p><b>5. Which of the following is not a type of poly alphabetic cipher?<br>
a) Rotor cipher<br>
b) Hill cipher<br>
c) One time pad cipher<br>
d) Multiplicative cipher<br>
</b></p><i>Answer:d<br>
Explanation: In poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. Out of the given options only multiplicative cipher is not a poly alphabetic cipher.</i><p><b>6. Vigenere table consists of _________<br>
a) 26 rows and 26 columns<br>
b) 26 rows and 1 column<br>
c) 1 row and 26 columns<br>
d) 27 rows and 27 columns<br>
</b></p><i>Answer: a<br>
Explanation: Encryption of plain text using vigenre cipher is done by making use of vigenere table. It consists of 26 rows and 26 columns which have alphabets written 26 times. These are shifted towards left after each row.</i><p><b>8. What will be the plain text corresponding to cipher text “PROTO” if vigenere cipher is used with keyword as “HELLO”?<br>
a) SANFOUNDRY<br>
b) WORLD<br>
c) INDIA<br>
d) AMERICA<br>
</b></p><i>Answer: a<br>
Explanation: Keyword cipher is less secure than vigenere cipher. It is due to the fact that keyword cipher is mono alphabetic and thus can be cracked using frequency analysis. But vigenere cipher being a poly alphabetic cipher cannot be deciphered using this method. </i><p><b>9. Which cipher is represented by the following function?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1">public class Cipher
<span class="br0">{</span>
    public <span class="kw4">static</span> String encrypt<span class="br0">(</span>String text<span class="sy0">,</span> final String key<span class="br0">)</span>
    <span class="br0">{</span>
        String res <span class="sy0">=</span> <span class="st0">""</span><span class="sy0">;</span>
        text <span class="sy0">=</span> text.<span class="me1">toUpperCase</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> text.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
        <span class="br0">{</span>
            <span class="kw4">char</span> c <span class="sy0">=</span> text.<span class="me1">charAt</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span> <span class="br0">(</span>c <span class="sy0">&lt;</span> <span class="st0">'A'</span> <span class="sy0">||</span> c <span class="sy0">&gt;</span> <span class="st0">'Z'</span><span class="br0">)</span>
                <span class="kw1">continue</span><span class="sy0">;</span>
            res <span class="sy0">+=</span> <span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span> <span class="br0">(</span><span class="br0">(</span>c <span class="sy0">+</span> key.<span class="me1">charAt</span><span class="br0">(</span>j<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">2</span> <span class="sy0">*</span> <span class="st0">'A'</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">26</span> <span class="sy0">+</span> <span class="st0">'A'</span><span class="br0">)</span><span class="sy0">;</span>
            j <span class="sy0">=</span> <span class="sy0">++</span>j <span class="sy0">%</span> key.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> res<span class="sy0">;</span>
    <span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) vigenere cipher<br>
b) hill cipher<br>
c) keyword cipher<br>
d) rotor cipher<br>
</b></p><i>Answer: c<br>
Explanation: Vigenere cipher is a type of poly alphabetic substitution which uses vigenere table for making substitutions in the plain text. Using the table we find the plain text to be “INDIA”.</i><p><b>10. In which of the following cipher the plain text and the ciphered text does not have a same number of letters?<br>
a) affine cipher<br>
b) vigenere cipher<br>
c) columnar cipher<br>
d) additive cipher<br>
</b></p><i>Answer: a<br>
Explanation: The given function represents the function of hill cipher. It is a type of poly alphabetic substitution which makes use of the vigenere table for making substitutions in the plain text.</i><p><b>11. What will be the ciphered text if the string “SANFOUNDRY” is given as input to the code of vigenere cipher with keyword as “HELLO”?<br>
a) UEWIIDKLL<br>
b) ZEYQCOCM<br>
c) ZEYQCBROCM<br>
d) ZEYQCBROCMJDH<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher and mono alphabetic cipher the number of letters remain same in ciphered and deciphered text. But in poly alphabetic cipher the number of letters are different. So here as vigenere cipher is the only poly alphabetic cipher so it will be the answer. </i><p><b>1. Which of the following cipher does not require a key for encrypting plain text?<br>
a) atbash cipher<br>
b) affine cipher<br>
c) playfair cipher<br>
d) vigenere cipher<br>
</b></p><i>Answer: a<br>
Explanation: Out of the given options only atbash cipher does not require a key for encryption. Atbash cipher is an example of a substitution cipher.</i><p><b>2. Atbash cipher was originally used for encrypting _____________<br>
a) english alphabet<br>
b) greek alphabet<br>
c) hebrew alphabet<br>
d) hindi alphabet<br>
</b></p><i>Answer: c<br>
Explanation: Atbash cipher was originally built to encrypt hebrew alphabet. But it can be used to encrypt any type of alphabets.</i><p><b>3. Which of the following cipher is a special case of affine cipher?<br>
a) Vigenere cipher<br>
b) Autokey cipher<br>
c) Atbash cipher<br>
d) Hill cipher<br>
</b></p><i>Answer: c<br>
Explanation: Atbash cipher is a special case of affine cipher. We have to assume a=b=25 as the key in affine cipher to get the same encryption.</i><p><b>4. Choose the weakest cipher from the following?<br>
a) vigenere cipher<br>
b) rail fence cipher<br>
c) hill cipher<br>
d) atbash cipher<br>
</b></p><i>Answer: d<br>
Explanation: Atbash cipher is the weakest cipher out of the given options. This is because it is a simple mono alphabetic substitution cipher with almost no security. It can be cracked without even knowing which technique has been used for encryption.</i><p><b>5. Which of the following is a mono alphabetic substitution cipher?<br>
a) vigenere cipher<br>
b) one time pad cipher<br>
c) play fair cipher<br>
d) atbash cipher<br>
</b></p><i>Answer: d<br>
Explanation: Atbash cipher is the only mono alphabetic substitution cipher out of the given options. All the remaining options fall under the category of poly alphabetic cipher.</i><p><b>7. Atbash cipher is an example of?<br>
a) Mono alphabetic substitution cipher<br>
b) Transposition cipher<br>
c) Poly alphabetic substitution cipher<br>
d) Geometric substitution cipher<br>
</b></p><i>Answer: a<br>
Explanation: Affine cipher is more secure as compared to pigpen cipher. Atbash cipher is a special case of affine cipher and can be cracked without even knowing which technique has been used for encryption. </i><p><b>9. What will be the ciphered text corresponding to plain text “SECRET” if atbash cipher is used for encryption?<br>
a) VHIXVG<br>
b) HVXIVG<br>
c) HXVIVG<br>
d) VIHXIV<br>
</b></p><i>Answer: a<br>
Explanation: Atbash cipher is an example of mono alphabetic substitution cipher. It replaces each alphabet of the plain text with a corresponding letter which we can see in the table below.<p></p>


	

<div class="hk1_style-wrap5"><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="text"><pre class="de1">A - Z	  J - Q	    S - H
B - Y	  K - P	    T - G
C - X	  L - O	    U - F
D - W	  M - N	    V - E
E - V	  N - M	    W - D
F - U	  O - L	    X - C
G - T	  P - K	    Y - B
H - S	  Q - J	    Z - A
I - R	  R - I</pre></div></div></div></div></div></div></div>


</i><p><b>10. What will be the plain text corresponding to ciphered text “MAO” if atbash cipher is used for encryption?<br>
a) NZL<br>
b) IND<br>
c) AUS<br>
d) ENG<br>
</b></p><i>Answer: b<br>
Explanation: Atbash cipher is a very weak cipher. It can be easily broken without even knowing the exact technique which has been used for encryption. We can just assume the ciphered text to be a substitution cipher in order to crack it.</i><p><b>11. Which of the following is not true about atbash cipher?<br>
a) it is a mono alphabetic substitution cipher<br>
b) it can only be used to encrypt hebrew alphabet<br>
c) it is a special case of affine cipher<br>
d) it is weaker than playfair cipher<br>
</b></p><i>Answer: b<br>
Explanation: Atbash cipher replaces each alphabet of the plain text with a corresponding letter which we can see in the table below.<p></p>


<div class="hk1_style-wrap5"><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="text"><pre class="de1">A - Z	  J - Q	    S - H
B - Y	  K - P	    T - G
C - X	  L - O	    U - F
D - W	  M - N	    V - E
E - V	  N - M	    W - D
F - U	  O - L	    X - C
G - T	  P - K	    Y - B
H - S	  Q - J	    Z - A
I - R	  R - I</pre></div></div></div></div></div></div></div>


<p>So the ciphered text would be “HVXIVG”.</p></i><p><b>1. Gronsfeld cipher is an example of _____________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Gronsfeld cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>2. Which of the following is true about encryption in gronsfeld cipher?<br>
a) It replaces letters with numbers<br>
b) It shifts the letters of plain text on the basis of key value<br>
c) It makes substitutions by using tabula recta<br>
d) It makes substitutions on the basis of a mathematical formula<br>
</b></p><i>Answer: b<br>
Explanation: Encryption of plain text in gronsfeld cipher is done by shifting the letters of plain text on the basis of key value. So it is similar to caesar cipher.</i><p><b>3. Gronsfeld cipher is similar to?<br>
a) additive cipher<br>
b) multiplicative cipher<br>
c) caesar cipher<br>
d) affine cipher<br>
</b></p><i>Answer: c<br>
Explanation: In gronsfeld cipher we shift the letters of the plain text on the basis of the key value. So it becomes a modified version of the caesar cipher.</i><p><b>4. Which of the following cipher uses a numeric key?<br>
a) gronsfeld cipher<br>
b) vigenere cipher<br>
c) trithemius cipher<br>
d) running key cipher<br>
</b></p><i>Answer: a<br>
Explanation: Gronsfeld cipher is a variation of vigenere cipher. The difference is that vigenere cipher uses an alphabetical key whereas gronsfeld cipher uses numeric key.</i><p><b>5. Which of the following cipher does not require the use of tabula recta?<br>
a) running key cipher<br>
b) vigenere cipher<br>
c) gronsfeld cipher<br>
d) trithemius cipher<br>
</b></p><i>Answer: c<br>
Explanation: Ciphers like running key cipher, vigenere cipher, trithemius cipher etc. makes use of tabula recta. Whereas gronsfeld cipher does not require tabula recta for encryption of plain text.</i><p><b>6. Gronsfeld cipher is a variation of ____________<br>
a) autokey cipher<br>
b) vigenere cipher<br>
c) hill cipher<br>
d) route cipher<br>
</b></p><i>Answer: b<br>
Explanation: Gronsfeld cipher is a variation of vigenere cipher. The difference is that vigenere cipher uses an alphabetical key whereas the key of gronsfeld cipher consists of numbers.</i><p><b>8. What will be the plain text corresponding to cipher text “EETPEG” if gronsfeld cipher is used with key “4321”?<br>
a) ABACUS<br>
b) ABROAD<br>
c) ABRUPT<br>
d) ABUSED<br>
</b></p><i>Answer: a<br>
Explanation: In gronsfeld cipher we shift the letters of the plain text on the basis of the key value. So it becomes a more complex version of the caesar cipher and thus harder to crack.</i><p><b>10. Which of the following is not a transposition cipher?<br>
a) rail fence cipher<br>
b) gronsfeld cipher<br>
c) hill cipher<br>
d) route cipher<br>
</b></p><i>Answer: b<br>
Explanation: Encryption in gronsfeld cipher takes place by shifting the letters of the plain text by a number given by the numeric key. So by applying the reverse of this method, we get the deciphered text to be “ABROAD”.</i><p><b>11. What will be the ciphered text corresponding to “SANFOUNDRY” if gronsfeld cipher is used for encryption with key as “1234”?<br>
a) TCQJPWQHSA<br>
b) TCQJTAULAI<br>
c) TCQJOUNDRY<br>
d) UETNQYTLTC<br>
</b></p><i>Answer: a<br>
Explanation: Gronsfeld cipher is a type of substitution cipher. It is a variation of vigenere cipher.</i><p><b>12. What will be the ciphered text corresponding to “ALGORITHM” if gronsfeld cipher is used for encryption with key “4321”?<br>
a) BNJSSKWLN<br>
b) EOIPVLVIQ<br>
c) BNJSRITHM<br>
d) EOIPRITHM<br>
</b></p><i>Answer: b<br>
Explanation: Rail fence, hill and route cipher are examples of transposition cipher. Gronsfeld cipher is a substitution cipher and so is the correct option.</i><p><b>13. What will be the plain text corresponding to cipher text “SCEFJV” if gronsfeld cipher is used with key “1234”?<br>
a) RABBIT<br>
b) RUSSIA<br>
c) RANGER<br>
d) FRIEND<br>
</b></p><i>Answer: a<br>
Explanation: Encryption in gronsfeld cipher takes place by shifting the letters of the plain text by a number given by the numeric key. So by applying this method, we get the ciphered text to be “TCQJPWQHSA”.</i><p><b>1. Beaufort cipher is an example of ____________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Beaufort cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>2. Encryption in beaufort cipher is done using ____________<br>
a) trithemius table<br>
b) vigenere cycle<br>
c) tabula recta<br>
d) four square table<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text in beaufort cipher is done by making use of tabula recta. The same table is also used for encryption in vigenere cipher and running key cipher.</i><p><b>3. Which of the following is reciprocal cipher?<br>
a) vigenere cipher<br>
b) autokey cipher<br>
c) running key cipher<br>
d) beaufort cipher<br>
</b></p><i>Answer: d<br>
Explanation: A reciprocal cipher is a cipher in which if we try to encrypt the cipher text (using the same cipher) then we gets the plain text as a result. In other words, the process of decryption and encryption is exactly the same.</i><p><b>4. Which of the following is a difference between beaufort cipher and vigenere cipher?<br>
a) they use different tables for encryption<br>
b) vigenere cipher is poly alphabetic whereas beaufort cipher is mono alphabetic<br>
c) vigenere cipher uses a key whereas no key is required for using beaufort cipher<br>
d) they use the same table for encryption, but in a different manner<br>
</b></p><i>Answer: d<br>
Explanation: Beaufort cipher is a variation of vigenere cipher. They use the same table i.e. tabula recta for encryption but the table is used in a different manner.</i><p><b>5. Beaufort cipher is a variant of ____________<br>
a) autokey cipher<br>
b) vigenere cipher<br>
c) hill cipher<br>
d) route cipher<br>
</b></p><i>Answer: b<br>
Explanation: Beaufort cipher is a variant of vigenere cipher. The difference is that beaufort cipher uses tabula recta in a different manner for encryption.</i><p><b>7. What will be the plain text corresponding to cipher text “SEDGKG” if beaufort cipher is used with key as “KEY”?<br>
a) PRISON<br>
b) DEATHS<br>
c) SAVEUS<br>
d) ABUSED<br>
</b></p><i>Answer: a<br>
Explanation: Beaufort cipher is an example of reciprocal cipher. So that is why the process of decryption is exactly same as that of encryption in beaufort cipher.</i><p><b>9. What will be the ciphered text corresponding to “SANFOUNDRY” if beaufort cipher is used for encryption with key as “KEY”?<br>
a) SBPISZTKZH<br>
b) TCQJTAULAI<br>
c) SELFQEXBHM<br>
d) SPBISZKTZH<br>
</b></p><i>Answer: c<br>
Explanation: The process of decryption and encryption are exactly the same in beaufort cipher. So the corresponding plain text would be “SAVEUS”.</i><p><b>10. What will be the ciphered text corresponding to “ALGORITHM” if beaufort cipher is used for encryption with key as “KEY”?<br>
a) BNJSWOAPV<br>
b) KTSWNQRXM<br>
c) AMIRVNZOU<br>
d) MBPHJSNIU<br>
</b></p><i>Answer: b<br>
Explanation: Beaufort cipher is different from variant beaufort cipher. Variant beaufort cipher is a variant of beaufort cipher.</i><p><b>1. What is the meaning of cipher in cryptography?<br>
a) an algorithm that performs encryption<br>
b) an algorithm that generates a secret code<br>
c) an algorithm that performs encryption or decryption<br>
d) a secret code<br>
</b></p><i>Answer: c<br>
Explanation: Cipher is an algorithm for performing encryption or decryption. In cryptography, a set of defined steps are followed to generate ciphers. These are necessary to prevent a data breach.</i><p><b>2. Autokey cipher is an example of ___________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Autokey cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>3. Encryption in Autokey cipher is done using ___________<br>
a) vigenere formula<br>
b) vigenere cycle<br>
c) vigenere table<br>
d) vigenere addition<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text in Autokey cipher is done using the same table which is used for encryption in vigenere cipher. It is known as vigenere table.</i><p><b>4. Which of the following correctly defines poly alphabetic cipher?<br>
a) a substitution based cipher which uses multiple substitution at different positions<br>
b) a substitution based cipher which uses fixed substitution over entire message<br>
c) a transposition based cipher which uses multiple substitution at different positions<br>
d) a transposition based cipher which uses fixed substitution over entire message<br>
</b></p><i>Answer: a<br>
Explanation: Poly alphabetic cipher is a type of substitution cipher. It uses multiple substitution at different positions in order to cipher the plain text.</i><p><b>5. Which of the following is not a type of poly alphabetic cipher?<br>
a) Autokey cipher<br>
b) Hill cipher<br>
c) One time pad cipher<br>
d) Additive cipher<br>
</b></p><i>Answer: d<br>
Explanation: In poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. Out of the given options only additive cipher is not a poly alphabetic cipher.</i><p><b>6. Autokey cipher is closely related to ___________<br>
a) Vigenere cipher<br>
b) Hill cipher<br>
c) Play fair cipher<br>
d) Rotor cipher<br>
</b></p><i>Answer: a<br>
Explanation: Autokey cipher like vigenere cipher uses vigenere table in order to encrypt the plain text. The difference in these cipher is the usage of the keyword.</i><p><b>8. What will be the plain text corresponding to cipher text “ZEYQC” if autokey cipher is used with keyword as “SANFOUNDRY”?<br>
a) INDIA<br>
b) WORLD<br>
c) HELLO<br>
d) SECRET<br>
</b></p><i>Answer: a<br>
Explanation: Keyword cipher is less secure than Autokey cipher. It is due to the fact that keyword cipher is mono alphabetic and thus can be cracked using frequency analysis. But Autokey cipher being a poly alphabetic cipher cannot be cracked using this method. </i><p><b>9. Autokey cipher is also known as?<br>
a) vigenere cipher<br>
b) autoclave cipher<br>
c) auto key cipher<br>
d) auto cipher<br>
</b></p><i>Answer: c<br>
Explanation: Autokey cipher is a type of poly alphabetic substitution which uses vigenere table for making substitutions in the plain text after generating key using plain text. Using the table we find the plain text to be “HELLO”.</i><p><b>10. In which of the following cipher the plain text and the ciphered text does not have same number of letters?<br>
a) affine cipher<br>
b) autokey cipher<br>
c) columnar cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Autoclave cipher is an alternative name given to autokey cipher. It is because the encrypted text is formed using a key that is generated from a message(plain text) itself.</i><p><b>11. What will be the ciphered text if the string “SECRET” is given as input to the code of autokey cipher with keyword as “SANFOUNDRY”?<br>
a) KEPWSN<br>
b) EKWPSN<br>
c) EKWPSNFDED<br>
d) KEPWSNFDED<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher and mono alphabetic cipher the number of letters remain same in ciphered and deciphered text. But in poly alphabetic cipher the number of letters are different. So here as autokey cipher is the only poly alphabetic cipher so it will be the answer. </i><p><b>1. What is the alternative name of playfair cipher?<br>
a) Wadsworth’s cipher<br>
b) Wheatstone playfair cipher<br>
c) Playfair rectangle<br>
d) Wheatstone cipher<br>
</b></p><i>Answer: b<br>
Explanation: Playfair cipher is also known by the name of Wheatstone playfair cipher. It is because it was discovered by Charles Wheatstone but was promoted by Lord Playfair. </i><p><b>2. Playfair cipher is an example of __________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Playfair cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitution at different positions in order to cipher the plain text.</i><p><b>3. Encryption in Autokey cipher is done using __________<br>
a) a 5×5 table<br>
b) a 13×2 table<br>
c) vigenere table<br>
d) a 6×6 table<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text in playfair cipher is done using a 5×5 table. In this table, all the alphabets of the keyword are arranged row wise by eliminating any duplicates then the remaining letters of the alphabet are placed. One of the alphabet has to be omitted in order to fit all the alphabets in the table.</i><p><b>4. Which of the following correctly defines poly graphic substitution cipher?<br>
a) a substitution based cipher which uses multiple substitutions at different positions<br>
b) a substitution based cipher which uses fixed substitution over entire plain text<br>
c) a substitution based cipher in which substitution is performed over a block of letters<br>
d) a transposition based cipher which uses fixed substitution over entire plain text<br>
</b></p><i>Answer: c<br>
Explanation: Poly graphic cipher is a type of substitution cipher in which substitution is performed over a block of letters. Playfair cipher is an example of poly graphic cipher.</i><p><b>5. Which of the following was the first diagram substitution cipher?<br>
a) autokey cipher<br>
b) hill cipher<br>
c) one time pad cipher<br>
d) playfair cipher<br>
</b></p><i>Answer: d<br>
Explanation: Poly graphic cipher is a type of substitution cipher in which substitution is performed over a block of letters. In diagram substitution, two adjacent letters are substituted simultaneously. Playfair cipher was the first diagram substitution cipher. </i><p><b>6. Which of the following is hardest to break using frequency analysis?<br>
a) Vigenere cipher<br>
b) Autokey cipher<br>
c) Playfair cipher<br>
d) Rotor cipher<br>
</b></p><i>Answer: c<br>
Explanation: Out of the given options playfair cipher is the hardest cipher to break using frequency analysis. It is because it does not substitute letters of the word individually but it encrypts them in pairs of two.</i><p><b>8. What will be the plain text corresponding to cipher text “BPKYFS” if playfair cipher is used with keyword as “SECRET” (assuming j is combined with i)?<br>
a) INDIAN<br>
b) WORLD<br>
c) DOLLAR<br>
d) HELLO<br>
</b></p><i>Answer: a<br>
Explanation: Keyword cipher is less secure than playfair cipher. It is due to the fact that keyword cipher is mono alphabetic and thus can be cracked using frequency analysis. But playfair cipher being a poly graphic substitution cipher is harder to break using this method.</i><p><b>9. What is the rule for encryption in playfair cipher if the letters in a pair are identical?<br>
a) then that pair is neglected<br>
b) a null is added in between the letters<br>
c) one of the identical letter is replaced by some other letter<br>
d) then both of the letters are replaced by the letter appearing just next in the row<br>
</b></p><i>Answer: c<br>
Explanation: To decrypt the message we follow the reverse procedure. The table is formed in the same manner. Applying this we get the plain text to be “DOLLAR”.</i><p><b>10. What is the rule for encryption in playfair cipher if the letters in a pair appear in same row?<br>
a) they are replaced by the letter appearing immediately below them respectively<br>
b) they are replaced by the letter appearing immediately right to them respectively<br>
c) they are replaced by the letter at the corner of the row<br>
d) that pair is neglected<br>
</b></p><i>Answer: b<br>
Explanation: In playfair cipher if the letters in a pair are identical then a null is added in between the letters. Any letter can be used as a null as long as that letter is not the one being repeated.</i><p><b>11. What will be the ciphered text if the string “SANFOUNDRY” is given as input to the code of playfair cipher with keyword as “SECRET” (assuming j is combined with i)?<br>
a) ZHQAPNPAFR<br>
b) AHQAPNPAFR<br>
c) HAQAPNPAFR<br>
d) QHAAPNPAFR<br>
</b></p><i>Answer: b<br>
Explanation: If the letters in a pair appear in same row then they are replaced by the letters appearing immediately right to them respectively. If the element to be replaced appears at the corner of the row then we wrap around to the left side of that row.</i><p><b>12. What is the rule for encryption in playfair cipher if the letters in a pair appear in same column?<br>
a) they are replaced by the letter appearing immediately below them respectively<br>
b) they are replaced by the letter appearing immediately right to them respectively<br>
c) they are replaced by the letters at the corner of the row<br>
d) that pair is neglected<br>
</b></p><i>Answer: b<br>
Explanation: For encrypting the plain text using playfair cipher we use a 5×5 table that is constructed by using keyword. Then we apply rules for encryption in order to get the ciphered text. Table is given as under-<p></p>
<pre>S E C R T
A B D F G
H I K L M
N O P Q U
V W X Y Z</pre>
</i><p><b>13. What is the rule for encryption in playfair cipher if the letters in a pair does not appear in same row or column?<br>
a) they are replaced by the letter appearing immediately below them respectively<br>
b) they are replaced by the letter appearing immediately right to them respectively<br>
c) they are replaced by the letter of the same row at the corner of the rectangle defined by the original pair respectively<br>
d) that pair is neglected<br>
</b></p><i>Answer: a<br>
Explanation: If the letters in a pair appear in the same column then they are replaced by the letters appearing immediately below them respectively. If the element to be replaced appears at the corner of the column then we wrap around to the top side of that column.</i><p><b>1. Hill cipher requires prerequisite knowledge of?<br>
a) integration<br>
b) differentiation<br>
c) matrix algebra<br>
d) differential equation<br>
</b></p><i>Answer: c<br>
Explanation: Hill cipher uses matrix multiplication in order to encrypt the given plain text. So it requires prerequisite knowledge of matrix algebra.</i><p><b>2. Hill cipher is an example of ____________<br>
a) mono-alphabetic cipher<br>
b) substitution cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Hill cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>3. Encryption in hill cipher is done using ______________<br>
a) matrix multiplication<br>
b) a 5×5 table<br>
c) vigenere table<br>
d) matrix inversion<br>
</b></p><i>Answer: a<br>
Explanation: Encryption of plain text in playfair cipher is done using matrix multiplication. Then modulo 26 of the resulting matrix is taken so as to get the ciphered text.</i><p><b>4. What is poly graphic substitution cipher?<br>
a) a substitution based cipher which uses multiple substitutions at different positions<br>
b) a substitution based cipher which uses fixed substitution over entire plain text<br>
c) a substitution based cipher in which substitution is performed over a block of letters<br>
d) a transposition based cipher which uses fixed substitution over entire plain text<br>
</b></p><i>Answer: c<br>
Explanation: Poly graphic cipher is a type of substitution cipher in which substitution is performed over a block of letters. Hill cipher is an example of poly graphic cipher.</i><p><b>5. Which of the following was the first poly graphic cipher to be able to operate on more than 3 letters at once?<br>
a) autokey cipher<br>
b) hill cipher<br>
c) one time pad cipher<br>
d) playfair cipher<br>
</b></p><i>Answer:b<br>
Explanation: Poly graphic cipher is a type of substitution cipher in which substitution is performed over a block of letters. Hill cipher was the first poly graphic cipher to be able to operate on more than 3 letters at once.</i><p><b>6. Which of the following is hardest to break using frequency analysis?<br>
a) Vigenere cipher<br>
b) Hill cipher<br>
c) Caesar cipher<br>
d) Affine cipher<br>
</b></p><i>Answer: b<br>
Explanation: Out of the given options hill cipher is the hardest cipher to break using frequency analysis. Although it is quite vulnerable to other forms of attack. </i><p><b>8. What will be the plain text corresponding to cipher text “YGQ“ if hill cipher is used with keyword as “GYBNQKURP”?<br>
a) SECRET<br>
b) WORLD<br>
c) DOLLAR<br>
d) HELLO<br>
</b></p><i>Answer: b<br>
Explanation: Both hill cipher and playfair cipher are less vulnerable to frequency analysis. But hill cipher is quite vulnerable to other forms of attack and thus less secure than playfair cipher.</i><p><b>9. What will be the size of a key matrix if the plain text is “SECRET”?<br>
a) 1×6<br>
b) 5×1<br>
c) 6×1<br>
d) 6×6<br>
</b></p><i>Answer: a<br>
Explanation: To decrypt the message we follow the reverse procedure. We first find the inverse of the keyword matrix then multiply it with cipher matrix.</i><p><b>10. A key matrix used for encryption in hill cipher must be?<br>
a) invertible matrix<br>
b) non invertible matrix<br>
c) square matrix<br>
d) rectangular matrix<br>
</b></p><i>Answer: d<br>
Explanation: Hill cipher uses a n x n matrix in order to cipher the plain text. In this case n=6 so a 6×6 matrix will be used.</i><p><b>11. What will be the ciphered text if the plain text “SAN” is encrypted using hill cipher with keyword as “GYBNQKURP”?<br>
a) RAJ<br>
b) JAR<br>
c) ARJ<br>
d) AJR<br>
</b></p><i>Answer: a<br>
Explanation: A key matrix used for encryption in hill cipher must be invertible matrix. Otherwise it will be impossible to decipher the message.</i><p><b>1. What is the alternative name given to Rail fence cipher?<br>
a) random cipher<br>
b) matrix cipher<br>
c) zig zag cipher<br>
d) columnar cipher<br>
</b></p><i>Answer: c<br>
Explanation: Rail fence cipher is also known as zig zag cipher. It is so because the plain text gets ciphered by arranging the letters in a zig zag fashion.</i><p><b>2. Rail fence cipher is an example of ___________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: c<br>
Explanation: Rail fence cipher is a transposition cipher. It falls under the category of transposition cipher as it encrypts the plain text by rearranging its letters.</i><p><b>3. Encryption in Rail fence cipher is done using _____________<br>
a) by arranging the letters in a zig zag fashion in a table<br>
b) by randomly arranging letters<br>
c) by arranging letters in vigenere table<br>
d) by swapping adjacent letters<br>
</b></p><i>Answer: a<br>
Explanation: Rail fence cipher is a transposition cipher. It encrypts a given plain text by arranging the letters in a zig zag fashion in a table.</i><p><b>4. Which of the following ciphers are created by shuffling the letters of a word?<br>
a) substitution cipher<br>
b) transposition cipher<br>
c) vigenere cipher<br>
d) hill cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of traditional ciphers- Transposition and substitution cipher. In transposition cipher the letters of the given data are shuffled in a particular order, fixed by a given rule.</i><p><b>5. Which of the following is not a type of poly alphabetic cipher?<br>
a) Autokey cipher<br>
b) Hill cipher<br>
c) One time pad cipher<br>
d) Additive cipher<br>
</b></p><i>Answer:d<br>
Explanation: In poly alphabetic cipher each symbol of plain text is replaced by a different cipher text regardless of its occurrence. Out of the given options, only additive cipher is not a poly alphabetic cipher.</i><p><b>6. Which of the following is are two types of traditional cipher?<br>
a) transposition cipher and replacement cipher<br>
b) transposition cipher and substitution cipher<br>
c) transforming cipher and substitution cipher<br>
d) transforming cipher and replacement cipher<br>
</b></p><i>Answer: b<br>
Explanation: There are two types of a traditional cipher. First is transposition cipher and the second is substitution cipher.</i><p><b>8. What will be the plain text corresponding to cipher text “SCSEMG” if rail fence cipher is used with key value 2?<br>
a) MSGSEC<br>
b) SECMSG<br>
c) GSMSEC<br>
d) SECGSM<br>
</b></p><i>Answer: b<br>
Explanation: The number of columns in the table of rail fence cipher is always equal to the number of letters in the plain text. It is independent of the given key value.</i><p><b>10. In which of the following cipher the plain text and the ciphered text have same letters?<br>
a) autokey cipher<br>
b) rail fence cipher<br>
c) vigenere cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: For decryption we reverse the process used in encryption.<p></p>
<table border="0" style="width:100%;text-align:center">
<tbody><tr>
<td>S</td>
<td> </td>
<td>C</td>
<td> </td>
<td>S</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>E</td>
<td> </td>
<td>M</td>
<td> </td>
<td>G</td>
</tr>
</tbody></table>
<p>So the resulting plain text is “SECMSG”.</p></i><p><b>11. What will be the ciphered text if rail fence cipher is used for encrypting the plain text “SANFOUNDRY” with the key value given to be 2?<br>
a) SNONRAFUDY<br>
b) SORAFUDYNN<br>
c) SNAUDNORFY<br>
d) SANFOUNDRY<br>
</b></p><i>Answer: b<br>
Explanation: One time pad cipher is one of the most secure traditional cipher as it is almost impossible to crack. Rail fence cipher is not very hard to crack. Thus rail fence cipher is less secure than one time pad cipher.</i><p><b>1. What is route cipher?<br>
a) a transposition cipher that performs encryption by following an imaginary pattern on a grid<br>
b) a substitution cipher that performs encryption by following an imaginary pattern on a grid<br>
c) a transposition cipher that performs encryption by following a zig zag pattern on a grid<br>
d) a substitution cipher that performs encryption by following a zig zag pattern on a grid<br>
</b></p><i>Answer: a<br>
Explanation: Route cipher is a transposition cipher. It encrypts the plain text by following an imaginary pattern on a grid. This pattern can vary from one version of route cipher to others.</i><p><b>2. Route cipher is an example of ____________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: c<br>
Explanation: Route cipher is a transposition cipher. It falls under the category of transposition cipher as it encrypts the plain text by rearranging its letters.</i><p><b>3. Encryption in Route cipher is done ___________<br>
a) by arranging the letters in a zig zag fashion in a table<br>
b) by randomly arranging letters<br>
c) by following an imaginary pattern drawn on a grid<br>
d) by swapping adjacent letters<br>
</b></p><i>Answer: c<br>
Explanation: Route cipher is a transposition cipher. It encrypts the plain text by following an imaginary pattern on a grid. </i><p><b>4. Which of the following ciphers are created by shuffling the letters of a word?<br>
a) playfair cipher<br>
b) route cipher<br>
c) vigenere cipher<br>
d) hill cipher<br>
</b></p><i>Answer: b<br>
Explanation: In transposition cipher the letters of the given data are shuffled in a particular order, fixed by a given rule. Route cipher is the only transposition cipher out of the given options.</i><p><b>5. Route cipher is closely related to?<br>
a) Autokey cipher<br>
b) Hill cipher<br>
c) Rail fence cipher<br>
d) Columnar transposition cipher<br>
</b></p><i>Answer: c<br>
Explanation: Route cipher is closely related to rail fence cipher. In rail fence cipher the plain text is written in a zig zag fashion in a grid whereas in route cipher the plain text is written horizontally.</i><p><b>8. What will be the plain text corresponding to cipher text “RSEADC” if with the number of columns are given to be 3 and route of reading is down the columns?<br>
a) SACRED<br>
b) DERSAC<br>
c) REDSAC<br>
d) SEDRAC<br>
</b></p><i>Answer: b<br>
Explanation: Rail fence is cipher is less secure than route cipher. It is because the key of route cipher not only defines the size of the grid but also the path that is to be followed.</i><p><b>9. What will be the plain text corresponding to cipher text “SFNUFACT” if with number of columns are given to be 3 and route of reading is from the bottom right anti clockwise?<br>
a) FACTSFUN<br>
b) FACTFUNS<br>
c) FUNSFACT<br>
d) FUNFACTS<br>
</b></p><i>Answer: b<br>
Explanation: The key of route cipher not only defines the size of grid but also the path that is to be followed. So longer the message is, the harder it becomes to guess the path.</i><p><b>10. What will be the ciphered text if route cipher is used for encrypting the plain text “SANFOUNDRY” with number of columns given to be 5 and route from the bottom right anti clockwise?<br>
a) SUANNDFROY<br>
b) SORAFUDYNN<br>
c) YOFNASUNDRY<br>
d) SANFOUNDRY<br>
</b></p><i>Answer: c<br>
Explanation: For decryption we reverse the process used in encryption. So we arrange the letters of cipher text down the columns and then read the grid horizontally.<p></p>
<table border="0" style="width:50%;text-align:center">
<tbody><tr>
<td>R</td>
<td>E</td>
<td>D</td>
</tr>
<tr>
<td>S</td>
<td>A</td>
<td>C</td>
</tr>
</tbody></table>
<p>So the resulting plain text is “REDSAC”.</p></i><p><b>11. What will be the ciphered text if route cipher is used for encrypting the plain text “SANFOUNDRY” with a number of columns given to be 5 and route of reading is down the columns?<br>
a) SUANNDFROY<br>
b) SORAFUDYNN<br>
c) SNAUDNORFY<br>
d) SANFOUNDRY<br>
</b></p><i>Answer: d<br>
Explanation: For decryption we reverse the process used in encryption. So we arrange the letters of cipher text from bottom right anti clockwise and then read the grid horizontally.<p></p>
<table border="0" style="width:50%;text-align:center">
<tbody><tr>
<td>F</td>
<td>U</td>
<td>N</td>
<td>F</td>
</tr>
<tr>
<td>A</td>
<td>C</td>
<td>T</td>
<td>S</td>
</tr>
</tbody></table>
<p>So the resulting plain text is “FUNFACTS”.</p></i><p><b>1. Trithemius cipher is an example of ________________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Trithemius cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>2. Encryption in trithemius cipher is done using _______________<br>
a) trithemius table<br>
b) vigenere cycle<br>
c) tabula recta<br>
d) any table provided by the person performing the encryption<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text in trithemius cipher is done by making use of tabula recta. The same table is also used for encryption in vigenere cipher and running key cipher.</i><p><b>3. Which of the following is a modified version of Caesar cipher?<br>
a) vigenere cipher<br>
b) autokey cipher<br>
c) running key cipher<br>
d) trithemius cipher<br>
</b></p><i>Answer: d<br>
Explanation: If in caesar cipher we consider a shift that increases by 1 by each letter starting at 0 then it is equivalent to trithemius cipher. So trithemius cipher is a special case of caesar cipher.</i><p><b>4. Which of the following is a difference between trithemius cipher and vigenere cipher?<br>
a) they use different tables for encryption<br>
b) vigenere cipher is poly alphabetic whereas running key cipher is mono alphabetic<br>
c) vigenere cipher uses a key whereas no key is required for using trithemius cipher<br>
d) vigenere cipher is substitution cipher whereas trithemius cipher is transposition cipher<br>
</b></p><i>Answer: c<br>
Explanation: Trithemius cipher is a special case of vigenere cipher. The difference is that vigenere cipher uses a different key every time but a fixed key is used by trithemius cipher.</i><p><b>5. Which of the following cipher require the use of tabula recta?<br>
a) hill cipher<br>
b) route cipher<br>
c) rail fence cipher<br>
d) trithemius cipher<br>
</b></p><i>Answer: d<br>
Explanation: Ciphers like running key cipher, vigenere cipher, trithemius cipher, etc. makes use of tabula recta. Whereas hill cipher, rail fence cipher and route cipher does not require tabula recta for encryption of plain text.</i><p><b>6. Trithemius cipher is a special case of _______________<br>
a) autokey cipher<br>
b) vigenere cipher<br>
c) hill cipher<br>
d) route cipher<br>
</b></p><i>Answer: b<br>
Explanation: Trithemius cipher is a special case of vigenere cipher. The difference is that vigenere cipher uses a different key every time but a fixed key is used by trithemius cipher.</i><p><b>8. What will be the plain text corresponding to cipher text “ACCFYX” if trithemius cipher is used?<br>
a) ABACUS<br>
b) ABROAD<br>
c) ABRUPT<br>
d) ABUSED<br>
</b></p><i>Answer: b<br>
Explanation: Trithemius cipher is a special case of vigenere cipher with ABCDEFGHIJKLMNOPQRSTUVWXYZ as key. So trithemius cipher is easier to crack as the key being used remains same every time.</i><p><b>10. Which of the following cipher is easiest to crack?<br>
a) vigenere cipher<br>
b) running key cipher<br>
c) trithemius cipher<br>
d) all are equally secure<br>
</b></p><i>Answer: a<br>
Explanation: Running key cipher is a type of poly alphabetic substitution which uses tabula recta for making substitutions in the plain text. Using the table and key as ABCDEFGHIJKLMNOPQRSTUVWXYZ we find the plain text to be “ABACUS”.</i><p><b>11. What will be the ciphered text corresponding to “SANFOUNDRY” if trithemius cipher is used for encryption?<br>
a) SBPISZTKZH<br>
b) TCQJTAULAI<br>
c) TBOGPVOESZ<br>
d) SPBISZKTZH<br>
</b></p><i>Answer: a<br>
Explanation: Trithemius cipher uses a more complex version of caesar cipher. So trithemius cipher is harder to crack as compared to caesar cipher.</i><p><b>12. What will be the ciphered text corresponding to “ALGORITHM” if trithemius cipher is used for encryption?<br>
a) BNJSWOAPV<br>
b) BMHPSJUIN<br>
c) AMIRVNZOU<br>
d) MBPHJSNIU<br>
</b></p><i>Answer: c<br>
Explanation: Trithemius cipher is a special case of vigenere cipher and running key cipher is a variation of vigenere cipher. If one figures out that the cipher being used is trithemius then it is very easy to crack, unlike running key and vigenere ciphers as these use a secret key for encryption.</i><p><b>13. What will be the plain text corresponding to cipher text “RVUVMF” if trithemius cipher is used?<br>
a) RABBIT<br>
b) RUSSIA<br>
c) RANGER<br>
d) FRIEND<br>
</b></p><i>Answer: a<br>
Explanation: Encryption in trithemius cipher takes place exactly as in vigenere cipher if we consider the key to be ABCDEFGHIJKLMNOPQRSTUVWXYZ. So by using the tabula recta we can find the encrypted text which is “SBPISZTKZH”.</i><p><b>1. Polybius square is also known by the name of?<br>
a) Polybius checkboard<br>
b) Polybius table<br>
c) Ploybius board<br>
d) Ploybius keypad<br>
</b></p><i>Answer: a<br>
Explanation: Polybius square is similar to substitution cipher. It is also known by the name of Polybius checkboard.</i><p><b>2. How many keys are required for encryption and decryption of data when we use asymmetric cipher?<br>
a) 0<br>
b) 1<br>
c) 2<br>
d) 3<br>
</b></p><i>Answer: c<br>
Explanation: Asymmetric cipher makes use of 2 keys for the purpose of encryption. One is known as public key whereas other is called private key.</i><p><b>3. Which of the following is made possible by the use of Polybius square?<br>
a) To represent the plain text by smaller set of symbols<br>
b) To represent the plain text by larger set of symbols<br>
c) To represent the plain text by the letters of some other language<br>
d) To represent the plain text by the same set of symbols<br>
</b></p><i>Answer: a<br>
Explanation: Polybius square is similar to substitution cipher. Polybius square allows us to cipher the plain text in such a way that a minimum number of symbols are used in the encrypted text.</i><p><b>4. What is the usual size of polybius square used for encrypting English alphabets?<br>
a) 5 X 5<br>
b) 6 X 6<br>
c) 26 X 26<br>
d) 25 X 25<br>
</b></p><i>Answer: a<br>
Explanation: The usual size of poybius square for encrypting English alphabets is 5 X 5. Usually, I and J are combined so as to fit all English letters in this table. </i><p><b>5. Polybius square cipher is most closely related to?<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: a<br>
Explanation: Polybius square cipher is much like any mono alphabetic cipher. It is because it applies a fixed substitution to the letters present in plain text.</i><p><b>6. Which two English letters are usually combined in polybius table?<br>
a) A and B<br>
b) Y and Z<br>
c) I and J<br>
d) J and K<br>
</b></p><i>Answer: c<br>
Explanation: The usual size of poybius square for encrypting English alphabets is 5 X 5. Usually, I and J are combined so as to fit all English letters in this table. </i><p><b>9. Which of the following cipher uses polybius square cipher in its first step of encrypting data?<br>
a) Autokey cipher<br>
b) One time pad cipher<br>
c) ADFGVX cipher<br>
d) Rail fence cipher<br>
</b></p><i>Answer: a<br>
Explanation: Polybius square is closely related to mono alphabetic substitution cipher and thus is more vulnerable to frequency analysis. Whereas polybius square being a poly alphabetic cipher is less vulnerable to frequency analysis and so is more secure.</i><p><b>10. What will be the plain text corresponding to ciphered text “134325” if standard polybius square cipher is used for encryption?<br>
a) SRH<br>
b) CSK<br>
c) RCB<br>
d) KKR<br>
</b></p><i>Answer: b<br>
Explanation: Polybius square cipher is closely related to mono alphabetic cipher. Thus it is quite vulnerable to frequency analysis much like any other mono alphabetic cipher.</i><p><b>11. What will be the encrypted text corresponding to plain text “SAN” using standard polybius square cipher?<br>
a) 431133<br>
b) 341133<br>
c) 441133<br>
d) 114433<br>
</b></p><i>Answer: c<br>
Explanation: ADFGVX cipher uses polybius square cipher in its first step of encrypting data. It uses a 6 X 6 version of polybius square.</i><p><b>12.What will be the output of the following C++ code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;cmath&gt; </span>
<span class="co2">#include &lt;iostream&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> Cipher<span class="br0">(</span>string str<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> r<span class="sy0">,</span> c<span class="sy0">;</span> 
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> str<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
    <span class="br0">{</span> 
&nbsp;
	r <span class="sy0">=</span> <span class="kw3">ceil</span><span class="br0">(</span><span class="br0">(</span>str<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">-</span> <span class="st0">'a'</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu0">5</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
	c <span class="sy0">=</span> <span class="br0">(</span><span class="br0">(</span>str<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">-</span> <span class="st0">'a'</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">5</span><span class="br0">)</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
&nbsp;
&nbsp;
	<span class="kw1">if</span> <span class="br0">(</span>str<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">==</span> <span class="st0">'k'</span><span class="br0">)</span> 
        <span class="br0">{</span> 
	    r <span class="sy0">=</span> r <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
	    c <span class="sy0">=</span> <span class="nu0">5</span> <span class="sy0">-</span> c <span class="sy0">+</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
&nbsp;
&nbsp;
	<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>str<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&gt;=</span> <span class="st0">'j'</span><span class="br0">)</span> 
        <span class="br0">{</span> 
	    <span class="kw1">if</span> <span class="br0">(</span>c <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">)</span> 
            <span class="br0">{</span> 
		c <span class="sy0">=</span> <span class="nu0">6</span><span class="sy0">;</span> 
		r <span class="sy0">=</span> r <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
	    <span class="br0">}</span> 
	    c <span class="sy0">=</span> c <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span> 
	<span class="br0">}</span> 
	cout <span class="sy0">&lt;&lt;</span> r <span class="sy0">&lt;&lt;</span> c<span class="sy0">;</span> 
    <span class="br0">}</span> 
    cout <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    string str <span class="sy0">=</span> <span class="st0">"nsit"</span><span class="sy0">;</span> 
    Cipher<span class="br0">(</span>str<span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 33344244<br>
b) 44332434<br>
c) 33432444<br>
d) 11444323<br>
</b></p><i>Answer: b<br>
Explanation: For decoding ciphered text we have to use the polybius square in and find out the letters corresponding to each pair of coordinate. So in this case the plain text is found to be “CSK”.</i><p><b>1. What is the significance of indicator block in running key cipher?<br>
a) it helps in encryption<br>
b) it strengthens the cipher<br>
c) it gives information regarding the book/text from where the key is taken<br>
d) it makes encryption easy<br>
</b></p><i>Answer: c<br>
Explanation: The purpose of having an indicator block in running key cipher is to give information to the receiver about the source of a key being used. It is usually included in the second last block of the message. </i><p><b>2. Running key cipher is an example of _______________<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: b<br>
Explanation: Running key cipher is a substitution cipher. It falls under the category of poly alphabetic cipher as it uses multiple substitutions at different positions in order to cipher the plain text.</i><p><b>3. Encryption in running key cipher is done using _______________<br>
a) running key table<br>
b) vigenere cycle<br>
c) tabula recta<br>
d) any table provided by the person performing the encryption<br>
</b></p><i>Answer: c<br>
Explanation: Encryption of plain text in running key cipher is done by making use of tabula recta. The same table is also used for encryption in vigenere cipher.</i><p><b>4. Which of the following cipher uses a key book or a key text instead of a keyword?<br>
a) vigenere cipher<br>
b) autokey cipher<br>
c) running key cipher<br>
d) affine cipher<br>
</b></p><i>Answer: c<br>
Explanation: Running key cipher is a poly alphabetic cipher. It uses a key book or key text instead of a keyword which is agreed by both parties before encryption takes place.</i><p><b>5. Which of the following is a difference between running key cipher and vigenere cipher?<br>
a) they use different tables for encryption<br>
b) vigenere cipher is poly alphabetic whereas running key cipher is mono alphabetic<br>
c) in vigenere cipher the key is repeated whereas in running key cipher key is not repeated<br>
d) vigenere cipher was used in ancient time whereas running key cipher is used in modern world<br>
</b></p><i>Answer: c<br>
Explanation: In running key cipher key is not repeated unlike vigenere cipher. They both use the same table for encryption.</i><p><b>6. Tabula recta consists of _______________<br>
a) 26 rows and 26 columns<br>
b) 26 rows and 1 column<br>
c) 1 row and 26 columns<br>
d) 27 rows and 27 columns<br>
</b></p><i>Answer: a<br>
Explanation: Encryption of plain text using running key cipher is done by making use of tabula recta. It consists of 26 rows and 26 columns which have alphabets written 26 times. These are shifted towards left after each row.</i><p><b>8. What will be the plain text corresponding to cipher text “KEPWSN” if running key cipher is used with keyword as “SANFOUNDRY”?<br>
a) SECRET<br>
b) QWERTY<br>
c) INDIAN<br>
d) FRIEND<br>
</b></p><i>Answer: a<br>
Explanation: Keyword cipher is less secure than running key cipher. It is due to the fact that keyword cipher is mono alphabetic and thus can be cracked using frequency analysis. But running key cipher being a poly alphabetic cipher is harder to crack. </i><p><b>10. Running key cipher is a variation of?<br>
a) vigenere cipher<br>
b) autokey cipher<br>
c) hill cipher<br>
d) route cipher<br>
</b></p><i>Answer: a<br>
Explanation: Running key cipher is a type of poly alphabetic substitution which uses tabula recta for making substitutions in the plain text. Using the table we find the plain text to be “SECRET”.</i><p><b>11. What will be the ciphered text corresponding to “SANFOUNDRY” if running key cipher is used for encryption with keyword as “ONCEUPONATIME”?<br>
a) GNPJIJBQRR<br>
b) GNPIJJBRRQ<br>
c) GPNJJOBQRR<br>
d) GJJNPOBQRI<br>
</b></p><i>Answer: b<br>
Explanation: Running key cipher is a poly alphabetic substitution cipher. Encryption is done by using tabula recta.</i><p><b>12. What will be the ciphered text corresponding to “ALGORITHM” if running key cipher is used for encryption with keyword as “DATASTRUCTURE”?<br>
a) LDJOZOBBK<br>
b) DLZOJBKBO<br>
c) ZOLDJBKBO<br>
d) OLZBJDKBO<br>
</b></p><i>Answer: a<br>
Explanation: Vigenere cipher is a variation of vigenere cipher. The only difference between them is that in vigenere cipher a random key is chosen whereas in running key cipher key is chosen from a book or a text.</i><p><b>13. What will be the plain text corresponding to cipher text “IWRWHS” if running key cipher is used with keyword as “SANFOUNDRY”?<br>
a) SECRET<br>
b) QWERTY<br>
c) INDIAN<br>
d) FRIEND<br>
</b></p><i>Answer: a<br>
Explanation: Encryption in running key cipher takes place exactly as in vigenere cipher if we don’t include the indicator block. So by using the tabula recta we can find the encrypted text which is “GNPJIJBQRR”.</i><p><b>1. What is the period in bifid cipher?<br>
a) length of blocks in which the plain text is divided before encryption<br>
b) number of letters after which the key is repeated<br>
c) number of blocks into which the plain text is divided before encryption<br>
d) number of keys used for encryption<br>
</b></p><i>Answer: a<br>
Explanation: Polybius square is similar to substitution cipher. It is also known by the name of Polybius checkboard.</i><p><b>2. Which of the following cipher uses polybius square?<br>
a) bifid cipher<br>
b) beaufort cipher<br>
c) trithemius cipher<br>
d) gronsfeld cipher<br>
</b></p><i>Answer: a<br>
Explanation: Bifid cipher uses polybius square for encrypting the plain text. Bifid cipher combines polybius square cipher with transposition.</i><p><b>3. Bifid cipher combines transposition with which of the following cipher?<br>
a) Polybius square cipher<br>
b) Playfair cipher<br>
c) gronsfeld cipher<br>
d) trifid cipher<br>
</b></p><i>Answer: a<br>
Explanation: Bifid cipher combines polybius square cipher with transposition. It uses fractionation to obtain diffusion.</i><p><b>7. What will be the ciphered text corresponding to “SANFOUNDRY” if bifid cipher is used for encryption with key as “KEY” with period as 5?<br>
a) SBPISZTKZH<br>
b) PLNSOWGKQM<br>
c) SELFQEXBHM<br>
d) YFSGWNFBW<br>
</b></p><i>Answer: a<br>
Explanation: For forming the key square from the given key we first add the letters of the key in the square by omitting the repeated letters and then we add the remaining letters of the English alphabet. Usually, I and J are combined together.</i><p><b>8. What will be the ciphered text corresponding to “ALGORITHM” if bifid cipher is used for encryption with key as “KEY” with a period as 5?<br>
a) SBPISZTKZH<br>
b) PLNSOWGKQM<br>
c) SELFQEXBHM<br>
d) YFSGWNFBW<br>
</b></p><i>Answer: b<br>
Explanation: Trifid cipher is a variation of bifid cipher. The only difference between them is that trifid cipher uses a 3×3 key square instead of 5×5 square.</i><p><b>9. What will be the plain text corresponding to cipher text “XKS” if the bifid cipher is used with key as “KEY” and period as 5?<br>
a) IND<br>
b) USA<br>
c) RSA<br>
d) AUS<br>
</b></p><i>Answer: b<br>
Explanation: Bifid square combines polybius square with transposition. So the given statement is false.</i><p><b>10. What will be the plain text corresponding to ciphered text “BKC” if the bifid cipher is used for encryption with key as “KEY” and period 5?<br>
a) MSD<br>
b) SRT<br>
c) KVK<br>
d) VVS<br>
</b></p><i>Answer: b<br>
Explanation: For encrypting the plain text using bifid cipher we first form the polybius square with the help of given key. After this, the plain text is divided into blocks of length 5 and corresponding coordinates are noted. So the corresponding cipher text would be “PLNSOWGKQM”.</i><p><b>1. What is the length of the dot in Morse code?<br>
a) 1 Unit<br>
b) 7 Units<br>
c) 5 Units<br>
d) 3 Units<br>
</b></p><i>Answer: d<br>
Explanation: In Morse Code, the length of the single dot is defined to be 1 Unit. While dash is defined to be 3 Unit. In Morse Code, the space between words is 7 unit.</i><p><b>2. Which of the following is used as signal duration in Morse Code?<br>
a) Dash<br>
b) Forward Slash<br>
c) Apostrophe<br>
d) Ampersand<br>
</b></p><i>Answer: a<br>
Explanation: The two signal duration used in Morse code are Dot and Dash. They are also called Dits and Dahs. While other symbols are expressed in terms of dots and dash.</i><p><b>3. Morse Code is named after which scientist?<br>
a) Samuel F. B. Morse<br>
b) Karl Morse<br>
c) Judea Pearl<br>
d) Daniel C. Morse<br>
</b></p><i>Answer: a<br>
Explanation: Morse Code is named after Samuel F. B. Morse who is the inventor of the telegraph. The best first search algorithm using heuristic evaluation rule or function was proposed by an Israeli – American computer scientist and philosopher Judea Pearl.</i><p><b>4. What is the basic unit of time measurement in Morse code transmission?<br>
a) Dot duration<br>
b) Dash Duration<br>
c) Numeric Duration<br>
d) Space Duration<br>
</b></p><i>Answer: a<br>
Explanation: Dot duration is the basic unit of time measurement in Morse code transmission. Both dot and dash signal are used as time measurement in Morse code.</i><p><b>5. The dash duration is how many times the dot duration?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The duration of a dash is 3 times the duration of a dot as duration of dot is defined to be 1 unit in Morse Code and duration of dash is 3 units in Morse Code.</i><p><b>6. In Morse Code, each dot or dash within a character is followed by a period of signal absence. What is the name of that signal?<br>
a) Slash<br>
b) Space<br>
c) Ampersand<br>
d) Asterisk<br>
</b></p><i>Answer: b<br>
Explanation: Each dot or dash within a character is followed by a period of signal absence called Space Signal which is of 1 Unit. The space signal is used after every word in Morse Code.</i><p><b>7. What is the duration of Space Signal?<br>
a) Equal to Dot Duration<br>
b) More than Dot Duration<br>
c) Equal to Dash Duration<br>
d) More than Dash Duration<br>
</b></p><i>Answer: a<br>
Explanation: The duration of Space Signal is 1 Unit and Dot Duration is also 1 Unit. So the duration of Space Signal is equal to Dot Duration.</i><p><b>8. The letters of a word are separated by a space of how many durations?<br>
a) 1 Dot Duration<br>
b) 2 Dot Duration<br>
c) 3 Dot Duration<br>
d) 4 Dot Duration<br>
</b></p><i>Answer: c<br>
Explanation: The letters of a word are separated by a space of 3 dot durations. Since the dot duration is of 1 Unit. So, the letters of a word are separated by a space of 3 Unit.</i><p><b>9. The words are separated by a space of how many durations?<br>
a) 5<br>
b) 6<br>
c) 7<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: The words are separated by a space of 7 dot durations. Since the dot duration is of 1 Unit. So, the words are separated by a space of 7 Unit.</i><p><b>12. What is meant by the single dash in Morse code?<br>
a) A<br>
b) T<br>
c) Z<br>
d) E<br>
</b></p><i>Answer: a<br>
Explanation: Morse code was designed so that the length of each symbol is inverse to the frequency of occurrence in text. Therefore, the letter the letter “E”, has a single dot.</i><p><b>13. What is the Morse code for the distress signal is SOS?<br>
a) 3 Dots, 3Dashes, and 3 Dots<br>
b) 3 Dots, 3 Dashes, and 2 Dots<br>
c) 3 Dots, 2 Dashes, and 3 Dots<br>
d) 2 Dots, 3 Dashes, and 3 Dots<br>
</b></p><i>Answer: a<br>
Explanation: The letter in English, “E”, has a single dot. It is considered to be the smallest Morse Code ever defined till now while other letters are larger in time duration.</i><p><b>14. For which device was Morse code developed for?<br>
a) Telegraphy<br>
b) Stethoscope<br>
c) Telephone<br>
d) SONAR<br>
</b></p><i>Answer: b<br>
Explanation: The common letter in English, the letter “T”, has the shortest dash code: a single dash. While the letter in English, “E”, has a single dot. It is considered to be the smallest Morse Code ever defined till now while other letters are larger in time duration.</i><p><b>15. When was Morse system for telegraphy first used?<br>
a) 1843<br>
b) 1844<br>
c) 1845<br>
d) 1846<br>
</b></p><i>Answer: a<br>
Explanation: In an emergency the distress signal is SOS– 3 dots, 3 dashes, and 3 dots – internationally recognized by treaty. It is used to call emergency help when someone is in need.</i><p><b>1. Which letter of the English alphabet has the shortest code in Morse Code?<br>
a) A<br>
b) C<br>
c) B<br>
d) E<br>
</b></p><i>Answer: d<br>
Explanation: Morse code was designed so that the length of each symbol is inverse to the frequency of occurrence in text. Thus the letter in English, “E”, has a single dot.</i><p><b>2. Which word tells a word rate of Morse code’s shorter code durations for common characters such as “e” and “t”.?<br>
a) PARIS<br>
b) CODEX<br>
c) PARCOD<br>
d) SPACE<br>
</b></p><i>Answer: a<br>
Explanation: PARIS tells about word rate that is typical of natural language words and reflects the benefits of Morse code’s shorter code durations for common characters such as “e” and “t”.</i><p><b>5. Who is the creator of Modern International Morse Code?<br>
a) Samuel F. B. Morse<br>
b) Karl Morse<br>
c) Alexander Morse<br>
d) Friedrich Clemens Gerke<br>
</b></p><i>Answer: a<br>
Explanation: Morse code speed is measured in words per minute (wpm). The transmission rate of the Morse code is also measured is groups per unit (gpm).</i><p><b>6. What is meant by the single dot in Morse code?<br>
a) A<br>
b) C<br>
c) B<br>
d) E<br>
</b></p><i>Answer: a<br>
Explanation: Morse code speed is measured in characters per minute (cpm) as well as in words per minute (wpm). The transmission rate of the Morse code is also measured is groups per unit (gpm).</i><p><b>7. Which word offers a word rate that is typical of 5-letter code groups?<br>
a) PARIS<br>
b) CODEX<br>
c) PARCOD<br>
d) SPACE<br>
</b></p><i>Answer: d<br>
Explanation: It was created by Friedrich Clemens Gerke in 1848 and initially used for telegraphy in Germany. Samuel Morse is the inventor of the telegraph after whom Morse code was named.</i><p><b>8. What is the name of special procedural signals that are used to indicate changes in communications protocol status?<br>
a) Prosigns<br>
b) Aldis<br>
c) BIT<br>
d) Asterisk<br>
</b></p><i>Answer: d<br>
Explanation: The most common letter in English, the letter “E”, has a single dot. Morse code was designed so that the length of each symbol is inverse to frequency of occurrence in text.</i><p><b>9. Space signal is of how many unit?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: CODEX word offers a word rate that is typical of 5-letter code groups. PARIS is a standard word to measure the operator transmission speed of Morse Code.</i><p><b>10. The letters of a word are separated by a space of how many units?<br>
a) 1 Unit<br>
b) 2 Units<br>
c) 3 Units<br>
d) 4 Units<br>
</b></p><i>Answer: b<br>
Explanation: Prosigns are special unwritten procedural signals which are used to show changes in communications protocol status or white space text.</i><p><b>11. Which symbol is not defined inside the ITU recommendation on Morse code?<br>
a) $<br>
b) .<br>
c) +<br>
d) ~<br>
</b></p><i>Answer: a<br>
Explanation: Since the duration of Space Signal is equal to Dot Duration. So, the space signal is of 1 Unit. While a dash is 3 units and space between letters is also three units.</i><p><b>12. For which symbol there is no standard representation in Morse Code?<br>
a) /<br>
b) .<br>
c) *<br>
d) !<br>
</b></p><i>Answer: c<br>
Explanation: The letters of a word are separated by a space of 3 Unit. The representation of dot symbol has 1 unit, while the dash symbol has 2 units.</i><p><b>13. In which year the symbol @ was added to the official Morse character set by ITU-R?<br>
a) 2003<br>
b) 2004<br>
c) 2005<br>
d) 2006<br>
</b></p><i>Answer: a<br>
Explanation: The symbol $ and &amp; are not defined inside the ITU recommendation on Morse code. International Telecommunication Union is a union that mandated Morse code worldwide.</i><p><b>14. Which device was used to generate high speed Morse Code?<br>
a) Iambic Paddle<br>
b) Note Paddle<br>
c) Vibrolex<br>
d) KSM Radio<br>
</b></p><i>Answer: d<br>
Explanation: There is no standard representation for the exclamation mark (!) in Morse code. The other symbols have been defined by the International Telecommunication Union.</i><p><b>15. Who along with Samuel Morse developed Morse code?<br>
a) Alfred Vail<br>
b) Alan Turing<br>
c) Jedidiah Morse<br>
d) Lucretia Pickering Walker<br>
</b></p><i>Answer: b<br>
Explanation: On May 24, 2004, the symbol @ was added to the official Morse character set by International Telecommunication Union.</i><p><b>1. Which of the following is not a type of traditional cipher?<br>
a) Substitution cipher<br>
b) Transposition  cipher<br>
c) Mono alphabetic cipher<br>
d) PKCS cipher<br>
</b></p><i>Answer: d<br>
Explanation: There are two types of the traditional cipher. One is transposition cipher and the other is substitution cipher. Whereas PKCS is a modern asymmetric cipher.</i><p><b>2. Which of the following cipher uses two keys to encrypt data?<br>
a) substitution cipher<br>
b) transposition cipher<br>
c) symmetric cipher<br>
d) asymmetric cipher<br>
</b></p><i>Answer: d<br>
Explanation: Asymmetric cipher makes use of 2 keys for the purpose of encryption. One is known as public key whereas other is called private key.</i><p><b>3. Asymmetric encryption is also known as?<br>
a) Private key cryptography<br>
b) Public key cryptography<br>
c) Public private key cryptography<br>
d) Traditional cryptography<br>
</b></p><i>Answer: b<br>
Explanation: Asymmetric encryption is also known as public key cryptography. Asymmetric cipher makes use of 2 keys for the purpose of encryption.</i><p><b>4. Which of the following is an example of asymmetric encryption technique?<br>
a) one-time pad<br>
b) one-time password<br>
c) DSA<br>
d) blowfish<br>
</b></p><i>Answer: c<br>
Explanation: Asymmetric cipher makes use of 2 keys for the purpose of encryption. DSA is an example of asymmetric encryption technique. </i><p><b>5. Columnar cipher falls under the category of?<br>
a) mono-alphabetic cipher<br>
b) poly-alphabetic cipher<br>
c) transposition cipher<br>
d) additive cipher<br>
</b></p><i>Answer: c<br>
Explanation: Columnar cipher is a transposition cipher. It falls under the category of transposition cipher as it encrypts the plain text by rearranging its letters.</i><p><b>6. Which of the following ciphered text would have NOT used transposition cipher for encryption of the plain text “CIPHER”?<br>
a) EPIHRC<br>
b) EHIPCR<br>
c) DTIPRC<br>
d) HRIPEC<br>
</b></p><i>Answer: c<br>
Explanation: We know that transposition cipher encrypts the plain text by shuffling the letters of the plain text. So out of the given options, only “DTIPRC” does not have the same set of letters as “CIPHER”.</i><p><b>7. Which of the following cipher is formed by applying columnar transposition cipher twice?<br>
a) Rail Fence cipher<br>
b) Route cipher<br>
c) Double transposition cipher<br>
d) One time pad<br>
</b></p><i>Answer: c<br>
Explanation: Double transposition cipher is formed by applying columnar transposition cipher twice. For the purpose of encryption, we may use the same key twice or we can use two different keys.</i><p><b>8. In which of the following cipher the plain text and the ciphered text does not have the same set of letters?<br>
a) route cipher<br>
b) columnar transposition cipher<br>
c) myszkowski cipher<br>
d) additive cipher<br>
</b></p><i>Answer: d<br>
Explanation: In transposition cipher, the letters remain the same in ciphered and plain text. Their position is only changed whereas in substitution cipher the letters become different in encrypted text. As additive cipher is the only non transposition cipher out of the given options so it will be the correct option.</i><p><b>10. How many columns do we need to have in the table, that is used for encryption in columnar transposition cipher when a given keyword is “SECRET” and plain text is “SANFOUNDRY”?<br>
a) 4<br>
b) 5<br>
c) 6<br>
d) 7<br>
</b></p><i>Answer: b<br>
Explanation: Double transposition cipher is formed by applying columnar transposition cipher twice. So it is harder to crack than a simple columnar transposition cipher.</i><p><b>11. What will be the encrypted text corresponding to plain text “CLASSIFIED” using columnar transposition cipher with a keyword as “GAMES”?<br>
a) LFDSIASECI<br>
b) SECIAISDFL<br>
c) CILFAISESD<br>
d) LFSECIAISD<br>
</b></p><i>Answer: c<br>
Explanation: The number of columns in the table used for the purpose encryption in columnar transposition cipher will always be equal to the number of letters in the keyword. So in this case it will be equal to 6.</i><p><b>12. How many rows will the letters of the plain text occupy in the table, that is used for encryption in columnar transposition cipher when a given keyword is “SECRET” and plain text is “SANFOUNDRY”?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: d<br>
Explanation: For encrypting using columnar cipher we have to arrange the letters of the plain text in a table which has the same number of columns as the letters of the keyword. Then the letters of the keyword are arranged in alphabetical order and we read along each column.<br>
3 1 4 2 5<br>
G A M E S<br>
C L A S S<br>
I F I E D<br>
So the ciphered text will be “IFSECIAISD”.</i><p><b>13. Which of the following statement is not true regarding columnar transposition cipher?<br>
a) it is a weak cipher<br>
b) probability of error is high while deciphering<br>
c) it cannot be combined with other ciphers<br>
d) it is a traditional symmetric cipher<br>
</b></p><i>Answer: b<br>
Explanation: The number of columns in the table used for the purpose encryption in columnar transposition cipher will always be equal to the number of letters in the keyword.So when we will write the letters of the plain text row wise then there will be 2 rows of plain text in this case. The table is shown below :-<br>
S E C R E T<br>
1 S A N F O U<br>
2 N D R Y</i><p><b>1. Which of the following cipher makes use of linear algebra for encrypting data?<br>
a) polybius square cipher<br>
b) affine cipher<br>
c) caesar cipher<br>
d) rail fence cipher<br>
</b></p><i>Answer: b<br>
Explanation: Affine cipher is the only cipher out of the given options that make use of linear algebra for the purpose of encryption. It is a type of mono alphabetic cipher.</i><p><b>2. Which of the following cipher requires only one key for decoding the ciphered text?<br>
a) Affine cipher<br>
b) RSA<br>
c) DSA<br>
d) PKCS<br>
</b></p><i>Answer: a<br>
Explanation: Asymmetric cipher makes use of 2 keys for the purpose of encryption. As affine cipher is the only symmetric cipher out of the given options so it requires only one key.</i><p><b>3. Choose the weakest cipher from the following?<br>
a) Vigenere cipher<br>
b) Autokey cipher<br>
c) Affine cipher<br>
d) Hill cipher<br>
</b></p><i>Answer: c<br>
Explanation: Affine cipher is the weakest cipher out of the given options as it is a mono alphabetic cipher and other options are poly alphabetic ciphers. So it is quite vulnerable to frequency analysis. </i><p><b>4. What is the formula used for encryption of data using affine cipher(a,b are constants and x is the numerical equivalent of a letter to be encrypted)?<br>
a) ax+b<br>
b) (ax+b)%26<br>
c) ax<sup>2</sup>+bx<br>
d) (ax<sup>2</sup>+bx)%26<br>
</b></p><i>Answer: b<br>
Explanation: Affine cipher uses linear algebra for the purpose of encryption. It uses the formula (ax+b)%26 for this purpose.</i><p><b>5. What is the formula used for decoding the ciphered text using affine cipher(a,b are constants and x is the numerical equivalent of a letter to be encrypted)?<br>
a) a<sup>-1</sup>(x-b)%26<br>
b) (ax+b)%26<br>
c) b<sup>-1</sup>(x-a)%26<br>
d) b<sup>-1</sup>(x-a)<br>
</b></p><i>Answer: a<br>
Explanation: Affine cipher uses linear algebra for the purpose of encryption. It uses the formula  a<sup>-1</sup>(x-b)%26 for decryption of ciphered text.</i><p><b>6. Affine cipher is an example of?<br>
a) Mono alphabetic cipher<br>
b) Poly alphabetic cipher<br>
c) Transposition cipher<br>
d) Asymmetric cipher<br>
</b></p><i>Answer: a<br>
Explanation: Affine cipher falls in the category of mono alphabetic substitution cipher. It uses linear algebra for encrypting the plain text.</i><p><b>9. What will be the ciphered text corresponding to plain text “sanfoundry” if an affine cipher is used with key values as a=5, b=10?<br>
a) wkxjcgxzra<br>
b) gkxteuxfzw<br>
c) ukxhmyxdfg<br>
d) rfsexbsumv<br>
</b></p><i>Answer: b<br>
Explanation: Affine cipher is more secure as compared to caesar cipher. But affine cipher is a very weak cipher as it can be easily broken using frequency analysis.</i><p><b>10. What will be the plain text corresponding to ciphered text “rmw ” if an affine cipher is used with key values as a=5, b=10?<br>
a) csk<br>
b) kkr<br>
c) srt<br>
d) msd<br>
</b></p><i>Answer: b<br>
Explanation: Affine cipher is a very weak cipher as it can be easily broken using frequency analysis. It can be easily cracked even if 2 characters are known.</i><p><b>11. While choosing the value of a and m (m is the no. of alphabets) in affine cipher it must be ensured that?<br>
a) a and m are prime numbers<br>
b) a and m are odd numbers<br>
c) a and m are coprime<br>
d) a and m are even numbers<br>
</b></p><i>Answer: a<br>
Explanation: Affine cipher uses linear algebra for the purpose of encryption. It uses the formula  (ax+b)%26 for this purpose. So the ciphered text will be “wkxjcgxzra”.</i><p><b>1. The most common hamming codes are a generalized version of?<br>
a) Hamming(7, 4) code<br>
b) Hamming(8, 4) code<br>
c) Hamming(6, 3) code<br>
d) Hamming(5, 7) code<br>
</b></p><i>Answer: a<br>
Explanation: The most common hamming codes generalize to form hamming(7, 4) code. It encodes four bits of data into seven bits by adding three parity bits.</i><p><b>2. What is the minimal Hamming distance between any two correct codewords?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: c<br>
Explanation: Since we use a generalized version of Hamming(7, 4) code, the minimal hamming distance is 3. It cannot correct burst errors.</i><p><b>3. Why do we require hamming codes?<br>
a) Error correction<br>
b) Encryption only<br>
c) Decryption<br>
d) Bit stuffing<br>
</b></p><i>Answer: a<br>
Explanation: Hamming codes are used for the purpose of error detection and correction. It is also used for channel encoding and decoding. They are linear-error correcting codes.</i><p><b>5. Who invented Hamming codes?<br>
a) Richard Hamming<br>
b) Ross Hamming<br>
c) Shannon<br>
d) Huffman<br>
</b></p><i>Answer: b<br>
Explanation: Hamming bits are suitable only for single-bit error detection and correction and two bit error detection. It is very unlikely to detect burst errors.</i><p><b>6. What is the total block length ‘n’ of a Hamming code?<br>
a) 2<sup>r</sup><br>
b) 2<sup>r</sup>-1<br>
c) 2<sup>r-1</sup>-1<br>
d) 2<sup>r</sup>+1<br>
</b></p><i>Answer: a<br>
Explanation: Richard W. Hamming invented hamming codes in Bell Telephone Laboratory to minimize the errors in punched card readers. Huffman invented huffman codes. Shannon invented Shannon-Fanno codes.</i><p><b>7. What is the message length ‘k’ of a Hamming(7,4) code?<br>
a) 2<sup>r</sup>-1<br>
b) 2<sup>r</sup>-r+1<br>
c) 2<sup>r</sup>-r-1<br>
d) 2<sup>r+1</sup>-r<br>
</b></p><i>Answer: b<br>
Explanation: Hamming codes are a class of binary linear codes, hence r&gt;=2. For a hamming(7, 4) code, the block length ‘n’ is 2<sup>r</sup>-1 where r is the parity bit. Here, r=3.</i><p><b>8. What is the rate of hamming codes?<br>
a) 1-[r/(2<sup>r</sup>-1)] <br>
b) 1-(r/2<sup>r</sup>)<br>
c) 1+(r/2<sup>r</sup>)<br>
d) r/2<sup>r</sup>+1<br>
</b></p><i>Answer: c<br>
Explanation: Hamming codes are a class of binary linear codes, hence r&gt;=2. For a hamming(7,4) code, the message length ‘k’ is 2<sup>r</sup>-r-1 where r is the parity bit. Here, r=3.</i><p><b>9. A two-out-of-five code consists of _________<br>
a) Two 0s and three 1s<br>
b) Three 0s and two 1s<br>
c) Four 0s and one 1s<br>
d) One 0s and four 1s<br>
</b></p><i>Answer: a<br>
Explanation: Rate of a hamming code is message length divided by block length (i.e.) 2<sup>r</sup>-r-1/2<sup>r</sup>-1 = 1-[r/(2<sup>r</sup>-1)]. It is the highest rate for a minimum distance of three.</i><p><b>11. ________ is the mechanism of sending data bits multiple times to ensure consistency.<br>
a) Repetition<br>
b) Duplication<br>
c) Mirroring<br>
d) Redundancy<br>
</b></p><i>Answer: b<br>
Explanation: A two-out-of-five code consists of three 0s and two 1s. Hence, it contains ten possible combinations to represent digits from 0-9.</i><p><b>12. An Extended hamming code is also called as __________<br>
a) SEDDEC<br>
b) SEDDED<br>
c) SECDED<br>
d) SECDEC<br>
</b></p><i>Answer: b<br>
Explanation: If error has occurred in a data string, parity will change inorder to indicate errors. However, if the error occurs in parity bit, the error goes undetected.</i><p><b>13. What is the code rate of a repetition Hamming code (3, 1)?<br>
a) 1<br>
b) 3<br>
c) 1/3<br>
d) 1.3<br>
</b></p><i>Answer: a<br>
Explanation: Repeating data bits multiple times is done to ensure consistency. If the data bit to be sent is a 1, a n=3 repetition code will send 111. If the bits are not the same, an error has occurred.</i><p><b>14. For a hamming code of parity bit m=8, what is the total bits and data bits?<br>
a) (255, 247)<br>
b) (127, 119)<br>
c) (31, 26)<br>
d) (0, 8)<br>
</b></p><i>Answer: c<br>
Explanation: An Extended Hamming code is also called as SECDED (Single Error Correction Double Error Detection). The most popular codes are (72, 64) code and (127,120) code.</i><p><b>15. What is the rate of the hamming code of parity bit m=8?<br>
a) 0.94<br>
b) 0.92<br>
c) 0.90<br>
d) 0.97<br>
</b></p><i>Answer: c<br>
Explanation: The code rate of a repetition hamming code is the second number divided by the first number. Here, it is 1/3.</i><p><b>1. The worst-case efficiency of solving a problem in polynomial time is?<br>
a) O(p(n))<br>
b) O(p( n log n))<br>
c) O(p(n<sup>2</sup>))<br>
d) O(p(m log n))<br>
</b></p><i>Answer: a<br>
Explanation: The worst-case efficiency of solving an problem in polynomial time is O(p(n)) where p(n) is the polynomial time of input size.</i><p><b>2. Problems that can be solved in polynomial time are known as?<br>
a) intractable<br>
b) tractable<br>
c) decision<br>
d) complete<br>
</b></p><i>Answer: b<br>
Explanation: Problems that can be solved in polynomial time are known as tractable. Problems that cannot be solved in polynomial time are intractable.</i><p><b>4. _________ is the class of decision problems that can be solved by non-deterministic polynomial algorithms.<br>
a) NP<br>
b) P<br>
c) Hard<br>
d) Complete<br>
</b></p><i>Answer: a<br>
Explanation: One of the properties of polynomial functions states that the sum and composition of two polynomials are always polynomials.</i><p><b>5. Problems that cannot be solved by any algorithm are called?<br>
a) tractable problems<br>
b) intractable problems<br>
c) undecidable problems<br>
d) decidable problems<br>
</b></p><i>Answer: a<br>
Explanation: NP  problems are called as non-deterministic polynomial problems. They are a class of decision problems that can be solved using NP algorithms.</i><p><b>6. The Euler’s circuit problem can be solved in?<br>
a) O(N)<br>
b) O( N log N)<br>
c) O(log N)<br>
d) O(N<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: Problems cannot be solved by any algorithm are called undecidable problems. Problems that can be solved in polynomial time are called Tractable problems.</i><p><b>7. To which class does the Euler’s circuit problem belong?<br>
a) P class<br>
b) NP class<br>
c) Partition class<br>
d) Complete class<br>
</b></p><i>Answer: d<br>
Explanation: Mathematically, the run time of Euler’s circuit problem is determined to be O(N<sup>2</sup>).</i><p><b>8. Halting problem is an example for?<br>
a) decidable problem<br>
b) undecidable problem<br>
c) complete problem<br>
d) trackable problem<br>
</b></p><i>Answer: a<br>
Explanation: Euler’s circuit problem can be solved in polynomial time. It can be solved in O(N<sup>2</sup>).</i><p><b>9. How many stages of procedure does a non-deterministic algorithm consist of?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: Halting problem by Alan Turing cannot be solved by any algorithm. Hence, it is undecidable.</i><p><b>11. How many conditions have to be met if an NP- complete problem is polynomially reducible?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: A non-deterministic algorithm is a two-stage procedure- guessing stage and verification stage.</i><p><b>12. To which of the following class does a CNF-satisfiability problem belong?<br>
a) NP class<br>
b) P class<br>
c) NP complete<br>
d) NP hard<br>
</b></p><i>Answer: a<br>
Explanation: One of the properties of NP class problems states that A non-deterministic algorithm is said to be non-deterministic polynomial if the time-efficiency of its verification stage is polynomial.</i><p><b>13. How many steps are required to prove that a decision problem is NP complete?<br>
a) 1<br>
b) 2<br>
c) 3<br>
d) 4<br>
</b></p><i>Answer: b<br>
Explanation: A function t that maps all yes instances of decision problems D1 and D2 and t should be computed in polynomial time are the two conditions.</i><p><b>14. Which of the following problems is not NP complete?<br>
a) Hamiltonian circuit<br>
b) Bin packing<br>
c) Partition problem<br>
d) Halting problem<br>
</b></p><i>Answer: c<br>
Explanation: The CNF satisfiability problem belongs to NP complete class. It deals with Boolean expressions.</i><p><b>15. The choice of polynomial class has led to the development of an extensive theory called ________<br>
a) computational complexity<br>
b) time complexity<br>
c) problem complexity<br>
d) decision complexity<br>
</b></p><i>Answer: b<br>
Explanation: First, the problem should be NP. Next, it should be proved that every problem in NP is reducible to the problem in question in polynomial time.</i><p><b>1. Which of the following algorithm can be used to solve the Hamiltonian path problem efficiently?<br>
a) branch and bound<br>
b) iterative improvement<br>
c) divide and conquer<br>
d) greedy algorithm<br>
</b></p><i>Answer: a<br>
Explanation: The Hamiltonian path problem can be solved efficiently using branch and bound approach. It can also be solved using a backtracking approach.</i><p><b>2. The problem of finding a path in a graph that visits every vertex exactly once is called?<br>
a) Hamiltonian path problem<br>
b) Hamiltonian cycle problem<br>
c) Subset sum problem<br>
d) Turnpike reconstruction problem<br>
</b></p><i>Answer: a<br>
Explanation: Hamiltonian path problem is a problem of finding a path in a graph that visits every node exactly once whereas Hamiltonian cycle problem is finding a cycle in a graph.</i><p><b>3. Hamiltonian path problem is _________<br>
a) NP problem<br>
b) N class problem<br>
c) P class problem<br>
d) NP complete problem<br>
</b></p><i>Answer: d<br>
Explanation: Hamiltonian path problem is found to be NP complete. Hamiltonian cycle problem is also an NP- complete problem.</i><p><b>5. Which of the following problems is similar to that of a Hamiltonian path problem?<br>
a) knapsack problem<br>
b) closest pair problem<br>
c) travelling salesman problem<br>
d) assignment problem<br>
</b></p><i>Answer: b<br>
Explanation: There is a relationship between Hamiltonian path problem and Hamiltonian circuit problem. The Hamiltonian path in graph G is equal to Hamiltonian cycle in graph H under certain conditions.</i><p><b>6. Who formulated the first ever algorithm for solving the Hamiltonian path problem?<br>
a) Martello<br>
b) Monte Carlo<br>
c) Leonard<br>
d) Bellman<br>
</b></p><i>Answer: c<br>
Explanation: Hamiltonian path problem is similar to that of a travelling salesman problem since both the problem traverses all the nodes in a graph exactly once.</i><p><b>7. In what time can the Hamiltonian path problem can be solved using dynamic programming?<br>
a) O(N)<br>
b) O(N log N)<br>
c) O(N<sup>2</sup>)<br>
d) O(N<sup>2</sup> 2<sup>N</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The first ever problem to solve the Hamiltonian path was the enumerative algorithm formulated by Martello.</i><p><b>9. Who invented the inclusion-exclusion principle to solve the Hamiltonian path problem?<br>
a) Karp<br>
b) Leonard Adleman<br>
c) Andreas Bjorklund<br>
d) Martello<br>
</b></p><i>Answer: d<br>
Explanation: Using dynamic programming, the time taken to solve the Hamiltonian path problem is mathematically found to be O(N<sup>2</sup> 2<sup>N</sup>).</i><p><b>10. For a graph of degree three, in what time can a Hamiltonian path be found?<br>
a) O(0.251<sup>n</sup>)<br>
b) O(0.401<sup>n</sup>)<br>
c) O(0.167<sup>n</sup>)<br>
d) O(0.151<sup>n</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: According to a handshaking lemma, in graphs, in which all vertices have an odd degree, the number of Hamiltonian cycles through any fixed edge is always even.</i><p><b>11. What is the time complexity for finding a Hamiltonian path for a graph having N vertices (using permutation)?<br>
a) O(N!)<br>
b) O(N! * N)<br>
c) O(log N)<br>
d) O(N)<br>
</b></p><i>Answer: c<br>
Explanation: Andreas Bjorklund came up with the inclusion-exclusion principle to reduce the counting of number of Hamiltonian cycles.</i><p><b>1. Under what condition any set A will be a subset of B?<br>
a) if all elements of set B are also present in set A<br>
b) if all elements of set A are also present in set B<br>
c) if A contains more elements than B<br>
d) if B contains more elements than A<br>
</b></p><i>Answer: b<br>
Explanation: Any set A will be called a subset of set B if all elements of set A are also present in set B. So in such a case set A will be a part of set B.</i><p><b>2. What is a subset sum problem?<br>
a) finding a subset of a set that has sum of elements equal to a given number<br>
b) checking for the presence of a subset that has sum of elements equal to a given number and printing true or false based on the result<br>
c) finding the sum of elements present in a set<br>
d) finding the sum of all the subsets of a set<br>
</b></p><i>Answer: b<br>
Explanation: In subset sum problem check for the presence of a subset that has sum of elements equal to a given number. If such a subset is present then we print true otherwise false.</i><p><b>3. Which of the following is true about the time complexity of the recursive solution of the subset sum problem?<br>
a) It has an exponential time complexity<br>
b) It has a linear time complexity<br>
c) It has a logarithmic time complexity<br>
d) it has a time complexity of O(n2)<br>
</b></p><i>Answer: a<br>
Explanation: Subset sum problem has both recursive as well as dynamic programming solution. The recursive solution has an exponential time complexity as it will require to check for all subsets in worst case.</i><p><b>4. What is the worst case time complexity of dynamic programming solution of the subset sum problem(sum=given subset sum)?<br>
a) O(n)<br>
b) O(sum)<br>
c) O(n<sup>2</sup>)<br>
d) O(sum*n)<br>
</b></p><i>Answer: d<br>
Explanation: Subset sum problem has both recursive as well as dynamic programming solution. The dynamic programming solution has a time complexity of O(n*sum) as it as a nested loop with limits from 1 to n and 1 to sum respectively.</i><p><b>7. Which of the following is not true about subset sum problem?<br>
a) the recursive solution has a time complexity of O(2n)<br>
b) there is no known solution that takes polynomial time<br>
c) the recursive solution is slower than dynamic programming solution<br>
d) the dynamic programming solution has a time complexity of O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Subset sum problem takes exponential time when we implement a recursive solution. Subset sum problem is known to be a part of NP complete problems.</i><p><b>9. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
bool func<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> sum<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>sum <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> sum <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&gt;</span> sum<span class="br0">)</span> 
	<span class="kw1">return</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span> 
&nbsp;
    <span class="kw1">return</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">||</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="sy0">-</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> sum <span class="sy0">=</span> <span class="nu0">12</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">true</span><span class="br0">)</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">else</span>
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 12<br>
b) 4 6 2<br>
c) True<br>
d) False<br>
</b></p><i>Answer: b<br>
Explanation: The recursive solution to subset sum problem takes exponential time complexity whereas the dynamic programming solution takes polynomial time complexity. So dynamic programming solution is faster in terms of time complexity. </i><p><b>10. What will be the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
bool func<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> sum<span class="br0">)</span> 
<span class="br0">{</span> 
	bool subarr<span class="br0">[</span>n<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>sum<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	subarr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sum<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	subarr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> sum<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
	    <span class="br0">{</span> 
		<span class="kw1">if</span><span class="br0">(</span>j<span class="sy0">&lt;</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
		subarr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> subarr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>j <span class="sy0">&gt;=</span> arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
		subarr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> subarr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> 
		subarr<span class="br0">[</span>i <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span>arr<span class="br0">[</span>i<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="sy0">;</span> 
	    <span class="br0">}</span> 
	<span class="br0">}</span> 
	<span class="kw1">return</span> subarr<span class="br0">[</span>n<span class="br0">]</span><span class="br0">[</span>sum<span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span> 
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> sum <span class="sy0">=</span> <span class="nu0">5</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">true</span><span class="br0">)</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">else</span>
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) true<br>
b) false<br>
c) 0<br>
d) error in code<br>
</b></p><i>Answer: d<br>
Explanation: Recursive solution of subset sum problem is slower than dynamic problem solution in terms of time complexity. Dynamic programming solution has a time complexity of O(n*sum).</i><p><b>11. What will be the worst case time complexity for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
bool func<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> sum<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>sum <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> sum <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&gt;</span> sum<span class="br0">)</span> 
	<span class="kw1">return</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">||</span> func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="sy0">-</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> sum <span class="sy0">=</span> <span class="nu0">12</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">true</span><span class="br0">)</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">else</span>
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(2<sup>n</sup>)<br>
d) O(n<sup>2</sup> log n)<br>
</b></p><i>Answer: b<br>
Explanation: The base case condition defines the point at which the program should stop recursion. In this case we need to make sure that, the sum does not become 0 and there should be elements left in our array for recursion to happen. </i><p><b>1. What is meant by the power set of a set?<br>
a) subset of all sets<br>
b) set of all subsets<br>
c) set of particular subsets<br>
d) an empty set<br>
</b></p><i>Answer: b<br>
Explanation: Power set of a set is defined as the set of all subsets. Ex- if there is a set S={1,3} then power set of set S will be P={{},{1},{3}{1,3}}.</i><p><b>2. What is the set partition problem?<br>
a) finding a subset of a set that has sum of elements equal to a given number<br>
b) checking for the presence of a subset that has sum of elements equal to a given number<br>
c) checking whether the set can be divided into two subsets of with equal sum of elements and printing true or false based on the result<br>
d) finding subsets with equal sum of elements<br>
</b></p><i>Answer: c<br>
Explanation: In set partition problem we check whether a set can be divided into 2 subsets such that the sum of elements in each subset is equal. If such subsets are present then we print true otherwise false.</i><p><b>3. Which of the following is true about the time complexity of the recursive solution of set partition problem?<br>
a) It has an exponential time complexity<br>
b) It has a linear time complexity<br>
c) It has a logarithmic time complexity<br>
d) it has a time complexity of O(n2)<br>
</b></p><i>Answer: a<br>
Explanation: Set partition problem has both recursive as well as dynamic programming solution. The recursive solution has an exponential time complexity as it will require to check for all subsets in the worst case.</i><p><b>4. What is the worst case time complexity of dynamic programming solution of set partition problem(sum=sum of set elements)?<br>
a) O(n)<br>
b) O(sum)<br>
c) O(n<sup>2</sup>)<br>
d) O(sum*n)<br>
</b></p><i>Answer: d<br>
Explanation: Set partition problem has both recursive as well as dynamic programming solution. The dynamic programming solution has a time complexity of O(n*sum) as it as a nested loop with limits from 1 to n and 1 to sum respectively.</i><p><b>7. Which of the following is not true about set partition problem?<br>
a) the recursive solution has a time complexity of O(2n)<br>
b) there is no known solution that takes polynomial time<br>
c) the recursive solution is slower than dynamic programming solution<br>
d) the dynamic programming solution has a time complexity of O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: Set partition problem takes exponential time when we implement a recursive solution. Set partition problem is known to be a part of NP complete problems.</i><p><b>9. What will be the output for the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt; </span>
<span class="co2">#include &lt;stdbool.h&gt; </span>
bool func1<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="sy0">,</span> <span class="kw4">int</span> sum<span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw1">if</span> <span class="br0">(</span>sum <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">true</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>n <span class="sy0">==</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> sum <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">&gt;</span> sum<span class="br0">)</span> 
	<span class="kw1">return</span> func1<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> func1<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="br0">)</span> <span class="sy0">||</span> func1<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> sum<span class="sy0">-</span>arr<span class="br0">[</span>n<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
bool func <span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> sum <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	sum <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span> 	
	<span class="kw1">if</span> <span class="br0">(</span>sum<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
	<span class="kw1">return</span> func1 <span class="br0">(</span>arr<span class="sy0">,</span> n<span class="sy0">,</span> sum<span class="sy0">/</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">6</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">true</span><span class="br0">)</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">else</span>
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) true<br>
b) false<br>
c) 4 6 2<br>
d) 12<br>
</b></p><i>Answer: b<br>
Explanation: The recursive solution to set partition problem takes exponential time complexity whereas the dynamic programming solution takes polynomial time complexity. So dynamic programming solution is faster in terms of time complexity. </i><p><b>10. What will be the output for the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;stdio.h&gt;</span>
bool func <span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> sum <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	sum <span class="sy0">+=</span> arr<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">;</span>
	<span class="kw1">if</span> <span class="br0">(</span>sum<span class="sy0">%</span><span class="nu19">2</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> 
	<span class="kw1">return</span> <span class="kw2">false</span><span class="sy0">;</span> 
	bool partition<span class="br0">[</span>sum<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span>n<span class="sy0">+</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	partition<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">true</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sum<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	partition<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>	 
	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;=</span> sum<span class="sy0">/</span><span class="nu0">2</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
	<span class="br0">{</span> 
	    <span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> j <span class="sy0">&lt;=</span> n<span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span> 
	    <span class="br0">{</span> 
		partition<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> partition<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">&gt;=</span> arr<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> 
		partition<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> partition<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">||</span> partition<span class="br0">[</span>i <span class="sy0">-</span> arr<span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">]</span><span class="br0">[</span>j<span class="sy0">-</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span> 
	    <span class="br0">}</span>		 
	<span class="br0">}</span>	 
	<span class="kw1">return</span> partition<span class="br0">[</span>sum<span class="sy0">/</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span>	
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
    <span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">4</span><span class="sy0">,</span> <span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
    <span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">if</span> <span class="br0">(</span>func<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span> <span class="sy0">==</span> <span class="kw2">true</span><span class="br0">)</span> 
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"true"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">else</span>
	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"false"</span><span class="br0">)</span><span class="sy0">;</span> 
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) true<br>
b) false<br>
c) 0<br>
d) error<br>
</b></p><i>Answer: d<br>
Explanation: Recursive solution of set partition problem is slower than dynamic problem solution in terms of time complexity. Dynamic programming solution has a time complexity of O(n*sum).</i><p><b>11. What will be the auxiliary space complexity of dynamic programming solution of set partition problem(sum=sum of set elements)?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(2<sup>n</sup>)<br>
d) O(sum*n)<br>
</b></p><i>Answer: b<br>
Explanation: In this case, we need to make sure that, the sum does not become 0 and there should be elements left in our array for recursion to happen. Also if the sum of elements of the set is an odd number then that set cannot be partitioned into two subsets with an equal sum so under such a condition false should be returned. </i><p><b>1. __________ has the lowest fault rate of all the page replacement algorithms.<br>
a) Optimal page replacement algorithm<br>
b) LRU replacement algorithm<br>
c) FIFO<br>
d) Counting based<br>
</b></p><i>Answer: a<br>
Explanation: Optimal page replacement algorithm has the lowest fault rate as it has the knowledge of all the pages beforehand.</i><p><b>2. Optimal page replacement algorithm is also called as __________<br>
a) LIFO<br>
b) NRU<br>
c) Clairvoyant replacement algorithm<br>
d) Page buffering<br>
</b></p><i>Answer: c<br>
Explanation: Optimal page replacement algorithm is also called a Clairvoyant replacement algorithm or Belady’s optimal replacement algorithm.</i><p><b>3. In a optimal page replacement algorithm, when a page is to be replaced, which of the following pages is chosen?<br>
a) Oldest page<br>
b) Newest page<br>
c) Frequently occurred page in the future<br>
d) Not frequently occurred page in the future<br>
</b></p><i>Answer: d<br>
Explanation: The page which doesn’t occur more frequently in the future is chosen to be replaced with the page in the frame.</i><p><b>5. Analysis of the optimal paging problem has been done through___________<br>
a) Deterministic algorithm<br>
b) Online algorithm<br>
c) Euclid algorithm<br>
d) Optimal algorithm<br>
</b></p><i>Answer: a<br>
Explanation: In an optimal page replacement algorithm, the page that is to be used later in the future is swapped out over a page that is to be used immediately.</i><p><b>6. Optimal page replacement algorithm is implemented in __________<br>
a) General-purpose operating system<br>
b) Special-purpose operating system<br>
c) In any kind of operating system<br>
d) In Windows only<br>
</b></p><i>Answer: b<br>
Explanation: Analysis of the optimal paging algorithm is done through an online algorithm. Efficiency is calculated through amortized analysis.</i><p><b>7. Optimal page replacement algorithm is said to satisfy __________<br>
a) Online algorithm<br>
b) Stack algorithm<br>
c) Queue algorithm<br>
d) Array algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Optimal page replacement algorithm is used in special-purpose operating system because it is impossible to compute time before which a page is used.</i><p><b>8. In a stack algorithm, the set of pages in a k-frame memory is always a subset of pages in a __________ frame memory.<br>
a) k-1<br>
b) k<br>
c) k+1<br>
d) k(k+1)<br>
</b></p><i>Answer: b<br>
Explanation: Optimal page replacement algorithm is said to satisfy the stack algorithm. It is also called as inclusion property.</i><p><b>10. Consider a reference string 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1 of frame size 3. Calculate the number of page faults using optimal page replacement algorithm.<br>
a) 10<br>
b) 9<br>
c) 8<br>
d) 7<br>
</b></p><i>Answer: c<br>
Explanation: Stack algorithm is satisfied if the set of pages in a k-frame memory is always a subset of pages in a k+1 frame memory.</i><p><b>1. ________  is a typical online problem from the competitive analysis to determine the optimal solution.<br>
a) Page replacement algorithm<br>
b) Segmentation<br>
c) Paging<br>
d) Segmentation with paging<br>
</b></p><i>Answer: a<br>
Explanation: Page replacement is a typical online problem from the competitive analysis. They determine which pages to page out or write to disk.</i><p><b>2. Which of the following is the simplest page replacement algorithm?<br>
a) FIFO<br>
b) Optimal page replacement<br>
c) LRU replacement<br>
d) Counting based replacement<br>
</b></p><i>Answer: a<br>
Explanation: FIFO is the simplest page replacement algorithm since LRU and optimal replacement algorithms require past and future data patterns respectively.</i><p><b>3. __________ algorithm associates with each page the time when the page was brought into memory.<br>
a) Optimal page replacement<br>
b) FIFO<br>
c) LRU replacement algorithm<br>
d) Counting based replacement<br>
</b></p><i>Answer: b<br>
Explanation: FIFO algorithm associates with each page the time when the page was brought into memory. The new page is inserted at the tail of the queue.</i><p><b>5. Which of the following page replacement algorithms return the minimum number of page faults?<br>
a) LRU replacement algorithm<br>
b) Optimal page replacement algorithm<br>
c) FIFO<br>
d) Counting based replacement<br>
</b></p><i>Answer: a<br>
Explanation: One of the rules of the page replacement algorithm is that, as the number of frames available increases, the number of page faults decreases.</i><p><b>6. Which of the following is the main drawback of FIFO page replacement algorithm?<br>
a) Requirement of large memory<br>
b) Frame allocation<br>
c) Reduction in multiprogramming<br>
d) Reduced optimality<br>
</b></p><i>Answer: b<br>
Explanation: Though FIFO is the simplest of all algorithms, optimal page replacement algorithm returns the minimum number of page faults.</i><p><b>7. Which of the following is required to determine the number of page faults in FIFO?<br>
a) Page number<br>
b) Page frame number<br>
c) Memory capacity<br>
d) Segment number<br>
</b></p><i>Answer: c<br>
Explanation: The main drawback of FIFO page replacement algorithm is that it reduces the level of multiprogramming and also causes Belady’s anomaly.</i><p><b>8. In a FIFO algorithm, when a page is to be replaced, which of the following page is chosen?<br>
a) Oldest page<br>
b) Newest page<br>
c) Frequently occurred page in past<br>
d) Frequently occurred page in future<br>
</b></p><i>Answer: b<br>
Explanation: To determine the number of page faults in a page replacement algorithm using FIFO, we require page frame number.</i><p><b>10. FIFO algorithm is used by __________ operating system.<br>
a) Linux<br>
b) Mac<br>
c) Windows<br>
d) VAX/VMS<br>
</b></p><i>Answer: a<br>
Explanation: In FIFO page replacement algorithm, when a page is to be replaced, the oldest page is chosen and replaced at the tail of the queue.</i><p><b>11. What is the competitive analysis of the FIFO algorithm?<br>
a) k/k+1<br>
b) k+1<br>
c) k(k+1)<br>
d) k/(k-h+1)<br>
</b></p><i>Answer: b<br>
Explanation: The cost of a FIFO algorithm is cheap and intuitive and it is used in poor practical applications.</i><p><b>12. Under which of the following scenarios is page replacement algorithm required?<br>
a) When total memory exceeds physical memory<br>
b) To determine the number of frames for each process<br>
c) When paging and segmentation are to be used<br>
d) Execution of a process, not in memory<br>
</b></p><i>Answer: d<br>
Explanation: Of the following given operating systems, VAX/VMS uses a FIFO algorithm.</i><p><b>15. _________ states that, on a page fault, the frame that has been in memory the longest is replaced.<br>
a) Belady’s anomaly<br>
b) Second chance algorithm<br>
c) Partial second chance algorithm<br>
d) LRU replacement algorithm<br>
</b></p><i>Answer: d<br>
Explanation: The competitive analysis of a FIFO algorithm is mathematically found to be k/(k-h+1) where k and h are some constants used in page replacement and always, h&lt;=k.</i><p><b>1. Topological sort can be applied to which of the following graphs?<br>
a) Undirected Cyclic Graphs<br>
b) Directed Cyclic Graphs<br>
c) Undirected Acyclic Graphs<br>
d) Directed Acyclic Graphs<br>
</b></p><i>Answer: d<br>
Explanation: Every Directed Acyclic Graph has one or more topological ordering whereas Cyclic and Undirected graphs can’t be ordered topologically.</i><p><b>2. Most Efficient Time Complexity of Topological Sorting is? (V – number of vertices, E – number of edges)<br>
a) O(V + E)<br>
b) O(V)<br>
c) O(E)<br>
d) O(V*E)<br>
</b></p><i>Answer: a<br>
Explanation: The topological sort algorithm has complexity same as Depth First Search. So, DFS has a complexity O(V+E).</i><p><b>3. In most of the cases, topological sort starts from a node which has __________<br>
a) Maximum Degree<br>
b) Minimum Degree<br>
c) Any degree<br>
d) Zero Degree<br>
</b></p><i>Answer: d<br>
Explanation: Topological sort starts with a node which has zero degree. If multiple such nodes exists then it can start with any node.</i><p><b>4. Which of the following is not an application of topological sorting?<br>
a) Finding prerequisite of a task<br>
b) Finding Deadlock in an Operating System<br>
c) Finding Cycle in a graph<br>
d) Ordered Statistics<br>
</b></p><i>Answer: d<br>
Explanation: Topological sort tells what task should be done before a task can be started. It also detects cycle in the graph which is why it is used in the Operating System to find the deadlock. Ordered statistics is an application of Heap sort.</i><p><b>5. Topological sort of a Directed Acyclic graph is?<br>
a) Always unique<br>
b) Always Not unique<br>
c) Sometimes unique and sometimes not unique<br>
d) Always unique if graph has even number of vertices<br>
</b></p><i>Answer: c<br>
Explanation: The topological sort of a graph can be unique if we assume the graph as a single linked list and we can have multiple topological sort order if we consider a graph as a complete binary tree.</i><p><b>6. Topological sort can be implemented by?<br>
a) Using Depth First Search<br>
b) Using Breadth First Search<br>
c) Using Depth and Breadth First Search<br>
d) Using level ordered search<br>
</b></p><i>Answer: c<br>
Explanation: We can implement topological sort by both BFS and DFS. In BFS, we use queue as data structure and in DFS, we use Linked list (if recursive) or Stack (if not recursive) as data structure.</i><p><b>7. Topological sort is equivalent to which of the traversals in trees?<br>
a) Pre-order traversal<br>
b) Post-order traversal<br>
c) In-order traversal<br>
d) Level-order traversal<br>
</b></p><i>Answer: a<br>
Explanation: In pre-order traversal of trees, we process the root first and then child from left to right.</i><p><b>8. A man wants to go different places in the world. He has listed them down all. But there are some places where he wants to visit before some other places. What application of graph can he use to determine that?<br>
a) Depth First Search<br>
b) Breadth First Search<br>
c) Topological Sorting<br>
d) Dijkstra’s Shortest path algorithm<br>
</b></p><i>Answer: c<br>
Explanation: As the definition of topological sorting suggests, it is the way to do tasks in prescribed order. So, if he does topological sorting, it will be easy for him to recognize what should be the order to visit different places.</i><p><b>9. When the topological sort of a graph is unique?<br>
a) When there exists a hamiltonian path in the graph<br>
b) In the presence of multiple nodes with indegree 0<br>
c) In the presence of single node with indegree 0<br>
d) In the presence of single node with outdegree 0<br>
</b></p><i>Answer: a<br>
Explanation: A hamiltonian path exists in a Directed Acyclic Graph when all pairs of consecutive vertices are in sorted order and are connected by edges. In such a case, there exists a unique topological sorting order.</i><p><b>1. Which of the following is an alternative name of the quickselect algorithm?<br>
a) quick sort<br>
b) hoare’s selection algorithm<br>
c) tony’s selection algorithm<br>
d) kruskal’s algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Quick select is a selection algorithm. It was developed by Tony Hoare, thus it is also known as Hoare’s selection algorithm.</i><p><b>2. Quickselect is an example of ___________<br>
a) sorting algorithm<br>
b) selection algorithm<br>
c) greedy algorithm<br>
d) searching algorithm<br>
</b></p><i>Answer: b<br>
Explanation: Quickselect is an example of a selection algorithm. It finds the kth smallest element from the given list.</i><p><b>3. What will be the output if quickselect algorithm is applied to the array arr={1,5,4,3,7} with k given as 4?<br>
a) 1<br>
b) 3<br>
c) 4<br>
d) 5<br>
</b></p><i>Answer: d<br>
Explanation: Quickselect algorithm finds the kth smallest element from the given list. So as here the given value of k is 4 so we need to find the fourth smallest element which is 5 in the given array.</i><p><b>4. What is the auxiliary space requirement of the quickselect algorithm?<br>
a) O(n<sup>2</sup>)<br>
b) O(n)<br>
c) O(n log n)<br>
d) O(1)<br>
</b></p><i>Answer: d<br>
Explanation: Quickselect algorithm requires no extra space in order to calculate the desired result. It performs manipulations in the given array itself so its auxiliary space requirement will be O(1).  </i><p><b>6. What is the best case time complexity of quickselect?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n)<br>
d) O(log n)<br>
</b></p><i>Answer: a<br>
Explanation: Quickselect’s auxiliary space requirement is O(1). So quickselect qualifies as an in-place algorithm.</i><p><b>7. Quickselect’s algorithm is similar to which of the following algorithm?<br>
a) Merge sort<br>
b) Quicksort<br>
c) Selection sort<br>
d) Counting sort<br>
</b></p><i>Answer: c<br>
Explanation: Best case time complexity of quickselect is O(n). It is observed in the case where good pivots are chosen consistently then the array size decreases exponentially and thus the required element is found in linear time.</i><p><b>8. What is the worst case time complexity of quickselect?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Both quicksort and quickselect algorithms are closely related. They were developed by the same person. Like quicksort, quickselect also works by choosing a pivot and partitioning array. </i><p><b>9. What is the average case time complexity of quickselect?<br>
a) O(n log n)<br>
b) O(n<sup>2</sup>)<br>
c) O(n)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: Worst case complexity occurs in the case where bad pivots are chosen consistently due to which the size of the array decreases in the steps of 1 only. This leads to a time complexity of O(n<sup>2</sup>).</i><p><b>10. Which of the following is a disadvantage of quickselect?<br>
a) Poor space complexity<br>
b) Poor best case time complexity<br>
c) Poor average case time complexity<br>
d) Poor worst case time complexity<br>
</b></p><i>Answer: c<br>
Explanation: In quickselect, we don’t recur for both portions of the array. Only that portion is considered where the smallest element lies. So this causes the average time complexity to be O(n).</i><p><b>11. Which of the following correctly represent the algorithm of quickselect?<br>
a)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw2">function</span> quickSelect<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span> k<span class="br0">)</span>
   <span class="kw1">if</span> left <span class="sy0">=</span> right
      <span class="kw1">return</span> list<span class="br0">[</span>left<span class="br0">]</span>
   Select a pivotIndex between left and right
   pivotIndex <span class="sy0">:=</span> partition<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span>  pivotIndex<span class="br0">)</span> 
   <span class="kw1">if</span> k <span class="sy0">=</span> pivotIndex
      <span class="kw1">return</span> list<span class="br0">[</span>k<span class="br0">]</span>
   <span class="kw1">else</span> <span class="kw1">if</span> k <span class="sy0">&lt;</span> pivotIndex
      right <span class="sy0">:=</span> pivotIndex <span class="sy0">-</span> <span class="nu0">1</span>
   <span class="kw1">else</span>
      left <span class="sy0">:=</span> pivotIndex <span class="sy0">+</span> <span class="nu0">1</span></pre></div></div></div></div></div></div><p><b>b)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw2">function</span> quickSelect<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span> k<span class="br0">)</span>
   <span class="kw1">if</span> left <span class="sy0">=</span> right
      <span class="kw1">return</span> list<span class="br0">[</span>right<span class="br0">]</span>
   Select a pivotIndex between left and right
   pivotIndex <span class="sy0">:=</span> partition<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span>  pivotIndex<span class="br0">)</span>
   <span class="kw1">if</span> k <span class="sy0">=</span> pivotIndex
      <span class="kw1">return</span> list<span class="br0">[</span>k<span class="br0">]</span>
   <span class="kw1">else</span> <span class="kw1">if</span> k <span class="sy0">&gt;</span> pivotIndex
      right <span class="sy0">:=</span> pivotIndex <span class="sy0">-</span> <span class="nu0">1</span>
   <span class="kw1">else</span>
      left <span class="sy0">:=</span> pivotIndex <span class="sy0">+</span> <span class="nu0">1</span></pre></div></div></div></div></div></div><p><b>c)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw2">function</span> quickSelect<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span> k<span class="br0">)</span>
   <span class="kw1">if</span> left <span class="sy0">=</span> right
      <span class="kw1">return</span> list<span class="br0">[</span>left<span class="br0">]</span>
   Select a pivotIndex between left and right
   pivotIndex <span class="sy0">:=</span> partition<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span>  pivotIndex<span class="br0">)</span>
   <span class="kw1">if</span> k <span class="sy0">=</span> pivotIndex
      <span class="kw1">return</span> list<span class="br0">[</span>k<span class="br0">]</span>
   <span class="kw1">else</span> <span class="kw1">if</span> k <span class="sy0">&lt;</span> pivotIndex
      right <span class="sy0">:=</span> pivotIndex <span class="sy0">+</span><span class="nu0">1</span>
   <span class="kw1">else</span>
      left <span class="sy0">:=</span> pivotIndex <span class="sy0">-</span><span class="nu0">1</span></pre></div></div></div></div></div></div><p><b>d)</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="kw2">function</span> quickSelect<span class="br0">(</span>list<span class="sy0">,</span> right<span class="sy0">,</span>left<span class="sy0">,</span> k<span class="br0">)</span>
   <span class="kw1">if</span> left <span class="sy0">=</span> right
      <span class="kw1">return</span> list<span class="br0">[</span>left<span class="br0">]</span>
   Select a pivotIndex between left and right
   pivotIndex <span class="sy0">:=</span> partition<span class="br0">(</span>list<span class="sy0">,</span> left<span class="sy0">,</span> right<span class="sy0">,</span>  pivotIndex<span class="br0">)</span>
   <span class="kw1">if</span> k <span class="sy0">=</span> pivotIndex
      <span class="kw1">return</span> list<span class="br0">[</span>k<span class="br0">]</span>
   <span class="kw1">else</span> <span class="kw1">if</span> k <span class="sy0">&lt;</span> pivotIndex
      right <span class="sy0">:=</span> pivotIndex <span class="sy0">-</span> <span class="nu0">1</span>
   <span class="kw1">else</span>
      left <span class="sy0">:=</span> pivotIndex <span class="sy0">+</span> <span class="nu0">1</span></pre></div></div></div></div></div></div><i>Answer: d<br>
Explanation: Quickselect has a poor worst case time complexity of O(n<sup>2</sup>). There are algorithms which have O(n) time complexity in the worst case.</i><p><b>1. What is co-ordinate compression?<br>
a) process of reassigning co-ordinates to remove gaps<br>
b) inserting gaps in a co-ordinate system<br>
c) removing redundant co-ordinates<br>
d) adding extra gaps<br>
</b></p><i>Answer: a<br>
Explanation: Co-ordinate compression is the process of reassigning co-ordinates in order to remove gaps. This helps in improving efficiency of a solution.</i><p><b>2. What is the need for co-ordinate compression?<br>
a) for improving time complexity<br>
b) for improving space complexity<br>
c) for improving both time and space complexity<br>
d) for making code simpler<br>
</b></p><i>Answer: c<br>
Explanation:Co-ordinate compression is the process of reassigning co-ordinates in order to remove gaps. This helps in improving both time and space complexity of a solution.</i><p><b>3. What is the output for the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span>  
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	vector <span class="sy0">&lt;</span>pair<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> <span class="sy0">&gt;</span> vec<span class="sy0">;</span>	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		vec.<span class="me1">push_back</span><span class="br0">(</span>make_pair<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	sort<span class="br0">(</span>vec.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">,</span> vec.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		a<span class="br0">[</span>vec<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">second</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
   	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) 4 3 0 1 2<br>
b) 1 2 3 4 5<br>
c) 5 4 1 2 3<br>
d) 0 1 2 3 4<br>
</b></p><i>Answer: a<br>
Explanation: The given code converts the elements of the input array. They are replaced with their respective position number in the sorted array.</i><p><b>4. What will be the time complexity of given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span>  
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	vector <span class="sy0">&lt;</span>pair<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> <span class="sy0">&gt;</span> vec<span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		vec.<span class="me1">push_back</span><span class="br0">(</span>make_pair<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 	
	sort<span class="br0">(</span>vec.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">,</span> vec.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		a<span class="br0">[</span>vec<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">second</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 	
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
   	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(n log n)<br>
c) O(n<sup>2</sup>)<br>
d) O(log n)<br>
</b></p><i>Answer: b<br>
Explanation: The time complexity of the given code will be governed by the time complexity of the sorting algorithm used. As this code uses in built sorting of C++ so it will take O(n log n) time.</i><p><b>5. What is the auxiliary space complexity of the given code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span>  
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	vector <span class="sy0">&lt;</span>pair<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> <span class="sy0">&gt;</span> vec<span class="sy0">;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		vec.<span class="me1">push_back</span><span class="br0">(</span>make_pair<span class="br0">(</span>a<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 	
	sort<span class="br0">(</span>vec.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">,</span> vec.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		a<span class="br0">[</span>vec<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">second</span><span class="br0">]</span> <span class="sy0">=</span> i<span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> a<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">7</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>  
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
   	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(1)<br>
b) O(n)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: b<br>
Explanation: The given code uses an auxiliary space of O(n). It is used by a vector which pairs each element of the array with their respective index number of the original array.</i><p><b>6. What will be the output of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> temp<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw3">memcpy</span><span class="br0">(</span>temp<span class="sy0">,</span> arr<span class="sy0">,</span> n<span class="sy0">*</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	sort<span class="br0">(</span>temp<span class="sy0">,</span> temp <span class="sy0">+</span> n<span class="br0">)</span><span class="sy0">;</span> 	
        unordered_map<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> map<span class="sy0">;</span> 	
	<span class="kw4">int</span> sort_index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		map<span class="br0">[</span>temp<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">=</span> sort_index<span class="sy0">++;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> map<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 	
	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><i>Answer: b<br>
Explanation: The given code converts the elements of input array. They are replaced with their respective position number in the sorted array.</i><p><b>a) 0 2 3 4<br>
b) 1 3 0 2<br>
c) 2 4 1 3<br>
d) 1 2 3 4<br>
</b></p><i>Answer: c<br>
Explanation: The time complexity of the given code will be governed by the time complexity of the sorting algorithm used. As this code uses inbuilt sorting of C++ so it will take O(n log n) time.</i><p><b>7. What is the time complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> temp<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw3">memcpy</span><span class="br0">(</span>temp<span class="sy0">,</span> arr<span class="sy0">,</span> n<span class="sy0">*</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	sort<span class="br0">(</span>temp<span class="sy0">,</span> temp <span class="sy0">+</span> n<span class="br0">)</span><span class="sy0">;</span> 	
        unordered_map<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> map<span class="sy0">;</span> 	
	<span class="kw4">int</span> sort_index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		map<span class="br0">[</span>temp<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">=</span> sort_index<span class="sy0">++;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> map<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">15</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">11</span><span class="sy0">,</span> <span class="nu0">50</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 	
	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(n log n)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: a<br>
Explanation: The given code uses an auxiliary space of O(n). It is used by a vector which pairs each element of the array with their respective index number of the original array.</i><p><b>8. What will be the auxiliary space complexity of the following code?</b></p><div class="hk1_style-wrap4"><div class="hk1_style-wrap3"><div class="hk1_style-wrap2"><div class="hk1_style-wrap"><div class="hk1_style"><div class="c"><pre class="de1"><span class="co2">#include &lt;bits/stdc++.h&gt; </span>
using namespace std<span class="sy0">;</span> 
<span class="kw4">void</span> convert<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 	
	<span class="kw4">int</span> temp<span class="br0">[</span>n<span class="br0">]</span><span class="sy0">;</span> 
	<span class="kw3">memcpy</span><span class="br0">(</span>temp<span class="sy0">,</span> arr<span class="sy0">,</span> n<span class="sy0">*</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> 
	sort<span class="br0">(</span>temp<span class="sy0">,</span> temp <span class="sy0">+</span> n<span class="br0">)</span><span class="sy0">;</span> 	
        unordered_map<span class="sy0">&lt;</span><span class="kw4">int</span><span class="sy0">,</span> int<span class="sy0">&gt;</span> map<span class="sy0">;</span> 	
	<span class="kw4">int</span> sort_index <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		map<span class="br0">[</span>temp<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span> <span class="sy0">=</span> sort_index<span class="sy0">++;</span> 	
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> map<span class="br0">[</span>arr<span class="br0">[</span>i<span class="br0">]</span><span class="br0">]</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">void</span> printArr<span class="br0">(</span><span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i<span class="sy0">&lt;</span>n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span> 
		cout <span class="sy0">&lt;&lt;</span> arr<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">&lt;&lt;</span> <span class="st0">" "</span><span class="sy0">;</span> 
<span class="br0">}</span> 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> 
<span class="br0">{</span> 
	<span class="kw4">int</span> arr<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu0">10</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">15</span><span class="sy0">,</span> <span class="nu0">12</span><span class="sy0">,</span> <span class="nu0">11</span><span class="sy0">,</span> <span class="nu0">50</span><span class="br0">}</span><span class="sy0">;</span> 
	<span class="kw4">int</span> n <span class="sy0">=</span> <span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">)</span><span class="sy0">/</span><span class="kw4">sizeof</span><span class="br0">(</span>arr<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span> 
	convert<span class="br0">(</span>arr <span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 	
	printArr<span class="br0">(</span>arr<span class="sy0">,</span> n<span class="br0">)</span><span class="sy0">;</span> 
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> 
<span class="br0">}</span></pre></div></div></div></div></div></div><p><b>a) O(n)<br>
b) O(1)<br>
c) O(log n)<br>
d) O(n log n)<br>
</b></p><i>Answer: a<br>
Explanation: The idea behind co-ordinate compression is to reduce the number of squares in a graph by converting them into rectangles of viable size. This reduces the time complexity of traversal.</i><p><b>1. What is the purpose of using square root decomposition?<br>
a) to reduce the time complexity of a code<br>
b) to increase the space complexity of a code<br>
c) to reduce the space complexity of a code<br>
d) to reduce the space and time complexity of a code<br>
</b></p><i>Answer: a<br>
Explanation: Square decomposition is mainly used in competitive programming to optimize code. It reduces the time complexity by a factor of √n.</i><p><b>2. By what factor time complexity is reduced when we apply square root decomposition to a code?<br>
a) n<br>
b) √n<br>
c) n<sup>2</sup><br>
d) n<sup>-1/2</sup><br>
</b></p><i>Answer: b<br>
Explanation: In square root decomposition a given array is decomposed into small parts each of size √n. This reduces the time complexity of the code by a factor of √n.</i><p><b>3. What will be the worst case time complexity of finding the sum of elements in a given range of (l,r) in an array of size n?<br>
a) O(n)<br>
b) O(l+r)<br>
c) O(l-r)<br>
d) O(r-l)<br>
</b></p><i>Answer: a<br>
Explanation: For a given array of size n we have to traverse all n elements in the worst case. In such a case l=0, r=n-1 so the time complexity will be O(n).  </i><p><b>4. What will be the worst case time complexity of finding the sum of elements in a given range of (l,r) in an array of size n when we use square root optimization?<br>
a) O(n)<br>
b) O(l+r)<br>
c) O(√n)<br>
d) O(r-l)<br>
</b></p><i>Answer: c<br>
Explanation: When we use square root optimization we decompose the given array into √n chunks each of size √n. So after calculating the sum of each chunk individually, we require to iterate only 3*√n times to calculate the sum in the worst case.</i><p><b>5. Total how many iterations are required to find the sum of elements in a given range of (l,r) in an array of size n when we use square root optimization?<br>
a) √n<br>
b) 2*√n<br>
c) 3*√n<br>
d) n*√n<br>
</b></p><i>Answer: c<br>
Explanation: After calculating the sum of each chunk individually we require to iterate only 3*√n times to calculate the sum in the worst case. It is because two of the √n factors consider the worst case time complexity of summing elements in the first and last block. Whereas the third √n considers the factor of summing the √n chunks.</i><p><b>6. What will be the time complexity of update query operation in an array of size n when we use square root optimization?<br>
a) O(√n)<br>
b) O(n)<br>
c) O(1)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer:c<br>
Explanation: The time complexity of query operation remains the same in both square root optimized code and non optimized code. We simply find the chunk in which the update requires to be performed and then add the new updated value at the desired index.</i><p><b>8. What will be the worst case time complexity of code to find sum in given query range (l,r) in an array of size n with q number of such queries?<br>
a) O(n)<br>
b) O(q)<br>
c) O(n*q)<br>
d) O(n+q)<br>
</b></p><i>Answer: b<br>
Explanation: Square root decomposition technique can be applied to an array with any number of indices. It does not require this number to be a perfect square.</i><p><b>9. What will be the worst case time complexity of code to find sum in given query range (l,r) in an array of size n with q number of such queries when we apply MO’s algorithm?<br>
a) O(n*q)<br>
b) O(n)<br>
c) O((q+n)√n)<br>
d) O(q*√n)<br>
</b></p><i>Answer: c<br>
Explanation: For finding the result of one query the worst case time complexity will be n. So for q queries the time complexity will be O(q*n). This can be reduced by using square root optimization.</i><p><b>11. What will be the time complexity of the code to find a minimum element from an array of size n and uses square root decomposition(exclude pre processing time)?<br>
a) O(√n)<br>
b) O(n)<br>
c) O(1)<br>
d) O(n<sup>2</sup>)<br>
</b></p><i>Answer: c<br>
Explanation: Mo’s algorithm requires O(q*√n) + O(n*√n) time for processing all the queries. It is better than the naive solution where O(n*q) time is required.</i></html> </body>